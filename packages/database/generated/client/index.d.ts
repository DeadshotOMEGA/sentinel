
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model Checkin
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Checkin = $Result.DefaultSelection<Prisma.$CheckinPayload>
/**
 * Model Division
 * 
 */
export type Division = $Result.DefaultSelection<Prisma.$DivisionPayload>
/**
 * Model EventAttendee
 * 
 */
export type EventAttendee = $Result.DefaultSelection<Prisma.$EventAttendeePayload>
/**
 * Model EventCheckin
 * 
 */
export type EventCheckin = $Result.DefaultSelection<Prisma.$EventCheckinPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model MemberTag
 * 
 */
export type MemberTag = $Result.DefaultSelection<Prisma.$MemberTagPayload>
/**
 * Model SecurityAlert
 * 
 */
export type SecurityAlert = $Result.DefaultSelection<Prisma.$SecurityAlertPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model BmqCourse
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type BmqCourse = $Result.DefaultSelection<Prisma.$BmqCoursePayload>
/**
 * Model BmqEnrollment
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type BmqEnrollment = $Result.DefaultSelection<Prisma.$BmqEnrollmentPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model report_audit_log
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type report_audit_log = $Result.DefaultSelection<Prisma.$report_audit_logPayload>
/**
 * Model ReportSetting
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ReportSetting = $Result.DefaultSelection<Prisma.$ReportSettingPayload>
/**
 * Model TrainingYear
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type TrainingYear = $Result.DefaultSelection<Prisma.$TrainingYearPayload>
/**
 * Model DdsAssignment
 * 
 */
export type DdsAssignment = $Result.DefaultSelection<Prisma.$DdsAssignmentPayload>
/**
 * Model ResponsibilityAuditLog
 * 
 */
export type ResponsibilityAuditLog = $Result.DefaultSelection<Prisma.$ResponsibilityAuditLogPayload>
/**
 * Model MemberStatus
 * 
 */
export type MemberStatus = $Result.DefaultSelection<Prisma.$MemberStatusPayload>
/**
 * Model MemberType
 * 
 */
export type MemberType = $Result.DefaultSelection<Prisma.$MemberTypePayload>
/**
 * Model VisitType
 * 
 */
export type VisitType = $Result.DefaultSelection<Prisma.$VisitTypePayload>
/**
 * Model BadgeStatus
 * 
 */
export type BadgeStatus = $Result.DefaultSelection<Prisma.$BadgeStatusPayload>
/**
 * Model ListItem
 * 
 */
export type ListItem = $Result.DefaultSelection<Prisma.$ListItemPayload>
/**
 * Model Rank
 * 
 */
export type Rank = $Result.DefaultSelection<Prisma.$RankPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model AlertConfig
 * 
 */
export type AlertConfig = $Result.DefaultSelection<Prisma.$AlertConfigPayload>
/**
 * Model StatHoliday
 * 
 */
export type StatHoliday = $Result.DefaultSelection<Prisma.$StatHolidayPayload>
/**
 * Model QualificationType
 * 
 */
export type QualificationType = $Result.DefaultSelection<Prisma.$QualificationTypePayload>
/**
 * Model MemberQualification
 * 
 */
export type MemberQualification = $Result.DefaultSelection<Prisma.$MemberQualificationPayload>
/**
 * Model DutyRole
 * 
 */
export type DutyRole = $Result.DefaultSelection<Prisma.$DutyRolePayload>
/**
 * Model DutyPosition
 * 
 */
export type DutyPosition = $Result.DefaultSelection<Prisma.$DutyPositionPayload>
/**
 * Model WeeklySchedule
 * 
 */
export type WeeklySchedule = $Result.DefaultSelection<Prisma.$WeeklySchedulePayload>
/**
 * Model ScheduleAssignment
 * 
 */
export type ScheduleAssignment = $Result.DefaultSelection<Prisma.$ScheduleAssignmentPayload>
/**
 * Model LockupStatus
 * 
 */
export type LockupStatus = $Result.DefaultSelection<Prisma.$LockupStatusPayload>
/**
 * Model LockupTransfer
 * 
 */
export type LockupTransfer = $Result.DefaultSelection<Prisma.$LockupTransferPayload>
/**
 * Model LockupExecution
 * 
 */
export type LockupExecution = $Result.DefaultSelection<Prisma.$LockupExecutionPayload>
/**
 * Model MissedCheckout
 * 
 */
export type MissedCheckout = $Result.DefaultSelection<Prisma.$MissedCheckoutPayload>
/**
 * Model UnitEventType
 * 
 */
export type UnitEventType = $Result.DefaultSelection<Prisma.$UnitEventTypePayload>
/**
 * Model UnitEvent
 * 
 */
export type UnitEvent = $Result.DefaultSelection<Prisma.$UnitEventPayload>
/**
 * Model UnitEventDutyPosition
 * 
 */
export type UnitEventDutyPosition = $Result.DefaultSelection<Prisma.$UnitEventDutyPositionPayload>
/**
 * Model UnitEventDutyAssignment
 * 
 */
export type UnitEventDutyAssignment = $Result.DefaultSelection<Prisma.$UnitEventDutyAssignmentPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdminUsers
 * const adminUsers = await prisma.adminUser.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdminUsers
   * const adminUsers = await prisma.adminUser.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkin`: Exposes CRUD operations for the **Checkin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkins
    * const checkins = await prisma.checkin.findMany()
    * ```
    */
  get checkin(): Prisma.CheckinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.division`: Exposes CRUD operations for the **Division** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.division.findMany()
    * ```
    */
  get division(): Prisma.DivisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventAttendee`: Exposes CRUD operations for the **EventAttendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventAttendees
    * const eventAttendees = await prisma.eventAttendee.findMany()
    * ```
    */
  get eventAttendee(): Prisma.EventAttendeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventCheckin`: Exposes CRUD operations for the **EventCheckin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCheckins
    * const eventCheckins = await prisma.eventCheckin.findMany()
    * ```
    */
  get eventCheckin(): Prisma.EventCheckinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberTag`: Exposes CRUD operations for the **MemberTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberTags
    * const memberTags = await prisma.memberTag.findMany()
    * ```
    */
  get memberTag(): Prisma.MemberTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityAlert`: Exposes CRUD operations for the **SecurityAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityAlerts
    * const securityAlerts = await prisma.securityAlert.findMany()
    * ```
    */
  get securityAlert(): Prisma.SecurityAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmqCourse`: Exposes CRUD operations for the **BmqCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmqCourses
    * const bmqCourses = await prisma.bmqCourse.findMany()
    * ```
    */
  get bmqCourse(): Prisma.BmqCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmqEnrollment`: Exposes CRUD operations for the **BmqEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmqEnrollments
    * const bmqEnrollments = await prisma.bmqEnrollment.findMany()
    * ```
    */
  get bmqEnrollment(): Prisma.BmqEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report_audit_log`: Exposes CRUD operations for the **report_audit_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_audit_logs
    * const report_audit_logs = await prisma.report_audit_log.findMany()
    * ```
    */
  get report_audit_log(): Prisma.report_audit_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportSetting`: Exposes CRUD operations for the **ReportSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportSettings
    * const reportSettings = await prisma.reportSetting.findMany()
    * ```
    */
  get reportSetting(): Prisma.ReportSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingYear`: Exposes CRUD operations for the **TrainingYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingYears
    * const trainingYears = await prisma.trainingYear.findMany()
    * ```
    */
  get trainingYear(): Prisma.TrainingYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ddsAssignment`: Exposes CRUD operations for the **DdsAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DdsAssignments
    * const ddsAssignments = await prisma.ddsAssignment.findMany()
    * ```
    */
  get ddsAssignment(): Prisma.DdsAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.responsibilityAuditLog`: Exposes CRUD operations for the **ResponsibilityAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponsibilityAuditLogs
    * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany()
    * ```
    */
  get responsibilityAuditLog(): Prisma.ResponsibilityAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberStatus`: Exposes CRUD operations for the **MemberStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberStatuses
    * const memberStatuses = await prisma.memberStatus.findMany()
    * ```
    */
  get memberStatus(): Prisma.MemberStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberType`: Exposes CRUD operations for the **MemberType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberTypes
    * const memberTypes = await prisma.memberType.findMany()
    * ```
    */
  get memberType(): Prisma.MemberTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitType`: Exposes CRUD operations for the **VisitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitTypes
    * const visitTypes = await prisma.visitType.findMany()
    * ```
    */
  get visitType(): Prisma.VisitTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badgeStatus`: Exposes CRUD operations for the **BadgeStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BadgeStatuses
    * const badgeStatuses = await prisma.badgeStatus.findMany()
    * ```
    */
  get badgeStatus(): Prisma.BadgeStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listItem`: Exposes CRUD operations for the **ListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListItems
    * const listItems = await prisma.listItem.findMany()
    * ```
    */
  get listItem(): Prisma.ListItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rank`: Exposes CRUD operations for the **Rank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ranks
    * const ranks = await prisma.rank.findMany()
    * ```
    */
  get rank(): Prisma.RankDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertConfig`: Exposes CRUD operations for the **AlertConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertConfigs
    * const alertConfigs = await prisma.alertConfig.findMany()
    * ```
    */
  get alertConfig(): Prisma.AlertConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statHoliday`: Exposes CRUD operations for the **StatHoliday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatHolidays
    * const statHolidays = await prisma.statHoliday.findMany()
    * ```
    */
  get statHoliday(): Prisma.StatHolidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualificationType`: Exposes CRUD operations for the **QualificationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualificationTypes
    * const qualificationTypes = await prisma.qualificationType.findMany()
    * ```
    */
  get qualificationType(): Prisma.QualificationTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberQualification`: Exposes CRUD operations for the **MemberQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberQualifications
    * const memberQualifications = await prisma.memberQualification.findMany()
    * ```
    */
  get memberQualification(): Prisma.MemberQualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dutyRole`: Exposes CRUD operations for the **DutyRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DutyRoles
    * const dutyRoles = await prisma.dutyRole.findMany()
    * ```
    */
  get dutyRole(): Prisma.DutyRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dutyPosition`: Exposes CRUD operations for the **DutyPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DutyPositions
    * const dutyPositions = await prisma.dutyPosition.findMany()
    * ```
    */
  get dutyPosition(): Prisma.DutyPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklySchedule`: Exposes CRUD operations for the **WeeklySchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklySchedules
    * const weeklySchedules = await prisma.weeklySchedule.findMany()
    * ```
    */
  get weeklySchedule(): Prisma.WeeklyScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleAssignment`: Exposes CRUD operations for the **ScheduleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleAssignments
    * const scheduleAssignments = await prisma.scheduleAssignment.findMany()
    * ```
    */
  get scheduleAssignment(): Prisma.ScheduleAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lockupStatus`: Exposes CRUD operations for the **LockupStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LockupStatuses
    * const lockupStatuses = await prisma.lockupStatus.findMany()
    * ```
    */
  get lockupStatus(): Prisma.LockupStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lockupTransfer`: Exposes CRUD operations for the **LockupTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LockupTransfers
    * const lockupTransfers = await prisma.lockupTransfer.findMany()
    * ```
    */
  get lockupTransfer(): Prisma.LockupTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lockupExecution`: Exposes CRUD operations for the **LockupExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LockupExecutions
    * const lockupExecutions = await prisma.lockupExecution.findMany()
    * ```
    */
  get lockupExecution(): Prisma.LockupExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.missedCheckout`: Exposes CRUD operations for the **MissedCheckout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissedCheckouts
    * const missedCheckouts = await prisma.missedCheckout.findMany()
    * ```
    */
  get missedCheckout(): Prisma.MissedCheckoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitEventType`: Exposes CRUD operations for the **UnitEventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitEventTypes
    * const unitEventTypes = await prisma.unitEventType.findMany()
    * ```
    */
  get unitEventType(): Prisma.UnitEventTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitEvent`: Exposes CRUD operations for the **UnitEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitEvents
    * const unitEvents = await prisma.unitEvent.findMany()
    * ```
    */
  get unitEvent(): Prisma.UnitEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitEventDutyPosition`: Exposes CRUD operations for the **UnitEventDutyPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitEventDutyPositions
    * const unitEventDutyPositions = await prisma.unitEventDutyPosition.findMany()
    * ```
    */
  get unitEventDutyPosition(): Prisma.UnitEventDutyPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitEventDutyAssignment`: Exposes CRUD operations for the **UnitEventDutyAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitEventDutyAssignments
    * const unitEventDutyAssignments = await prisma.unitEventDutyAssignment.findMany()
    * ```
    */
  get unitEventDutyAssignment(): Prisma.UnitEventDutyAssignmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AdminUser: 'AdminUser',
    AuditLog: 'AuditLog',
    Badge: 'Badge',
    Checkin: 'Checkin',
    Division: 'Division',
    EventAttendee: 'EventAttendee',
    EventCheckin: 'EventCheckin',
    Event: 'Event',
    Member: 'Member',
    Tag: 'Tag',
    MemberTag: 'MemberTag',
    SecurityAlert: 'SecurityAlert',
    Visitor: 'Visitor',
    BmqCourse: 'BmqCourse',
    BmqEnrollment: 'BmqEnrollment',
    migrations: 'migrations',
    report_audit_log: 'report_audit_log',
    ReportSetting: 'ReportSetting',
    TrainingYear: 'TrainingYear',
    DdsAssignment: 'DdsAssignment',
    ResponsibilityAuditLog: 'ResponsibilityAuditLog',
    MemberStatus: 'MemberStatus',
    MemberType: 'MemberType',
    VisitType: 'VisitType',
    BadgeStatus: 'BadgeStatus',
    ListItem: 'ListItem',
    Rank: 'Rank',
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Setting: 'Setting',
    AlertConfig: 'AlertConfig',
    StatHoliday: 'StatHoliday',
    QualificationType: 'QualificationType',
    MemberQualification: 'MemberQualification',
    DutyRole: 'DutyRole',
    DutyPosition: 'DutyPosition',
    WeeklySchedule: 'WeeklySchedule',
    ScheduleAssignment: 'ScheduleAssignment',
    LockupStatus: 'LockupStatus',
    LockupTransfer: 'LockupTransfer',
    LockupExecution: 'LockupExecution',
    MissedCheckout: 'MissedCheckout',
    UnitEventType: 'UnitEventType',
    UnitEvent: 'UnitEvent',
    UnitEventDutyPosition: 'UnitEventDutyPosition',
    UnitEventDutyAssignment: 'UnitEventDutyAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "adminUser" | "auditLog" | "badge" | "checkin" | "division" | "eventAttendee" | "eventCheckin" | "event" | "member" | "tag" | "memberTag" | "securityAlert" | "visitor" | "bmqCourse" | "bmqEnrollment" | "migrations" | "report_audit_log" | "reportSetting" | "trainingYear" | "ddsAssignment" | "responsibilityAuditLog" | "memberStatus" | "memberType" | "visitType" | "badgeStatus" | "listItem" | "rank" | "user" | "session" | "account" | "verification" | "setting" | "alertConfig" | "statHoliday" | "qualificationType" | "memberQualification" | "dutyRole" | "dutyPosition" | "weeklySchedule" | "scheduleAssignment" | "lockupStatus" | "lockupTransfer" | "lockupExecution" | "missedCheckout" | "unitEventType" | "unitEvent" | "unitEventDutyPosition" | "unitEventDutyAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      Checkin: {
        payload: Prisma.$CheckinPayload<ExtArgs>
        fields: Prisma.CheckinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          findFirst: {
            args: Prisma.CheckinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          findMany: {
            args: Prisma.CheckinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          create: {
            args: Prisma.CheckinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          createMany: {
            args: Prisma.CheckinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          delete: {
            args: Prisma.CheckinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          update: {
            args: Prisma.CheckinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          deleteMany: {
            args: Prisma.CheckinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          upsert: {
            args: Prisma.CheckinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          aggregate: {
            args: Prisma.CheckinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckin>
          }
          groupBy: {
            args: Prisma.CheckinGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckinGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckinCountArgs<ExtArgs>
            result: $Utils.Optional<CheckinCountAggregateOutputType> | number
          }
        }
      }
      Division: {
        payload: Prisma.$DivisionPayload<ExtArgs>
        fields: Prisma.DivisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DivisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DivisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findFirst: {
            args: Prisma.DivisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DivisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findMany: {
            args: Prisma.DivisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          create: {
            args: Prisma.DivisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          createMany: {
            args: Prisma.DivisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DivisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          delete: {
            args: Prisma.DivisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          update: {
            args: Prisma.DivisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          deleteMany: {
            args: Prisma.DivisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DivisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DivisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          upsert: {
            args: Prisma.DivisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          aggregate: {
            args: Prisma.DivisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDivision>
          }
          groupBy: {
            args: Prisma.DivisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DivisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DivisionCountArgs<ExtArgs>
            result: $Utils.Optional<DivisionCountAggregateOutputType> | number
          }
        }
      }
      EventAttendee: {
        payload: Prisma.$EventAttendeePayload<ExtArgs>
        fields: Prisma.EventAttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventAttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventAttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findFirst: {
            args: Prisma.EventAttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventAttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findMany: {
            args: Prisma.EventAttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          create: {
            args: Prisma.EventAttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          createMany: {
            args: Prisma.EventAttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventAttendeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          delete: {
            args: Prisma.EventAttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          update: {
            args: Prisma.EventAttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          deleteMany: {
            args: Prisma.EventAttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventAttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventAttendeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          upsert: {
            args: Prisma.EventAttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          aggregate: {
            args: Prisma.EventAttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventAttendee>
          }
          groupBy: {
            args: Prisma.EventAttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventAttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeCountAggregateOutputType> | number
          }
        }
      }
      EventCheckin: {
        payload: Prisma.$EventCheckinPayload<ExtArgs>
        fields: Prisma.EventCheckinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCheckinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCheckinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          findFirst: {
            args: Prisma.EventCheckinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCheckinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          findMany: {
            args: Prisma.EventCheckinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          create: {
            args: Prisma.EventCheckinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          createMany: {
            args: Prisma.EventCheckinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCheckinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          delete: {
            args: Prisma.EventCheckinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          update: {
            args: Prisma.EventCheckinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          deleteMany: {
            args: Prisma.EventCheckinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCheckinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventCheckinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          upsert: {
            args: Prisma.EventCheckinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          aggregate: {
            args: Prisma.EventCheckinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCheckin>
          }
          groupBy: {
            args: Prisma.EventCheckinGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCheckinGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCheckinCountArgs<ExtArgs>
            result: $Utils.Optional<EventCheckinCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      MemberTag: {
        payload: Prisma.$MemberTagPayload<ExtArgs>
        fields: Prisma.MemberTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          findFirst: {
            args: Prisma.MemberTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          findMany: {
            args: Prisma.MemberTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          create: {
            args: Prisma.MemberTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          createMany: {
            args: Prisma.MemberTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          delete: {
            args: Prisma.MemberTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          update: {
            args: Prisma.MemberTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          deleteMany: {
            args: Prisma.MemberTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          upsert: {
            args: Prisma.MemberTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          aggregate: {
            args: Prisma.MemberTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberTag>
          }
          groupBy: {
            args: Prisma.MemberTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberTagCountArgs<ExtArgs>
            result: $Utils.Optional<MemberTagCountAggregateOutputType> | number
          }
        }
      }
      SecurityAlert: {
        payload: Prisma.$SecurityAlertPayload<ExtArgs>
        fields: Prisma.SecurityAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findFirst: {
            args: Prisma.SecurityAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findMany: {
            args: Prisma.SecurityAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          create: {
            args: Prisma.SecurityAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          createMany: {
            args: Prisma.SecurityAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          delete: {
            args: Prisma.SecurityAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          update: {
            args: Prisma.SecurityAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          deleteMany: {
            args: Prisma.SecurityAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          upsert: {
            args: Prisma.SecurityAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          aggregate: {
            args: Prisma.SecurityAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityAlert>
          }
          groupBy: {
            args: Prisma.SecurityAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityAlertCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      BmqCourse: {
        payload: Prisma.$BmqCoursePayload<ExtArgs>
        fields: Prisma.BmqCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmqCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmqCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          findFirst: {
            args: Prisma.BmqCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmqCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          findMany: {
            args: Prisma.BmqCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          create: {
            args: Prisma.BmqCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          createMany: {
            args: Prisma.BmqCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BmqCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          delete: {
            args: Prisma.BmqCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          update: {
            args: Prisma.BmqCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          deleteMany: {
            args: Prisma.BmqCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmqCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BmqCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          upsert: {
            args: Prisma.BmqCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          aggregate: {
            args: Prisma.BmqCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmqCourse>
          }
          groupBy: {
            args: Prisma.BmqCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmqCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmqCourseCountArgs<ExtArgs>
            result: $Utils.Optional<BmqCourseCountAggregateOutputType> | number
          }
        }
      }
      BmqEnrollment: {
        payload: Prisma.$BmqEnrollmentPayload<ExtArgs>
        fields: Prisma.BmqEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmqEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.BmqEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmqEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          findMany: {
            args: Prisma.BmqEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          create: {
            args: Prisma.BmqEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          createMany: {
            args: Prisma.BmqEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BmqEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.BmqEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          update: {
            args: Prisma.BmqEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.BmqEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmqEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.BmqEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.BmqEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmqEnrollment>
          }
          groupBy: {
            args: Prisma.BmqEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmqEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmqEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<BmqEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      report_audit_log: {
        payload: Prisma.$report_audit_logPayload<ExtArgs>
        fields: Prisma.report_audit_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.report_audit_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.report_audit_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          findFirst: {
            args: Prisma.report_audit_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.report_audit_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          findMany: {
            args: Prisma.report_audit_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          create: {
            args: Prisma.report_audit_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          createMany: {
            args: Prisma.report_audit_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.report_audit_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          delete: {
            args: Prisma.report_audit_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          update: {
            args: Prisma.report_audit_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          deleteMany: {
            args: Prisma.report_audit_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.report_audit_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.report_audit_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          upsert: {
            args: Prisma.report_audit_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          aggregate: {
            args: Prisma.Report_audit_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport_audit_log>
          }
          groupBy: {
            args: Prisma.report_audit_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Report_audit_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.report_audit_logCountArgs<ExtArgs>
            result: $Utils.Optional<Report_audit_logCountAggregateOutputType> | number
          }
        }
      }
      ReportSetting: {
        payload: Prisma.$ReportSettingPayload<ExtArgs>
        fields: Prisma.ReportSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          findFirst: {
            args: Prisma.ReportSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          findMany: {
            args: Prisma.ReportSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          create: {
            args: Prisma.ReportSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          createMany: {
            args: Prisma.ReportSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          delete: {
            args: Prisma.ReportSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          update: {
            args: Prisma.ReportSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          deleteMany: {
            args: Prisma.ReportSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          upsert: {
            args: Prisma.ReportSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          aggregate: {
            args: Prisma.ReportSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportSetting>
          }
          groupBy: {
            args: Prisma.ReportSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportSettingCountArgs<ExtArgs>
            result: $Utils.Optional<ReportSettingCountAggregateOutputType> | number
          }
        }
      }
      TrainingYear: {
        payload: Prisma.$TrainingYearPayload<ExtArgs>
        fields: Prisma.TrainingYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          findFirst: {
            args: Prisma.TrainingYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          findMany: {
            args: Prisma.TrainingYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          create: {
            args: Prisma.TrainingYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          createMany: {
            args: Prisma.TrainingYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          delete: {
            args: Prisma.TrainingYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          update: {
            args: Prisma.TrainingYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          deleteMany: {
            args: Prisma.TrainingYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          upsert: {
            args: Prisma.TrainingYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          aggregate: {
            args: Prisma.TrainingYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingYear>
          }
          groupBy: {
            args: Prisma.TrainingYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingYearCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingYearCountAggregateOutputType> | number
          }
        }
      }
      DdsAssignment: {
        payload: Prisma.$DdsAssignmentPayload<ExtArgs>
        fields: Prisma.DdsAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DdsAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DdsAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DdsAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DdsAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          findMany: {
            args: Prisma.DdsAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          create: {
            args: Prisma.DdsAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          createMany: {
            args: Prisma.DdsAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DdsAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DdsAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          update: {
            args: Prisma.DdsAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DdsAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DdsAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DdsAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DdsAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DdsAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDdsAssignment>
          }
          groupBy: {
            args: Prisma.DdsAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DdsAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DdsAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DdsAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ResponsibilityAuditLog: {
        payload: Prisma.$ResponsibilityAuditLogPayload<ExtArgs>
        fields: Prisma.ResponsibilityAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponsibilityAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          findFirst: {
            args: Prisma.ResponsibilityAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          findMany: {
            args: Prisma.ResponsibilityAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          create: {
            args: Prisma.ResponsibilityAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          createMany: {
            args: Prisma.ResponsibilityAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          delete: {
            args: Prisma.ResponsibilityAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          update: {
            args: Prisma.ResponsibilityAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.ResponsibilityAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponsibilityAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.ResponsibilityAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          aggregate: {
            args: Prisma.ResponsibilityAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsibilityAuditLog>
          }
          groupBy: {
            args: Prisma.ResponsibilityAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponsibilityAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityAuditLogCountAggregateOutputType> | number
          }
        }
      }
      MemberStatus: {
        payload: Prisma.$MemberStatusPayload<ExtArgs>
        fields: Prisma.MemberStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          findFirst: {
            args: Prisma.MemberStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          findMany: {
            args: Prisma.MemberStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          create: {
            args: Prisma.MemberStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          createMany: {
            args: Prisma.MemberStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          delete: {
            args: Prisma.MemberStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          update: {
            args: Prisma.MemberStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          deleteMany: {
            args: Prisma.MemberStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          upsert: {
            args: Prisma.MemberStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          aggregate: {
            args: Prisma.MemberStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberStatus>
          }
          groupBy: {
            args: Prisma.MemberStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MemberStatusCountAggregateOutputType> | number
          }
        }
      }
      MemberType: {
        payload: Prisma.$MemberTypePayload<ExtArgs>
        fields: Prisma.MemberTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          findFirst: {
            args: Prisma.MemberTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          findMany: {
            args: Prisma.MemberTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          create: {
            args: Prisma.MemberTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          createMany: {
            args: Prisma.MemberTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          delete: {
            args: Prisma.MemberTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          update: {
            args: Prisma.MemberTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          deleteMany: {
            args: Prisma.MemberTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          upsert: {
            args: Prisma.MemberTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          aggregate: {
            args: Prisma.MemberTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberType>
          }
          groupBy: {
            args: Prisma.MemberTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberTypeCountArgs<ExtArgs>
            result: $Utils.Optional<MemberTypeCountAggregateOutputType> | number
          }
        }
      }
      VisitType: {
        payload: Prisma.$VisitTypePayload<ExtArgs>
        fields: Prisma.VisitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findFirst: {
            args: Prisma.VisitTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findMany: {
            args: Prisma.VisitTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          create: {
            args: Prisma.VisitTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          createMany: {
            args: Prisma.VisitTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          delete: {
            args: Prisma.VisitTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          update: {
            args: Prisma.VisitTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          deleteMany: {
            args: Prisma.VisitTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          upsert: {
            args: Prisma.VisitTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          aggregate: {
            args: Prisma.VisitTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitType>
          }
          groupBy: {
            args: Prisma.VisitTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VisitTypeCountAggregateOutputType> | number
          }
        }
      }
      BadgeStatus: {
        payload: Prisma.$BadgeStatusPayload<ExtArgs>
        fields: Prisma.BadgeStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          findFirst: {
            args: Prisma.BadgeStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          findMany: {
            args: Prisma.BadgeStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          create: {
            args: Prisma.BadgeStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          createMany: {
            args: Prisma.BadgeStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          delete: {
            args: Prisma.BadgeStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          update: {
            args: Prisma.BadgeStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          deleteMany: {
            args: Prisma.BadgeStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          upsert: {
            args: Prisma.BadgeStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          aggregate: {
            args: Prisma.BadgeStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadgeStatus>
          }
          groupBy: {
            args: Prisma.BadgeStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeStatusCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeStatusCountAggregateOutputType> | number
          }
        }
      }
      ListItem: {
        payload: Prisma.$ListItemPayload<ExtArgs>
        fields: Prisma.ListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findFirst: {
            args: Prisma.ListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findMany: {
            args: Prisma.ListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          create: {
            args: Prisma.ListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          createMany: {
            args: Prisma.ListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          delete: {
            args: Prisma.ListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          update: {
            args: Prisma.ListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          deleteMany: {
            args: Prisma.ListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          upsert: {
            args: Prisma.ListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          aggregate: {
            args: Prisma.ListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListItem>
          }
          groupBy: {
            args: Prisma.ListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListItemCountArgs<ExtArgs>
            result: $Utils.Optional<ListItemCountAggregateOutputType> | number
          }
        }
      }
      Rank: {
        payload: Prisma.$RankPayload<ExtArgs>
        fields: Prisma.RankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          findFirst: {
            args: Prisma.RankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          findMany: {
            args: Prisma.RankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>[]
          }
          create: {
            args: Prisma.RankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          createMany: {
            args: Prisma.RankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RankCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>[]
          }
          delete: {
            args: Prisma.RankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          update: {
            args: Prisma.RankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          deleteMany: {
            args: Prisma.RankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RankUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>[]
          }
          upsert: {
            args: Prisma.RankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          aggregate: {
            args: Prisma.RankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRank>
          }
          groupBy: {
            args: Prisma.RankGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankCountArgs<ExtArgs>
            result: $Utils.Optional<RankCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      AlertConfig: {
        payload: Prisma.$AlertConfigPayload<ExtArgs>
        fields: Prisma.AlertConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          findFirst: {
            args: Prisma.AlertConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          findMany: {
            args: Prisma.AlertConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          create: {
            args: Prisma.AlertConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          createMany: {
            args: Prisma.AlertConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          delete: {
            args: Prisma.AlertConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          update: {
            args: Prisma.AlertConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          deleteMany: {
            args: Prisma.AlertConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          upsert: {
            args: Prisma.AlertConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          aggregate: {
            args: Prisma.AlertConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertConfig>
          }
          groupBy: {
            args: Prisma.AlertConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AlertConfigCountAggregateOutputType> | number
          }
        }
      }
      StatHoliday: {
        payload: Prisma.$StatHolidayPayload<ExtArgs>
        fields: Prisma.StatHolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatHolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatHolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          findFirst: {
            args: Prisma.StatHolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatHolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          findMany: {
            args: Prisma.StatHolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>[]
          }
          create: {
            args: Prisma.StatHolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          createMany: {
            args: Prisma.StatHolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatHolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>[]
          }
          delete: {
            args: Prisma.StatHolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          update: {
            args: Prisma.StatHolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          deleteMany: {
            args: Prisma.StatHolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatHolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatHolidayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>[]
          }
          upsert: {
            args: Prisma.StatHolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatHolidayPayload>
          }
          aggregate: {
            args: Prisma.StatHolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatHoliday>
          }
          groupBy: {
            args: Prisma.StatHolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatHolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatHolidayCountArgs<ExtArgs>
            result: $Utils.Optional<StatHolidayCountAggregateOutputType> | number
          }
        }
      }
      QualificationType: {
        payload: Prisma.$QualificationTypePayload<ExtArgs>
        fields: Prisma.QualificationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualificationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualificationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          findFirst: {
            args: Prisma.QualificationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualificationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          findMany: {
            args: Prisma.QualificationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>[]
          }
          create: {
            args: Prisma.QualificationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          createMany: {
            args: Prisma.QualificationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualificationTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>[]
          }
          delete: {
            args: Prisma.QualificationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          update: {
            args: Prisma.QualificationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          deleteMany: {
            args: Prisma.QualificationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualificationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QualificationTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>[]
          }
          upsert: {
            args: Prisma.QualificationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationTypePayload>
          }
          aggregate: {
            args: Prisma.QualificationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualificationType>
          }
          groupBy: {
            args: Prisma.QualificationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualificationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualificationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<QualificationTypeCountAggregateOutputType> | number
          }
        }
      }
      MemberQualification: {
        payload: Prisma.$MemberQualificationPayload<ExtArgs>
        fields: Prisma.MemberQualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberQualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberQualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          findFirst: {
            args: Prisma.MemberQualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberQualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          findMany: {
            args: Prisma.MemberQualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>[]
          }
          create: {
            args: Prisma.MemberQualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          createMany: {
            args: Prisma.MemberQualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberQualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>[]
          }
          delete: {
            args: Prisma.MemberQualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          update: {
            args: Prisma.MemberQualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          deleteMany: {
            args: Prisma.MemberQualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberQualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberQualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>[]
          }
          upsert: {
            args: Prisma.MemberQualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberQualificationPayload>
          }
          aggregate: {
            args: Prisma.MemberQualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberQualification>
          }
          groupBy: {
            args: Prisma.MemberQualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberQualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberQualificationCountArgs<ExtArgs>
            result: $Utils.Optional<MemberQualificationCountAggregateOutputType> | number
          }
        }
      }
      DutyRole: {
        payload: Prisma.$DutyRolePayload<ExtArgs>
        fields: Prisma.DutyRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DutyRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DutyRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          findFirst: {
            args: Prisma.DutyRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DutyRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          findMany: {
            args: Prisma.DutyRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>[]
          }
          create: {
            args: Prisma.DutyRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          createMany: {
            args: Prisma.DutyRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DutyRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>[]
          }
          delete: {
            args: Prisma.DutyRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          update: {
            args: Prisma.DutyRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          deleteMany: {
            args: Prisma.DutyRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DutyRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DutyRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>[]
          }
          upsert: {
            args: Prisma.DutyRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRolePayload>
          }
          aggregate: {
            args: Prisma.DutyRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDutyRole>
          }
          groupBy: {
            args: Prisma.DutyRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DutyRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DutyRoleCountArgs<ExtArgs>
            result: $Utils.Optional<DutyRoleCountAggregateOutputType> | number
          }
        }
      }
      DutyPosition: {
        payload: Prisma.$DutyPositionPayload<ExtArgs>
        fields: Prisma.DutyPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DutyPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DutyPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          findFirst: {
            args: Prisma.DutyPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DutyPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          findMany: {
            args: Prisma.DutyPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>[]
          }
          create: {
            args: Prisma.DutyPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          createMany: {
            args: Prisma.DutyPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DutyPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>[]
          }
          delete: {
            args: Prisma.DutyPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          update: {
            args: Prisma.DutyPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          deleteMany: {
            args: Prisma.DutyPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DutyPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DutyPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>[]
          }
          upsert: {
            args: Prisma.DutyPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPositionPayload>
          }
          aggregate: {
            args: Prisma.DutyPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDutyPosition>
          }
          groupBy: {
            args: Prisma.DutyPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DutyPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DutyPositionCountArgs<ExtArgs>
            result: $Utils.Optional<DutyPositionCountAggregateOutputType> | number
          }
        }
      }
      WeeklySchedule: {
        payload: Prisma.$WeeklySchedulePayload<ExtArgs>
        fields: Prisma.WeeklyScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          findFirst: {
            args: Prisma.WeeklyScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          findMany: {
            args: Prisma.WeeklyScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>[]
          }
          create: {
            args: Prisma.WeeklyScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          createMany: {
            args: Prisma.WeeklyScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>[]
          }
          delete: {
            args: Prisma.WeeklyScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          update: {
            args: Prisma.WeeklyScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          deleteMany: {
            args: Prisma.WeeklyScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeeklyScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>[]
          }
          upsert: {
            args: Prisma.WeeklyScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklySchedulePayload>
          }
          aggregate: {
            args: Prisma.WeeklyScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklySchedule>
          }
          groupBy: {
            args: Prisma.WeeklyScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyScheduleCountAggregateOutputType> | number
          }
        }
      }
      ScheduleAssignment: {
        payload: Prisma.$ScheduleAssignmentPayload<ExtArgs>
        fields: Prisma.ScheduleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ScheduleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          findMany: {
            args: Prisma.ScheduleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>[]
          }
          create: {
            args: Prisma.ScheduleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          createMany: {
            args: Prisma.ScheduleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ScheduleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          update: {
            args: Prisma.ScheduleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ScheduleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleAssignment>
          }
          groupBy: {
            args: Prisma.ScheduleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      LockupStatus: {
        payload: Prisma.$LockupStatusPayload<ExtArgs>
        fields: Prisma.LockupStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LockupStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LockupStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          findFirst: {
            args: Prisma.LockupStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LockupStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          findMany: {
            args: Prisma.LockupStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>[]
          }
          create: {
            args: Prisma.LockupStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          createMany: {
            args: Prisma.LockupStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LockupStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>[]
          }
          delete: {
            args: Prisma.LockupStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          update: {
            args: Prisma.LockupStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          deleteMany: {
            args: Prisma.LockupStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LockupStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LockupStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>[]
          }
          upsert: {
            args: Prisma.LockupStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupStatusPayload>
          }
          aggregate: {
            args: Prisma.LockupStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLockupStatus>
          }
          groupBy: {
            args: Prisma.LockupStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<LockupStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.LockupStatusCountArgs<ExtArgs>
            result: $Utils.Optional<LockupStatusCountAggregateOutputType> | number
          }
        }
      }
      LockupTransfer: {
        payload: Prisma.$LockupTransferPayload<ExtArgs>
        fields: Prisma.LockupTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LockupTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LockupTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          findFirst: {
            args: Prisma.LockupTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LockupTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          findMany: {
            args: Prisma.LockupTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>[]
          }
          create: {
            args: Prisma.LockupTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          createMany: {
            args: Prisma.LockupTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LockupTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>[]
          }
          delete: {
            args: Prisma.LockupTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          update: {
            args: Prisma.LockupTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          deleteMany: {
            args: Prisma.LockupTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LockupTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LockupTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>[]
          }
          upsert: {
            args: Prisma.LockupTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupTransferPayload>
          }
          aggregate: {
            args: Prisma.LockupTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLockupTransfer>
          }
          groupBy: {
            args: Prisma.LockupTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<LockupTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.LockupTransferCountArgs<ExtArgs>
            result: $Utils.Optional<LockupTransferCountAggregateOutputType> | number
          }
        }
      }
      LockupExecution: {
        payload: Prisma.$LockupExecutionPayload<ExtArgs>
        fields: Prisma.LockupExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LockupExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LockupExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          findFirst: {
            args: Prisma.LockupExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LockupExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          findMany: {
            args: Prisma.LockupExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>[]
          }
          create: {
            args: Prisma.LockupExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          createMany: {
            args: Prisma.LockupExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LockupExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>[]
          }
          delete: {
            args: Prisma.LockupExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          update: {
            args: Prisma.LockupExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          deleteMany: {
            args: Prisma.LockupExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LockupExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LockupExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>[]
          }
          upsert: {
            args: Prisma.LockupExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockupExecutionPayload>
          }
          aggregate: {
            args: Prisma.LockupExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLockupExecution>
          }
          groupBy: {
            args: Prisma.LockupExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LockupExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LockupExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<LockupExecutionCountAggregateOutputType> | number
          }
        }
      }
      MissedCheckout: {
        payload: Prisma.$MissedCheckoutPayload<ExtArgs>
        fields: Prisma.MissedCheckoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissedCheckoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissedCheckoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          findFirst: {
            args: Prisma.MissedCheckoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissedCheckoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          findMany: {
            args: Prisma.MissedCheckoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>[]
          }
          create: {
            args: Prisma.MissedCheckoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          createMany: {
            args: Prisma.MissedCheckoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissedCheckoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>[]
          }
          delete: {
            args: Prisma.MissedCheckoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          update: {
            args: Prisma.MissedCheckoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          deleteMany: {
            args: Prisma.MissedCheckoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissedCheckoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MissedCheckoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>[]
          }
          upsert: {
            args: Prisma.MissedCheckoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissedCheckoutPayload>
          }
          aggregate: {
            args: Prisma.MissedCheckoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissedCheckout>
          }
          groupBy: {
            args: Prisma.MissedCheckoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissedCheckoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissedCheckoutCountArgs<ExtArgs>
            result: $Utils.Optional<MissedCheckoutCountAggregateOutputType> | number
          }
        }
      }
      UnitEventType: {
        payload: Prisma.$UnitEventTypePayload<ExtArgs>
        fields: Prisma.UnitEventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitEventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitEventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          findFirst: {
            args: Prisma.UnitEventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitEventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          findMany: {
            args: Prisma.UnitEventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>[]
          }
          create: {
            args: Prisma.UnitEventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          createMany: {
            args: Prisma.UnitEventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitEventTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>[]
          }
          delete: {
            args: Prisma.UnitEventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          update: {
            args: Prisma.UnitEventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          deleteMany: {
            args: Prisma.UnitEventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitEventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitEventTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>[]
          }
          upsert: {
            args: Prisma.UnitEventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventTypePayload>
          }
          aggregate: {
            args: Prisma.UnitEventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitEventType>
          }
          groupBy: {
            args: Prisma.UnitEventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitEventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitEventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<UnitEventTypeCountAggregateOutputType> | number
          }
        }
      }
      UnitEvent: {
        payload: Prisma.$UnitEventPayload<ExtArgs>
        fields: Prisma.UnitEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          findFirst: {
            args: Prisma.UnitEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          findMany: {
            args: Prisma.UnitEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>[]
          }
          create: {
            args: Prisma.UnitEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          createMany: {
            args: Prisma.UnitEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>[]
          }
          delete: {
            args: Prisma.UnitEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          update: {
            args: Prisma.UnitEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          deleteMany: {
            args: Prisma.UnitEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>[]
          }
          upsert: {
            args: Prisma.UnitEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventPayload>
          }
          aggregate: {
            args: Prisma.UnitEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitEvent>
          }
          groupBy: {
            args: Prisma.UnitEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitEventCountArgs<ExtArgs>
            result: $Utils.Optional<UnitEventCountAggregateOutputType> | number
          }
        }
      }
      UnitEventDutyPosition: {
        payload: Prisma.$UnitEventDutyPositionPayload<ExtArgs>
        fields: Prisma.UnitEventDutyPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitEventDutyPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitEventDutyPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          findFirst: {
            args: Prisma.UnitEventDutyPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitEventDutyPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          findMany: {
            args: Prisma.UnitEventDutyPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>[]
          }
          create: {
            args: Prisma.UnitEventDutyPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          createMany: {
            args: Prisma.UnitEventDutyPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitEventDutyPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>[]
          }
          delete: {
            args: Prisma.UnitEventDutyPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          update: {
            args: Prisma.UnitEventDutyPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          deleteMany: {
            args: Prisma.UnitEventDutyPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitEventDutyPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitEventDutyPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>[]
          }
          upsert: {
            args: Prisma.UnitEventDutyPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyPositionPayload>
          }
          aggregate: {
            args: Prisma.UnitEventDutyPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitEventDutyPosition>
          }
          groupBy: {
            args: Prisma.UnitEventDutyPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitEventDutyPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitEventDutyPositionCountArgs<ExtArgs>
            result: $Utils.Optional<UnitEventDutyPositionCountAggregateOutputType> | number
          }
        }
      }
      UnitEventDutyAssignment: {
        payload: Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>
        fields: Prisma.UnitEventDutyAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitEventDutyAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitEventDutyAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          findFirst: {
            args: Prisma.UnitEventDutyAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitEventDutyAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          findMany: {
            args: Prisma.UnitEventDutyAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>[]
          }
          create: {
            args: Prisma.UnitEventDutyAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          createMany: {
            args: Prisma.UnitEventDutyAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitEventDutyAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>[]
          }
          delete: {
            args: Prisma.UnitEventDutyAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          update: {
            args: Prisma.UnitEventDutyAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.UnitEventDutyAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitEventDutyAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitEventDutyAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.UnitEventDutyAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitEventDutyAssignmentPayload>
          }
          aggregate: {
            args: Prisma.UnitEventDutyAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitEventDutyAssignment>
          }
          groupBy: {
            args: Prisma.UnitEventDutyAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitEventDutyAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitEventDutyAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<UnitEventDutyAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    adminUser?: AdminUserOmit
    auditLog?: AuditLogOmit
    badge?: BadgeOmit
    checkin?: CheckinOmit
    division?: DivisionOmit
    eventAttendee?: EventAttendeeOmit
    eventCheckin?: EventCheckinOmit
    event?: EventOmit
    member?: MemberOmit
    tag?: TagOmit
    memberTag?: MemberTagOmit
    securityAlert?: SecurityAlertOmit
    visitor?: VisitorOmit
    bmqCourse?: BmqCourseOmit
    bmqEnrollment?: BmqEnrollmentOmit
    migrations?: migrationsOmit
    report_audit_log?: report_audit_logOmit
    reportSetting?: ReportSettingOmit
    trainingYear?: TrainingYearOmit
    ddsAssignment?: DdsAssignmentOmit
    responsibilityAuditLog?: ResponsibilityAuditLogOmit
    memberStatus?: MemberStatusOmit
    memberType?: MemberTypeOmit
    visitType?: VisitTypeOmit
    badgeStatus?: BadgeStatusOmit
    listItem?: ListItemOmit
    rank?: RankOmit
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    setting?: SettingOmit
    alertConfig?: AlertConfigOmit
    statHoliday?: StatHolidayOmit
    qualificationType?: QualificationTypeOmit
    memberQualification?: MemberQualificationOmit
    dutyRole?: DutyRoleOmit
    dutyPosition?: DutyPositionOmit
    weeklySchedule?: WeeklyScheduleOmit
    scheduleAssignment?: ScheduleAssignmentOmit
    lockupStatus?: LockupStatusOmit
    lockupTransfer?: LockupTransferOmit
    lockupExecution?: LockupExecutionOmit
    missedCheckout?: MissedCheckoutOmit
    unitEventType?: UnitEventTypeOmit
    unitEvent?: UnitEventOmit
    unitEventDutyPosition?: UnitEventDutyPositionOmit
    unitEventDutyAssignment?: UnitEventDutyAssignmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    auditLogs: number
    checkins: number
    report_audit_log: number
    securityAlerts: number
    visitors: number
    ddsAssignments: number
    disabledUsers: number
    updatedUsers: number
    qualificationsGranted: number
    qualificationsRevoked: number
    schedulesCreated: number
    schedulesPublished: number
    missedCheckoutsResolved: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUserCountOutputTypeCountAuditLogsArgs
    checkins?: boolean | AdminUserCountOutputTypeCountCheckinsArgs
    report_audit_log?: boolean | AdminUserCountOutputTypeCountReport_audit_logArgs
    securityAlerts?: boolean | AdminUserCountOutputTypeCountSecurityAlertsArgs
    visitors?: boolean | AdminUserCountOutputTypeCountVisitorsArgs
    ddsAssignments?: boolean | AdminUserCountOutputTypeCountDdsAssignmentsArgs
    disabledUsers?: boolean | AdminUserCountOutputTypeCountDisabledUsersArgs
    updatedUsers?: boolean | AdminUserCountOutputTypeCountUpdatedUsersArgs
    qualificationsGranted?: boolean | AdminUserCountOutputTypeCountQualificationsGrantedArgs
    qualificationsRevoked?: boolean | AdminUserCountOutputTypeCountQualificationsRevokedArgs
    schedulesCreated?: boolean | AdminUserCountOutputTypeCountSchedulesCreatedArgs
    schedulesPublished?: boolean | AdminUserCountOutputTypeCountSchedulesPublishedArgs
    missedCheckoutsResolved?: boolean | AdminUserCountOutputTypeCountMissedCheckoutsResolvedArgs
  }

  // Custom InputTypes
  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountReport_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_audit_logWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountSecurityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountDdsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountDisabledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountUpdatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountQualificationsGrantedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberQualificationWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountQualificationsRevokedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberQualificationWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountSchedulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyScheduleWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountSchedulesPublishedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyScheduleWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountMissedCheckoutsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissedCheckoutWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    checkins: number
    eventAttendees: number
    eventCheckins: number
    members: number
    visitors: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | BadgeCountOutputTypeCountCheckinsArgs
    eventAttendees?: boolean | BadgeCountOutputTypeCountEventAttendeesArgs
    eventCheckins?: boolean | BadgeCountOutputTypeCountEventCheckinsArgs
    members?: boolean | BadgeCountOutputTypeCountMembersArgs
    visitors?: boolean | BadgeCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountEventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountEventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type DivisionCountOutputType
   */

  export type DivisionCountOutputType = {
    members: number
  }

  export type DivisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DivisionCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DivisionCountOutputType
     */
    select?: DivisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type EventAttendeeCountOutputType
   */

  export type EventAttendeeCountOutputType = {
    eventCheckins: number
  }

  export type EventAttendeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventCheckins?: boolean | EventAttendeeCountOutputTypeCountEventCheckinsArgs
  }

  // Custom InputTypes
  /**
   * EventAttendeeCountOutputType without action
   */
  export type EventAttendeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendeeCountOutputType
     */
    select?: EventAttendeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventAttendeeCountOutputType without action
   */
  export type EventAttendeeCountOutputTypeCountEventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    eventAttendees: number
    visitors: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventAttendees?: boolean | EventCountOutputTypeCountEventAttendeesArgs
    visitors?: boolean | EventCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    bmqEnrollments: number
    checkins: number
    visitors: number
    memberTags: number
    ddsAssignments: number
    ddsTransfers: number
    qualifications: number
    scheduleAssignments: number
    lockupHolding: number
    lockupSecured: number
    lockupTransfersFrom: number
    lockupTransfersTo: number
    lockupExecutions: number
    missedCheckouts: number
    unitEventDutyAssignments: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | MemberCountOutputTypeCountBmqEnrollmentsArgs
    checkins?: boolean | MemberCountOutputTypeCountCheckinsArgs
    visitors?: boolean | MemberCountOutputTypeCountVisitorsArgs
    memberTags?: boolean | MemberCountOutputTypeCountMemberTagsArgs
    ddsAssignments?: boolean | MemberCountOutputTypeCountDdsAssignmentsArgs
    ddsTransfers?: boolean | MemberCountOutputTypeCountDdsTransfersArgs
    qualifications?: boolean | MemberCountOutputTypeCountQualificationsArgs
    scheduleAssignments?: boolean | MemberCountOutputTypeCountScheduleAssignmentsArgs
    lockupHolding?: boolean | MemberCountOutputTypeCountLockupHoldingArgs
    lockupSecured?: boolean | MemberCountOutputTypeCountLockupSecuredArgs
    lockupTransfersFrom?: boolean | MemberCountOutputTypeCountLockupTransfersFromArgs
    lockupTransfersTo?: boolean | MemberCountOutputTypeCountLockupTransfersToArgs
    lockupExecutions?: boolean | MemberCountOutputTypeCountLockupExecutionsArgs
    missedCheckouts?: boolean | MemberCountOutputTypeCountMissedCheckoutsArgs
    unitEventDutyAssignments?: boolean | MemberCountOutputTypeCountUnitEventDutyAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountBmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountDdsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountDdsTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberQualificationWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountScheduleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAssignmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountLockupHoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupStatusWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountLockupSecuredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupStatusWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountLockupTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupTransferWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountLockupTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupTransferWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountLockupExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupExecutionWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMissedCheckoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissedCheckoutWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountUnitEventDutyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyAssignmentWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    memberTags: number
    qualificationTypes: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberTags?: boolean | TagCountOutputTypeCountMemberTagsArgs
    qualificationTypes?: boolean | TagCountOutputTypeCountQualificationTypesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMemberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountQualificationTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualificationTypeWhereInput
  }


  /**
   * Count Type BmqCourseCountOutputType
   */

  export type BmqCourseCountOutputType = {
    bmqEnrollments: number
  }

  export type BmqCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | BmqCourseCountOutputTypeCountBmqEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * BmqCourseCountOutputType without action
   */
  export type BmqCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourseCountOutputType
     */
    select?: BmqCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmqCourseCountOutputType without action
   */
  export type BmqCourseCountOutputTypeCountBmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
  }


  /**
   * Count Type MemberStatusCountOutputType
   */

  export type MemberStatusCountOutputType = {
    members: number
  }

  export type MemberStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberStatusCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MemberStatusCountOutputType without action
   */
  export type MemberStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatusCountOutputType
     */
    select?: MemberStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberStatusCountOutputType without action
   */
  export type MemberStatusCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type MemberTypeCountOutputType
   */

  export type MemberTypeCountOutputType = {
    members: number
  }

  export type MemberTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberTypeCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MemberTypeCountOutputType without action
   */
  export type MemberTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTypeCountOutputType
     */
    select?: MemberTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberTypeCountOutputType without action
   */
  export type MemberTypeCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type VisitTypeCountOutputType
   */

  export type VisitTypeCountOutputType = {
    visitors: number
  }

  export type VisitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | VisitTypeCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTypeCountOutputType
     */
    select?: VisitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type BadgeStatusCountOutputType
   */

  export type BadgeStatusCountOutputType = {
    badges: number
  }

  export type BadgeStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeStatusCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeStatusCountOutputType without action
   */
  export type BadgeStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatusCountOutputType
     */
    select?: BadgeStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeStatusCountOutputType without action
   */
  export type BadgeStatusCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }


  /**
   * Count Type RankCountOutputType
   */

  export type RankCountOutputType = {
    members: number
    replacesRanks: number
  }

  export type RankCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | RankCountOutputTypeCountMembersArgs
    replacesRanks?: boolean | RankCountOutputTypeCountReplacesRanksArgs
  }

  // Custom InputTypes
  /**
   * RankCountOutputType without action
   */
  export type RankCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankCountOutputType
     */
    select?: RankCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RankCountOutputType without action
   */
  export type RankCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * RankCountOutputType without action
   */
  export type RankCountOutputTypeCountReplacesRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type QualificationTypeCountOutputType
   */

  export type QualificationTypeCountOutputType = {
    memberQualifications: number
  }

  export type QualificationTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberQualifications?: boolean | QualificationTypeCountOutputTypeCountMemberQualificationsArgs
  }

  // Custom InputTypes
  /**
   * QualificationTypeCountOutputType without action
   */
  export type QualificationTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationTypeCountOutputType
     */
    select?: QualificationTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QualificationTypeCountOutputType without action
   */
  export type QualificationTypeCountOutputTypeCountMemberQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberQualificationWhereInput
  }


  /**
   * Count Type DutyRoleCountOutputType
   */

  export type DutyRoleCountOutputType = {
    positions: number
    schedules: number
  }

  export type DutyRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | DutyRoleCountOutputTypeCountPositionsArgs
    schedules?: boolean | DutyRoleCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * DutyRoleCountOutputType without action
   */
  export type DutyRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoleCountOutputType
     */
    select?: DutyRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DutyRoleCountOutputType without action
   */
  export type DutyRoleCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyPositionWhereInput
  }

  /**
   * DutyRoleCountOutputType without action
   */
  export type DutyRoleCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyScheduleWhereInput
  }


  /**
   * Count Type DutyPositionCountOutputType
   */

  export type DutyPositionCountOutputType = {
    assignments: number
  }

  export type DutyPositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | DutyPositionCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * DutyPositionCountOutputType without action
   */
  export type DutyPositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPositionCountOutputType
     */
    select?: DutyPositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DutyPositionCountOutputType without action
   */
  export type DutyPositionCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAssignmentWhereInput
  }


  /**
   * Count Type WeeklyScheduleCountOutputType
   */

  export type WeeklyScheduleCountOutputType = {
    assignments: number
  }

  export type WeeklyScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | WeeklyScheduleCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WeeklyScheduleCountOutputType without action
   */
  export type WeeklyScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyScheduleCountOutputType
     */
    select?: WeeklyScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeeklyScheduleCountOutputType without action
   */
  export type WeeklyScheduleCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAssignmentWhereInput
  }


  /**
   * Count Type LockupStatusCountOutputType
   */

  export type LockupStatusCountOutputType = {
    transfers: number
  }

  export type LockupStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfers?: boolean | LockupStatusCountOutputTypeCountTransfersArgs
  }

  // Custom InputTypes
  /**
   * LockupStatusCountOutputType without action
   */
  export type LockupStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatusCountOutputType
     */
    select?: LockupStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LockupStatusCountOutputType without action
   */
  export type LockupStatusCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupTransferWhereInput
  }


  /**
   * Count Type UnitEventTypeCountOutputType
   */

  export type UnitEventTypeCountOutputType = {
    unitEvents: number
  }

  export type UnitEventTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitEvents?: boolean | UnitEventTypeCountOutputTypeCountUnitEventsArgs
  }

  // Custom InputTypes
  /**
   * UnitEventTypeCountOutputType without action
   */
  export type UnitEventTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventTypeCountOutputType
     */
    select?: UnitEventTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitEventTypeCountOutputType without action
   */
  export type UnitEventTypeCountOutputTypeCountUnitEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventWhereInput
  }


  /**
   * Count Type UnitEventCountOutputType
   */

  export type UnitEventCountOutputType = {
    dutyPositions: number
    dutyAssignments: number
  }

  export type UnitEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyPositions?: boolean | UnitEventCountOutputTypeCountDutyPositionsArgs
    dutyAssignments?: boolean | UnitEventCountOutputTypeCountDutyAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UnitEventCountOutputType without action
   */
  export type UnitEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventCountOutputType
     */
    select?: UnitEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitEventCountOutputType without action
   */
  export type UnitEventCountOutputTypeCountDutyPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyPositionWhereInput
  }

  /**
   * UnitEventCountOutputType without action
   */
  export type UnitEventCountOutputTypeCountDutyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyAssignmentWhereInput
  }


  /**
   * Count Type UnitEventDutyPositionCountOutputType
   */

  export type UnitEventDutyPositionCountOutputType = {
    assignments: number
  }

  export type UnitEventDutyPositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | UnitEventDutyPositionCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UnitEventDutyPositionCountOutputType without action
   */
  export type UnitEventDutyPositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPositionCountOutputType
     */
    select?: UnitEventDutyPositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitEventDutyPositionCountOutputType without action
   */
  export type UnitEventDutyPositionCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    fullName: string | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean | null
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    fullName: string | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean | null
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    displayName: number
    fullName: number
    role: number
    lastLogin: number
    createdAt: number
    first_name: number
    last_name: number
    updated_at: number
    disabled: number
    disabledAt: number
    disabledBy: number
    updatedBy: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    username: string
    email: string | null
    passwordHash: string
    displayName: string
    fullName: string | null
    role: string
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    checkins?: boolean | AdminUser$checkinsArgs<ExtArgs>
    report_audit_log?: boolean | AdminUser$report_audit_logArgs<ExtArgs>
    securityAlerts?: boolean | AdminUser$securityAlertsArgs<ExtArgs>
    visitors?: boolean | AdminUser$visitorsArgs<ExtArgs>
    ddsAssignments?: boolean | AdminUser$ddsAssignmentsArgs<ExtArgs>
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
    disabledUsers?: boolean | AdminUser$disabledUsersArgs<ExtArgs>
    updatedUsers?: boolean | AdminUser$updatedUsersArgs<ExtArgs>
    qualificationsGranted?: boolean | AdminUser$qualificationsGrantedArgs<ExtArgs>
    qualificationsRevoked?: boolean | AdminUser$qualificationsRevokedArgs<ExtArgs>
    schedulesCreated?: boolean | AdminUser$schedulesCreatedArgs<ExtArgs>
    schedulesPublished?: boolean | AdminUser$schedulesPublishedArgs<ExtArgs>
    missedCheckoutsResolved?: boolean | AdminUser$missedCheckoutsResolvedArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
  }

  export type AdminUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "displayName" | "fullName" | "role" | "lastLogin" | "createdAt" | "first_name" | "last_name" | "updated_at" | "disabled" | "disabledAt" | "disabledBy" | "updatedBy", ExtArgs["result"]["adminUser"]>
  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    checkins?: boolean | AdminUser$checkinsArgs<ExtArgs>
    report_audit_log?: boolean | AdminUser$report_audit_logArgs<ExtArgs>
    securityAlerts?: boolean | AdminUser$securityAlertsArgs<ExtArgs>
    visitors?: boolean | AdminUser$visitorsArgs<ExtArgs>
    ddsAssignments?: boolean | AdminUser$ddsAssignmentsArgs<ExtArgs>
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
    disabledUsers?: boolean | AdminUser$disabledUsersArgs<ExtArgs>
    updatedUsers?: boolean | AdminUser$updatedUsersArgs<ExtArgs>
    qualificationsGranted?: boolean | AdminUser$qualificationsGrantedArgs<ExtArgs>
    qualificationsRevoked?: boolean | AdminUser$qualificationsRevokedArgs<ExtArgs>
    schedulesCreated?: boolean | AdminUser$schedulesCreatedArgs<ExtArgs>
    schedulesPublished?: boolean | AdminUser$schedulesPublishedArgs<ExtArgs>
    missedCheckoutsResolved?: boolean | AdminUser$missedCheckoutsResolvedArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }
  export type AdminUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      report_audit_log: Prisma.$report_audit_logPayload<ExtArgs>[]
      securityAlerts: Prisma.$SecurityAlertPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      ddsAssignments: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      disabledByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      updatedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      disabledUsers: Prisma.$AdminUserPayload<ExtArgs>[]
      updatedUsers: Prisma.$AdminUserPayload<ExtArgs>[]
      qualificationsGranted: Prisma.$MemberQualificationPayload<ExtArgs>[]
      qualificationsRevoked: Prisma.$MemberQualificationPayload<ExtArgs>[]
      schedulesCreated: Prisma.$WeeklySchedulePayload<ExtArgs>[]
      schedulesPublished: Prisma.$WeeklySchedulePayload<ExtArgs>[]
      missedCheckoutsResolved: Prisma.$MissedCheckoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string | null
      passwordHash: string
      displayName: string
      fullName: string | null
      role: string
      lastLogin: Date | null
      createdAt: Date | null
      first_name: string | null
      last_name: string | null
      updated_at: Date | null
      disabled: boolean
      disabledAt: Date | null
      disabledBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers and returns the data updated in the database.
     * @param {AdminUserUpdateManyAndReturnArgs} args - Arguments to update many AdminUsers.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends AdminUser$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkins<T extends AdminUser$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    report_audit_log<T extends AdminUser$report_audit_logArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$report_audit_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityAlerts<T extends AdminUser$securityAlertsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$securityAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends AdminUser$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsAssignments<T extends AdminUser$ddsAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$ddsAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disabledByAdmin<T extends AdminUser$disabledByAdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$disabledByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedByAdmin<T extends AdminUser$updatedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$updatedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    disabledUsers<T extends AdminUser$disabledUsersArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$disabledUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedUsers<T extends AdminUser$updatedUsersArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$updatedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualificationsGranted<T extends AdminUser$qualificationsGrantedArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$qualificationsGrantedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualificationsRevoked<T extends AdminUser$qualificationsRevokedArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$qualificationsRevokedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedulesCreated<T extends AdminUser$schedulesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$schedulesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedulesPublished<T extends AdminUser$schedulesPublishedArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$schedulesPublishedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    missedCheckoutsResolved<T extends AdminUser$missedCheckoutsResolvedArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$missedCheckoutsResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly username: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly passwordHash: FieldRef<"AdminUser", 'String'>
    readonly displayName: FieldRef<"AdminUser", 'String'>
    readonly fullName: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'String'>
    readonly lastLogin: FieldRef<"AdminUser", 'DateTime'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly first_name: FieldRef<"AdminUser", 'String'>
    readonly last_name: FieldRef<"AdminUser", 'String'>
    readonly updated_at: FieldRef<"AdminUser", 'DateTime'>
    readonly disabled: FieldRef<"AdminUser", 'Boolean'>
    readonly disabledAt: FieldRef<"AdminUser", 'DateTime'>
    readonly disabledBy: FieldRef<"AdminUser", 'String'>
    readonly updatedBy: FieldRef<"AdminUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
  }

  /**
   * AdminUser updateManyAndReturn
   */
  export type AdminUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to delete.
     */
    limit?: number
  }

  /**
   * AdminUser.auditLogs
   */
  export type AdminUser$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AdminUser.checkins
   */
  export type AdminUser$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * AdminUser.report_audit_log
   */
  export type AdminUser$report_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    where?: report_audit_logWhereInput
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    cursor?: report_audit_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
  }

  /**
   * AdminUser.securityAlerts
   */
  export type AdminUser$securityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    cursor?: SecurityAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * AdminUser.visitors
   */
  export type AdminUser$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * AdminUser.ddsAssignments
   */
  export type AdminUser$ddsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * AdminUser.disabledByAdmin
   */
  export type AdminUser$disabledByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.updatedByAdmin
   */
  export type AdminUser$updatedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.disabledUsers
   */
  export type AdminUser$disabledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    cursor?: AdminUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser.updatedUsers
   */
  export type AdminUser$updatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    cursor?: AdminUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser.qualificationsGranted
   */
  export type AdminUser$qualificationsGrantedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    where?: MemberQualificationWhereInput
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    cursor?: MemberQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
  }

  /**
   * AdminUser.qualificationsRevoked
   */
  export type AdminUser$qualificationsRevokedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    where?: MemberQualificationWhereInput
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    cursor?: MemberQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
  }

  /**
   * AdminUser.schedulesCreated
   */
  export type AdminUser$schedulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    where?: WeeklyScheduleWhereInput
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    cursor?: WeeklyScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
  }

  /**
   * AdminUser.schedulesPublished
   */
  export type AdminUser$schedulesPublishedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    where?: WeeklyScheduleWhereInput
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    cursor?: WeeklyScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
  }

  /**
   * AdminUser.missedCheckoutsResolved
   */
  export type AdminUser$missedCheckoutsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    where?: MissedCheckoutWhereInput
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    cursor?: MissedCheckoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissedCheckoutScalarFieldEnum | MissedCheckoutScalarFieldEnum[]
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    adminUserId: number
    action: number
    entityType: number
    entityId: number
    details: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    adminUserId: string | null
    action: string
    entityType: string
    entityId: string | null
    details: JsonValue | null
    ipAddress: string | null
    createdAt: Date | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminUserId" | "action" | "entityType" | "entityId" | "details" | "ipAddress" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      adminUser: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUserId: string | null
      action: string
      entityType: string
      entityId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUser<T extends AuditLog$adminUserArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$adminUserArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly adminUserId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.adminUser
   */
  export type AuditLog$adminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    assignmentType: string | null
    assignedToId: string | null
    status: string | null
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    assignmentType: string | null
    assignedToId: string | null
    status: string | null
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    serialNumber: number
    assignmentType: number
    assignedToId: number
    status: number
    badgeStatusId: number
    lastUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    serialNumber: string
    assignmentType: string
    assignedToId: string | null
    status: string
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkins?: boolean | Badge$checkinsArgs<ExtArgs>
    eventAttendees?: boolean | Badge$eventAttendeesArgs<ExtArgs>
    eventCheckins?: boolean | Badge$eventCheckinsArgs<ExtArgs>
    members?: boolean | Badge$membersArgs<ExtArgs>
    visitors?: boolean | Badge$visitorsArgs<ExtArgs>
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serialNumber" | "assignmentType" | "assignedToId" | "status" | "badgeStatusId" | "lastUsed" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | Badge$checkinsArgs<ExtArgs>
    eventAttendees?: boolean | Badge$eventAttendeesArgs<ExtArgs>
    eventCheckins?: boolean | Badge$eventCheckinsArgs<ExtArgs>
    members?: boolean | Badge$membersArgs<ExtArgs>
    visitors?: boolean | Badge$visitorsArgs<ExtArgs>
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      eventAttendees: Prisma.$EventAttendeePayload<ExtArgs>[]
      eventCheckins: Prisma.$EventCheckinPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      badgeStatusRef: Prisma.$BadgeStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      assignmentType: string
      assignedToId: string | null
      status: string
      badgeStatusId: string | null
      lastUsed: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkins<T extends Badge$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventAttendees<T extends Badge$eventAttendeesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$eventAttendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventCheckins<T extends Badge$eventCheckinsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$eventCheckinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Badge$membersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Badge$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badgeStatusRef<T extends Badge$badgeStatusRefArgs<ExtArgs> = {}>(args?: Subset<T, Badge$badgeStatusRefArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly serialNumber: FieldRef<"Badge", 'String'>
    readonly assignmentType: FieldRef<"Badge", 'String'>
    readonly assignedToId: FieldRef<"Badge", 'String'>
    readonly status: FieldRef<"Badge", 'String'>
    readonly badgeStatusId: FieldRef<"Badge", 'String'>
    readonly lastUsed: FieldRef<"Badge", 'DateTime'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.checkins
   */
  export type Badge$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Badge.eventAttendees
   */
  export type Badge$eventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * Badge.eventCheckins
   */
  export type Badge$eventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    cursor?: EventCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * Badge.members
   */
  export type Badge$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Badge.visitors
   */
  export type Badge$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Badge.badgeStatusRef
   */
  export type Badge$badgeStatusRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    where?: BadgeStatusWhereInput
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model Checkin
   */

  export type AggregateCheckin = {
    _count: CheckinCountAggregateOutputType | null
    _min: CheckinMinAggregateOutputType | null
    _max: CheckinMaxAggregateOutputType | null
  }

  export type CheckinMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
  }

  export type CheckinMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
  }

  export type CheckinCountAggregateOutputType = {
    id: number
    memberId: number
    badgeId: number
    direction: number
    timestamp: number
    kioskId: number
    synced: number
    createdAt: number
    flagged_for_review: number
    flag_reason: number
    method: number
    created_by_admin: number
    _all: number
  }


  export type CheckinMinAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
  }

  export type CheckinMaxAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
  }

  export type CheckinCountAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
    _all?: true
  }

  export type CheckinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkin to aggregate.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Checkins
    **/
    _count?: true | CheckinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckinMaxAggregateInputType
  }

  export type GetCheckinAggregateType<T extends CheckinAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckin[P]>
      : GetScalarType<T[P], AggregateCheckin[P]>
  }




  export type CheckinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithAggregationInput | CheckinOrderByWithAggregationInput[]
    by: CheckinScalarFieldEnum[] | CheckinScalarFieldEnum
    having?: CheckinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckinCountAggregateInputType | true
    _min?: CheckinMinAggregateInputType
    _max?: CheckinMaxAggregateInputType
  }

  export type CheckinGroupByOutputType = {
    id: string
    memberId: string | null
    badgeId: string | null
    direction: string
    timestamp: Date
    kioskId: string
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
    _count: CheckinCountAggregateOutputType | null
    _min: CheckinMinAggregateOutputType | null
    _max: CheckinMaxAggregateOutputType | null
  }

  type GetCheckinGroupByPayload<T extends CheckinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckinGroupByOutputType[P]>
            : GetScalarType<T[P], CheckinGroupByOutputType[P]>
        }
      >
    >


  export type CheckinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectScalar = {
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
  }

  export type CheckinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "badgeId" | "direction" | "timestamp" | "kioskId" | "synced" | "createdAt" | "flagged_for_review" | "flag_reason" | "method" | "created_by_admin", ExtArgs["result"]["checkin"]>
  export type CheckinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }
  export type CheckinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }
  export type CheckinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }

  export type $CheckinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Checkin"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs> | null
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
      member: Prisma.$MemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string | null
      badgeId: string | null
      direction: string
      timestamp: Date
      kioskId: string
      synced: boolean | null
      createdAt: Date | null
      flagged_for_review: boolean | null
      flag_reason: string | null
      method: string | null
      created_by_admin: string | null
    }, ExtArgs["result"]["checkin"]>
    composites: {}
  }

  type CheckinGetPayload<S extends boolean | null | undefined | CheckinDefaultArgs> = $Result.GetResult<Prisma.$CheckinPayload, S>

  type CheckinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CheckinCountAggregateInputType | true
    }

  export interface CheckinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Checkin'], meta: { name: 'Checkin' } }
    /**
     * Find zero or one Checkin that matches the filter.
     * @param {CheckinFindUniqueArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckinFindUniqueArgs>(args: SelectSubset<T, CheckinFindUniqueArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Checkin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckinFindUniqueOrThrowArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckinFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindFirstArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckinFindFirstArgs>(args?: SelectSubset<T, CheckinFindFirstArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindFirstOrThrowArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckinFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckinFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkins
     * const checkins = await prisma.checkin.findMany()
     * 
     * // Get first 10 Checkins
     * const checkins = await prisma.checkin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkinWithIdOnly = await prisma.checkin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckinFindManyArgs>(args?: SelectSubset<T, CheckinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Checkin.
     * @param {CheckinCreateArgs} args - Arguments to create a Checkin.
     * @example
     * // Create one Checkin
     * const Checkin = await prisma.checkin.create({
     *   data: {
     *     // ... data to create a Checkin
     *   }
     * })
     * 
     */
    create<T extends CheckinCreateArgs>(args: SelectSubset<T, CheckinCreateArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Checkins.
     * @param {CheckinCreateManyArgs} args - Arguments to create many Checkins.
     * @example
     * // Create many Checkins
     * const checkin = await prisma.checkin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckinCreateManyArgs>(args?: SelectSubset<T, CheckinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkins and returns the data saved in the database.
     * @param {CheckinCreateManyAndReturnArgs} args - Arguments to create many Checkins.
     * @example
     * // Create many Checkins
     * const checkin = await prisma.checkin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkins and only return the `id`
     * const checkinWithIdOnly = await prisma.checkin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckinCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Checkin.
     * @param {CheckinDeleteArgs} args - Arguments to delete one Checkin.
     * @example
     * // Delete one Checkin
     * const Checkin = await prisma.checkin.delete({
     *   where: {
     *     // ... filter to delete one Checkin
     *   }
     * })
     * 
     */
    delete<T extends CheckinDeleteArgs>(args: SelectSubset<T, CheckinDeleteArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Checkin.
     * @param {CheckinUpdateArgs} args - Arguments to update one Checkin.
     * @example
     * // Update one Checkin
     * const checkin = await prisma.checkin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckinUpdateArgs>(args: SelectSubset<T, CheckinUpdateArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Checkins.
     * @param {CheckinDeleteManyArgs} args - Arguments to filter Checkins to delete.
     * @example
     * // Delete a few Checkins
     * const { count } = await prisma.checkin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckinDeleteManyArgs>(args?: SelectSubset<T, CheckinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkins
     * const checkin = await prisma.checkin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckinUpdateManyArgs>(args: SelectSubset<T, CheckinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkins and returns the data updated in the database.
     * @param {CheckinUpdateManyAndReturnArgs} args - Arguments to update many Checkins.
     * @example
     * // Update many Checkins
     * const checkin = await prisma.checkin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Checkins and only return the `id`
     * const checkinWithIdOnly = await prisma.checkin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckinUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Checkin.
     * @param {CheckinUpsertArgs} args - Arguments to update or create a Checkin.
     * @example
     * // Update or create a Checkin
     * const checkin = await prisma.checkin.upsert({
     *   create: {
     *     // ... data to create a Checkin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkin we want to update
     *   }
     * })
     */
    upsert<T extends CheckinUpsertArgs>(args: SelectSubset<T, CheckinUpsertArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinCountArgs} args - Arguments to filter Checkins to count.
     * @example
     * // Count the number of Checkins
     * const count = await prisma.checkin.count({
     *   where: {
     *     // ... the filter for the Checkins we want to count
     *   }
     * })
    **/
    count<T extends CheckinCountArgs>(
      args?: Subset<T, CheckinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckinAggregateArgs>(args: Subset<T, CheckinAggregateArgs>): Prisma.PrismaPromise<GetCheckinAggregateType<T>>

    /**
     * Group by Checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckinGroupByArgs['orderBy'] }
        : { orderBy?: CheckinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Checkin model
   */
  readonly fields: CheckinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Checkin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends Checkin$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin_users<T extends Checkin$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends Checkin$memberArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$memberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Checkin model
   */
  interface CheckinFieldRefs {
    readonly id: FieldRef<"Checkin", 'String'>
    readonly memberId: FieldRef<"Checkin", 'String'>
    readonly badgeId: FieldRef<"Checkin", 'String'>
    readonly direction: FieldRef<"Checkin", 'String'>
    readonly timestamp: FieldRef<"Checkin", 'DateTime'>
    readonly kioskId: FieldRef<"Checkin", 'String'>
    readonly synced: FieldRef<"Checkin", 'Boolean'>
    readonly createdAt: FieldRef<"Checkin", 'DateTime'>
    readonly flagged_for_review: FieldRef<"Checkin", 'Boolean'>
    readonly flag_reason: FieldRef<"Checkin", 'String'>
    readonly method: FieldRef<"Checkin", 'String'>
    readonly created_by_admin: FieldRef<"Checkin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Checkin findUnique
   */
  export type CheckinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where: CheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin findUniqueOrThrow
   */
  export type CheckinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where: CheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin findFirst
   */
  export type CheckinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkins.
     */
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin findFirstOrThrow
   */
  export type CheckinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkins.
     */
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin findMany
   */
  export type CheckinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkins to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin create
   */
  export type CheckinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The data needed to create a Checkin.
     */
    data: XOR<CheckinCreateInput, CheckinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin createMany
   */
  export type CheckinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Checkins.
     */
    data: CheckinCreateManyInput | CheckinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Checkin createManyAndReturn
   */
  export type CheckinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * The data used to create many Checkins.
     */
    data: CheckinCreateManyInput | CheckinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checkin update
   */
  export type CheckinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The data needed to update a Checkin.
     */
    data: XOR<CheckinUpdateInput, CheckinUncheckedUpdateInput>
    /**
     * Choose, which Checkin to update.
     */
    where: CheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin updateMany
   */
  export type CheckinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Checkins.
     */
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyInput>
    /**
     * Filter which Checkins to update
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to update.
     */
    limit?: number
  }

  /**
   * Checkin updateManyAndReturn
   */
  export type CheckinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * The data used to update Checkins.
     */
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyInput>
    /**
     * Filter which Checkins to update
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checkin upsert
   */
  export type CheckinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The filter to search for the Checkin to update in case it exists.
     */
    where: CheckinWhereUniqueInput
    /**
     * In case the Checkin found by the `where` argument doesn't exist, create a new Checkin with this data.
     */
    create: XOR<CheckinCreateInput, CheckinUncheckedCreateInput>
    /**
     * In case the Checkin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckinUpdateInput, CheckinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin delete
   */
  export type CheckinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter which Checkin to delete.
     */
    where: CheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Checkin deleteMany
   */
  export type CheckinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkins to delete
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to delete.
     */
    limit?: number
  }

  /**
   * Checkin.badge
   */
  export type Checkin$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Checkin.admin_users
   */
  export type Checkin$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * Checkin.member
   */
  export type Checkin$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Checkin without action
   */
  export type CheckinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
  }


  /**
   * Model Division
   */

  export type AggregateDivision = {
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  export type DivisionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DivisionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DivisionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DivisionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DivisionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DivisionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DivisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Division to aggregate.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Divisions
    **/
    _count?: true | DivisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionMaxAggregateInputType
  }

  export type GetDivisionAggregateType<T extends DivisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDivision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivision[P]>
      : GetScalarType<T[P], AggregateDivision[P]>
  }




  export type DivisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionWhereInput
    orderBy?: DivisionOrderByWithAggregationInput | DivisionOrderByWithAggregationInput[]
    by: DivisionScalarFieldEnum[] | DivisionScalarFieldEnum
    having?: DivisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionCountAggregateInputType | true
    _min?: DivisionMinAggregateInputType
    _max?: DivisionMaxAggregateInputType
  }

  export type DivisionGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  type GetDivisionGroupByPayload<T extends DivisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionGroupByOutputType[P]>
        }
      >
    >


  export type DivisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Division$membersArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DivisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["division"]>
  export type DivisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Division$membersArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DivisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DivisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DivisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Division"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["division"]>
    composites: {}
  }

  type DivisionGetPayload<S extends boolean | null | undefined | DivisionDefaultArgs> = $Result.GetResult<Prisma.$DivisionPayload, S>

  type DivisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DivisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DivisionCountAggregateInputType | true
    }

  export interface DivisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Division'], meta: { name: 'Division' } }
    /**
     * Find zero or one Division that matches the filter.
     * @param {DivisionFindUniqueArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DivisionFindUniqueArgs>(args: SelectSubset<T, DivisionFindUniqueArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Division that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DivisionFindUniqueOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DivisionFindUniqueOrThrowArgs>(args: SelectSubset<T, DivisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Division that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DivisionFindFirstArgs>(args?: SelectSubset<T, DivisionFindFirstArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Division that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DivisionFindFirstOrThrowArgs>(args?: SelectSubset<T, DivisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.division.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.division.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const divisionWithIdOnly = await prisma.division.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DivisionFindManyArgs>(args?: SelectSubset<T, DivisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Division.
     * @param {DivisionCreateArgs} args - Arguments to create a Division.
     * @example
     * // Create one Division
     * const Division = await prisma.division.create({
     *   data: {
     *     // ... data to create a Division
     *   }
     * })
     * 
     */
    create<T extends DivisionCreateArgs>(args: SelectSubset<T, DivisionCreateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Divisions.
     * @param {DivisionCreateManyArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DivisionCreateManyArgs>(args?: SelectSubset<T, DivisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Divisions and returns the data saved in the database.
     * @param {DivisionCreateManyAndReturnArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Divisions and only return the `id`
     * const divisionWithIdOnly = await prisma.division.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DivisionCreateManyAndReturnArgs>(args?: SelectSubset<T, DivisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Division.
     * @param {DivisionDeleteArgs} args - Arguments to delete one Division.
     * @example
     * // Delete one Division
     * const Division = await prisma.division.delete({
     *   where: {
     *     // ... filter to delete one Division
     *   }
     * })
     * 
     */
    delete<T extends DivisionDeleteArgs>(args: SelectSubset<T, DivisionDeleteArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Division.
     * @param {DivisionUpdateArgs} args - Arguments to update one Division.
     * @example
     * // Update one Division
     * const division = await prisma.division.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DivisionUpdateArgs>(args: SelectSubset<T, DivisionUpdateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Divisions.
     * @param {DivisionDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.division.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DivisionDeleteManyArgs>(args?: SelectSubset<T, DivisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DivisionUpdateManyArgs>(args: SelectSubset<T, DivisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions and returns the data updated in the database.
     * @param {DivisionUpdateManyAndReturnArgs} args - Arguments to update many Divisions.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Divisions and only return the `id`
     * const divisionWithIdOnly = await prisma.division.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DivisionUpdateManyAndReturnArgs>(args: SelectSubset<T, DivisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Division.
     * @param {DivisionUpsertArgs} args - Arguments to update or create a Division.
     * @example
     * // Update or create a Division
     * const division = await prisma.division.upsert({
     *   create: {
     *     // ... data to create a Division
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Division we want to update
     *   }
     * })
     */
    upsert<T extends DivisionUpsertArgs>(args: SelectSubset<T, DivisionUpsertArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.division.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends DivisionCountArgs>(
      args?: Subset<T, DivisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionAggregateArgs>(args: Subset<T, DivisionAggregateArgs>): Prisma.PrismaPromise<GetDivisionAggregateType<T>>

    /**
     * Group by Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DivisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DivisionGroupByArgs['orderBy'] }
        : { orderBy?: DivisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DivisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Division model
   */
  readonly fields: DivisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Division.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DivisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Division$membersArgs<ExtArgs> = {}>(args?: Subset<T, Division$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Division model
   */
  interface DivisionFieldRefs {
    readonly id: FieldRef<"Division", 'String'>
    readonly name: FieldRef<"Division", 'String'>
    readonly code: FieldRef<"Division", 'String'>
    readonly description: FieldRef<"Division", 'String'>
    readonly createdAt: FieldRef<"Division", 'DateTime'>
    readonly updatedAt: FieldRef<"Division", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Division findUnique
   */
  export type DivisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division findUniqueOrThrow
   */
  export type DivisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division findFirst
   */
  export type DivisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division findFirstOrThrow
   */
  export type DivisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division findMany
   */
  export type DivisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division create
   */
  export type DivisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Division.
     */
    data: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division createMany
   */
  export type DivisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Division createManyAndReturn
   */
  export type DivisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Division update
   */
  export type DivisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Division.
     */
    data: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
    /**
     * Choose, which Division to update.
     */
    where: DivisionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division updateMany
   */
  export type DivisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Division updateManyAndReturn
   */
  export type DivisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Division upsert
   */
  export type DivisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Division to update in case it exists.
     */
    where: DivisionWhereUniqueInput
    /**
     * In case the Division found by the `where` argument doesn't exist, create a new Division with this data.
     */
    create: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
    /**
     * In case the Division was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division delete
   */
  export type DivisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter which Division to delete.
     */
    where: DivisionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Division deleteMany
   */
  export type DivisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Divisions to delete
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to delete.
     */
    limit?: number
  }

  /**
   * Division.members
   */
  export type Division$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Division without action
   */
  export type DivisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
  }


  /**
   * Model EventAttendee
   */

  export type AggregateEventAttendee = {
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  export type EventAttendeeMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    rank: string | null
    organization: string | null
    role: string | null
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    rank: string | null
    organization: string | null
    role: string | null
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    rank: number
    organization: number
    role: number
    badgeId: number
    badgeAssignedAt: number
    accessStart: number
    accessEnd: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAttendeeMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendee to aggregate.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventAttendees
    **/
    _count?: true | EventAttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventAttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type GetEventAttendeeAggregateType<T extends EventAttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventAttendee[P]>
      : GetScalarType<T[P], AggregateEventAttendee[P]>
  }




  export type EventAttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithAggregationInput | EventAttendeeOrderByWithAggregationInput[]
    by: EventAttendeeScalarFieldEnum[] | EventAttendeeScalarFieldEnum
    having?: EventAttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventAttendeeCountAggregateInputType | true
    _min?: EventAttendeeMinAggregateInputType
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type EventAttendeeGroupByOutputType = {
    id: string
    eventId: string
    name: string
    rank: string | null
    organization: string
    role: string
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  type GetEventAttendeeGroupByPayload<T extends EventAttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventAttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventAttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
        }
      >
    >


  export type EventAttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    eventCheckins?: boolean | EventAttendee$eventCheckinsArgs<ExtArgs>
    _count?: boolean | EventAttendeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventAttendeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "rank" | "organization" | "role" | "badgeId" | "badgeAssignedAt" | "accessStart" | "accessEnd" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["eventAttendee"]>
  export type EventAttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    eventCheckins?: boolean | EventAttendee$eventCheckinsArgs<ExtArgs>
    _count?: boolean | EventAttendeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventAttendeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventAttendeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventAttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventAttendee"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs>
      eventCheckins: Prisma.$EventCheckinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      rank: string | null
      organization: string
      role: string
      badgeId: string | null
      badgeAssignedAt: Date | null
      accessStart: Date | null
      accessEnd: Date | null
      status: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["eventAttendee"]>
    composites: {}
  }

  type EventAttendeeGetPayload<S extends boolean | null | undefined | EventAttendeeDefaultArgs> = $Result.GetResult<Prisma.$EventAttendeePayload, S>

  type EventAttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventAttendeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: EventAttendeeCountAggregateInputType | true
    }

  export interface EventAttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventAttendee'], meta: { name: 'EventAttendee' } }
    /**
     * Find zero or one EventAttendee that matches the filter.
     * @param {EventAttendeeFindUniqueArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventAttendeeFindUniqueArgs>(args: SelectSubset<T, EventAttendeeFindUniqueArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventAttendee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventAttendeeFindUniqueOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventAttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventAttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventAttendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventAttendeeFindFirstArgs>(args?: SelectSubset<T, EventAttendeeFindFirstArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventAttendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventAttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventAttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventAttendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany()
     * 
     * // Get first 10 EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventAttendeeFindManyArgs>(args?: SelectSubset<T, EventAttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventAttendee.
     * @param {EventAttendeeCreateArgs} args - Arguments to create a EventAttendee.
     * @example
     * // Create one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.create({
     *   data: {
     *     // ... data to create a EventAttendee
     *   }
     * })
     * 
     */
    create<T extends EventAttendeeCreateArgs>(args: SelectSubset<T, EventAttendeeCreateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventAttendees.
     * @param {EventAttendeeCreateManyArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventAttendeeCreateManyArgs>(args?: SelectSubset<T, EventAttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventAttendees and returns the data saved in the database.
     * @param {EventAttendeeCreateManyAndReturnArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventAttendees and only return the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventAttendeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EventAttendeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventAttendee.
     * @param {EventAttendeeDeleteArgs} args - Arguments to delete one EventAttendee.
     * @example
     * // Delete one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.delete({
     *   where: {
     *     // ... filter to delete one EventAttendee
     *   }
     * })
     * 
     */
    delete<T extends EventAttendeeDeleteArgs>(args: SelectSubset<T, EventAttendeeDeleteArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventAttendee.
     * @param {EventAttendeeUpdateArgs} args - Arguments to update one EventAttendee.
     * @example
     * // Update one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventAttendeeUpdateArgs>(args: SelectSubset<T, EventAttendeeUpdateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventAttendees.
     * @param {EventAttendeeDeleteManyArgs} args - Arguments to filter EventAttendees to delete.
     * @example
     * // Delete a few EventAttendees
     * const { count } = await prisma.eventAttendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventAttendeeDeleteManyArgs>(args?: SelectSubset<T, EventAttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventAttendeeUpdateManyArgs>(args: SelectSubset<T, EventAttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAttendees and returns the data updated in the database.
     * @param {EventAttendeeUpdateManyAndReturnArgs} args - Arguments to update many EventAttendees.
     * @example
     * // Update many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventAttendees and only return the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventAttendeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EventAttendeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventAttendee.
     * @param {EventAttendeeUpsertArgs} args - Arguments to update or create a EventAttendee.
     * @example
     * // Update or create a EventAttendee
     * const eventAttendee = await prisma.eventAttendee.upsert({
     *   create: {
     *     // ... data to create a EventAttendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventAttendee we want to update
     *   }
     * })
     */
    upsert<T extends EventAttendeeUpsertArgs>(args: SelectSubset<T, EventAttendeeUpsertArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeCountArgs} args - Arguments to filter EventAttendees to count.
     * @example
     * // Count the number of EventAttendees
     * const count = await prisma.eventAttendee.count({
     *   where: {
     *     // ... the filter for the EventAttendees we want to count
     *   }
     * })
    **/
    count<T extends EventAttendeeCountArgs>(
      args?: Subset<T, EventAttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventAttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAttendeeAggregateArgs>(args: Subset<T, EventAttendeeAggregateArgs>): Prisma.PrismaPromise<GetEventAttendeeAggregateType<T>>

    /**
     * Group by EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventAttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventAttendeeGroupByArgs['orderBy'] }
        : { orderBy?: EventAttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventAttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventAttendee model
   */
  readonly fields: EventAttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventAttendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventAttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends EventAttendee$badgeArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendee$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventCheckins<T extends EventAttendee$eventCheckinsArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendee$eventCheckinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventAttendee model
   */
  interface EventAttendeeFieldRefs {
    readonly id: FieldRef<"EventAttendee", 'String'>
    readonly eventId: FieldRef<"EventAttendee", 'String'>
    readonly name: FieldRef<"EventAttendee", 'String'>
    readonly rank: FieldRef<"EventAttendee", 'String'>
    readonly organization: FieldRef<"EventAttendee", 'String'>
    readonly role: FieldRef<"EventAttendee", 'String'>
    readonly badgeId: FieldRef<"EventAttendee", 'String'>
    readonly badgeAssignedAt: FieldRef<"EventAttendee", 'DateTime'>
    readonly accessStart: FieldRef<"EventAttendee", 'DateTime'>
    readonly accessEnd: FieldRef<"EventAttendee", 'DateTime'>
    readonly status: FieldRef<"EventAttendee", 'String'>
    readonly createdAt: FieldRef<"EventAttendee", 'DateTime'>
    readonly updatedAt: FieldRef<"EventAttendee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventAttendee findUnique
   */
  export type EventAttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee findUniqueOrThrow
   */
  export type EventAttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee findFirst
   */
  export type EventAttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee findFirstOrThrow
   */
  export type EventAttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee findMany
   */
  export type EventAttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendees to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee create
   */
  export type EventAttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventAttendee.
     */
    data: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee createMany
   */
  export type EventAttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventAttendee createManyAndReturn
   */
  export type EventAttendeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAttendee update
   */
  export type EventAttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventAttendee.
     */
    data: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
    /**
     * Choose, which EventAttendee to update.
     */
    where: EventAttendeeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee updateMany
   */
  export type EventAttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventAttendees.
     */
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which EventAttendees to update
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to update.
     */
    limit?: number
  }

  /**
   * EventAttendee updateManyAndReturn
   */
  export type EventAttendeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * The data used to update EventAttendees.
     */
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which EventAttendees to update
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAttendee upsert
   */
  export type EventAttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventAttendee to update in case it exists.
     */
    where: EventAttendeeWhereUniqueInput
    /**
     * In case the EventAttendee found by the `where` argument doesn't exist, create a new EventAttendee with this data.
     */
    create: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
    /**
     * In case the EventAttendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee delete
   */
  export type EventAttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter which EventAttendee to delete.
     */
    where: EventAttendeeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventAttendee deleteMany
   */
  export type EventAttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendees to delete
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to delete.
     */
    limit?: number
  }

  /**
   * EventAttendee.badge
   */
  export type EventAttendee$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * EventAttendee.eventCheckins
   */
  export type EventAttendee$eventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    cursor?: EventCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * EventAttendee without action
   */
  export type EventAttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
  }


  /**
   * Model EventCheckin
   */

  export type AggregateEventCheckin = {
    _count: EventCheckinCountAggregateOutputType | null
    _min: EventCheckinMinAggregateOutputType | null
    _max: EventCheckinMaxAggregateOutputType | null
  }

  export type EventCheckinMinAggregateOutputType = {
    id: string | null
    eventAttendeeId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    createdAt: Date | null
  }

  export type EventCheckinMaxAggregateOutputType = {
    id: string | null
    eventAttendeeId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    createdAt: Date | null
  }

  export type EventCheckinCountAggregateOutputType = {
    id: number
    eventAttendeeId: number
    badgeId: number
    direction: number
    timestamp: number
    kioskId: number
    createdAt: number
    _all: number
  }


  export type EventCheckinMinAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
  }

  export type EventCheckinMaxAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
  }

  export type EventCheckinCountAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
    _all?: true
  }

  export type EventCheckinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCheckin to aggregate.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCheckins
    **/
    _count?: true | EventCheckinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCheckinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCheckinMaxAggregateInputType
  }

  export type GetEventCheckinAggregateType<T extends EventCheckinAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCheckin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCheckin[P]>
      : GetScalarType<T[P], AggregateEventCheckin[P]>
  }




  export type EventCheckinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithAggregationInput | EventCheckinOrderByWithAggregationInput[]
    by: EventCheckinScalarFieldEnum[] | EventCheckinScalarFieldEnum
    having?: EventCheckinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCheckinCountAggregateInputType | true
    _min?: EventCheckinMinAggregateInputType
    _max?: EventCheckinMaxAggregateInputType
  }

  export type EventCheckinGroupByOutputType = {
    id: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp: Date
    kioskId: string
    createdAt: Date | null
    _count: EventCheckinCountAggregateOutputType | null
    _min: EventCheckinMinAggregateOutputType | null
    _max: EventCheckinMaxAggregateOutputType | null
  }

  type GetEventCheckinGroupByPayload<T extends EventCheckinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCheckinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCheckinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCheckinGroupByOutputType[P]>
            : GetScalarType<T[P], EventCheckinGroupByOutputType[P]>
        }
      >
    >


  export type EventCheckinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectScalar = {
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
  }

  export type EventCheckinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventAttendeeId" | "badgeId" | "direction" | "timestamp" | "kioskId" | "createdAt", ExtArgs["result"]["eventCheckin"]>
  export type EventCheckinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }
  export type EventCheckinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }
  export type EventCheckinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }

  export type $EventCheckinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCheckin"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs>
      eventAttendee: Prisma.$EventAttendeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventAttendeeId: string
      badgeId: string
      direction: string
      timestamp: Date
      kioskId: string
      createdAt: Date | null
    }, ExtArgs["result"]["eventCheckin"]>
    composites: {}
  }

  type EventCheckinGetPayload<S extends boolean | null | undefined | EventCheckinDefaultArgs> = $Result.GetResult<Prisma.$EventCheckinPayload, S>

  type EventCheckinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventCheckinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: EventCheckinCountAggregateInputType | true
    }

  export interface EventCheckinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCheckin'], meta: { name: 'EventCheckin' } }
    /**
     * Find zero or one EventCheckin that matches the filter.
     * @param {EventCheckinFindUniqueArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCheckinFindUniqueArgs>(args: SelectSubset<T, EventCheckinFindUniqueArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventCheckin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventCheckinFindUniqueOrThrowArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCheckinFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCheckinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventCheckin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindFirstArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCheckinFindFirstArgs>(args?: SelectSubset<T, EventCheckinFindFirstArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventCheckin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindFirstOrThrowArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCheckinFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCheckinFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventCheckins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCheckins
     * const eventCheckins = await prisma.eventCheckin.findMany()
     * 
     * // Get first 10 EventCheckins
     * const eventCheckins = await prisma.eventCheckin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCheckinFindManyArgs>(args?: SelectSubset<T, EventCheckinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventCheckin.
     * @param {EventCheckinCreateArgs} args - Arguments to create a EventCheckin.
     * @example
     * // Create one EventCheckin
     * const EventCheckin = await prisma.eventCheckin.create({
     *   data: {
     *     // ... data to create a EventCheckin
     *   }
     * })
     * 
     */
    create<T extends EventCheckinCreateArgs>(args: SelectSubset<T, EventCheckinCreateArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventCheckins.
     * @param {EventCheckinCreateManyArgs} args - Arguments to create many EventCheckins.
     * @example
     * // Create many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCheckinCreateManyArgs>(args?: SelectSubset<T, EventCheckinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventCheckins and returns the data saved in the database.
     * @param {EventCheckinCreateManyAndReturnArgs} args - Arguments to create many EventCheckins.
     * @example
     * // Create many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventCheckins and only return the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCheckinCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCheckinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventCheckin.
     * @param {EventCheckinDeleteArgs} args - Arguments to delete one EventCheckin.
     * @example
     * // Delete one EventCheckin
     * const EventCheckin = await prisma.eventCheckin.delete({
     *   where: {
     *     // ... filter to delete one EventCheckin
     *   }
     * })
     * 
     */
    delete<T extends EventCheckinDeleteArgs>(args: SelectSubset<T, EventCheckinDeleteArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventCheckin.
     * @param {EventCheckinUpdateArgs} args - Arguments to update one EventCheckin.
     * @example
     * // Update one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCheckinUpdateArgs>(args: SelectSubset<T, EventCheckinUpdateArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventCheckins.
     * @param {EventCheckinDeleteManyArgs} args - Arguments to filter EventCheckins to delete.
     * @example
     * // Delete a few EventCheckins
     * const { count } = await prisma.eventCheckin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCheckinDeleteManyArgs>(args?: SelectSubset<T, EventCheckinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCheckinUpdateManyArgs>(args: SelectSubset<T, EventCheckinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCheckins and returns the data updated in the database.
     * @param {EventCheckinUpdateManyAndReturnArgs} args - Arguments to update many EventCheckins.
     * @example
     * // Update many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventCheckins and only return the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventCheckinUpdateManyAndReturnArgs>(args: SelectSubset<T, EventCheckinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventCheckin.
     * @param {EventCheckinUpsertArgs} args - Arguments to update or create a EventCheckin.
     * @example
     * // Update or create a EventCheckin
     * const eventCheckin = await prisma.eventCheckin.upsert({
     *   create: {
     *     // ... data to create a EventCheckin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCheckin we want to update
     *   }
     * })
     */
    upsert<T extends EventCheckinUpsertArgs>(args: SelectSubset<T, EventCheckinUpsertArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinCountArgs} args - Arguments to filter EventCheckins to count.
     * @example
     * // Count the number of EventCheckins
     * const count = await prisma.eventCheckin.count({
     *   where: {
     *     // ... the filter for the EventCheckins we want to count
     *   }
     * })
    **/
    count<T extends EventCheckinCountArgs>(
      args?: Subset<T, EventCheckinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCheckinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCheckinAggregateArgs>(args: Subset<T, EventCheckinAggregateArgs>): Prisma.PrismaPromise<GetEventCheckinAggregateType<T>>

    /**
     * Group by EventCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCheckinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCheckinGroupByArgs['orderBy'] }
        : { orderBy?: EventCheckinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCheckinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCheckinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCheckin model
   */
  readonly fields: EventCheckinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCheckin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCheckinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventAttendee<T extends EventAttendeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendeeDefaultArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCheckin model
   */
  interface EventCheckinFieldRefs {
    readonly id: FieldRef<"EventCheckin", 'String'>
    readonly eventAttendeeId: FieldRef<"EventCheckin", 'String'>
    readonly badgeId: FieldRef<"EventCheckin", 'String'>
    readonly direction: FieldRef<"EventCheckin", 'String'>
    readonly timestamp: FieldRef<"EventCheckin", 'DateTime'>
    readonly kioskId: FieldRef<"EventCheckin", 'String'>
    readonly createdAt: FieldRef<"EventCheckin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventCheckin findUnique
   */
  export type EventCheckinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where: EventCheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin findUniqueOrThrow
   */
  export type EventCheckinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where: EventCheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin findFirst
   */
  export type EventCheckinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCheckins.
     */
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin findFirstOrThrow
   */
  export type EventCheckinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCheckins.
     */
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin findMany
   */
  export type EventCheckinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckins to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin create
   */
  export type EventCheckinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCheckin.
     */
    data: XOR<EventCheckinCreateInput, EventCheckinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin createMany
   */
  export type EventCheckinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCheckins.
     */
    data: EventCheckinCreateManyInput | EventCheckinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCheckin createManyAndReturn
   */
  export type EventCheckinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * The data used to create many EventCheckins.
     */
    data: EventCheckinCreateManyInput | EventCheckinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCheckin update
   */
  export type EventCheckinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCheckin.
     */
    data: XOR<EventCheckinUpdateInput, EventCheckinUncheckedUpdateInput>
    /**
     * Choose, which EventCheckin to update.
     */
    where: EventCheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin updateMany
   */
  export type EventCheckinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCheckins.
     */
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyInput>
    /**
     * Filter which EventCheckins to update
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to update.
     */
    limit?: number
  }

  /**
   * EventCheckin updateManyAndReturn
   */
  export type EventCheckinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * The data used to update EventCheckins.
     */
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyInput>
    /**
     * Filter which EventCheckins to update
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCheckin upsert
   */
  export type EventCheckinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCheckin to update in case it exists.
     */
    where: EventCheckinWhereUniqueInput
    /**
     * In case the EventCheckin found by the `where` argument doesn't exist, create a new EventCheckin with this data.
     */
    create: XOR<EventCheckinCreateInput, EventCheckinUncheckedCreateInput>
    /**
     * In case the EventCheckin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCheckinUpdateInput, EventCheckinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin delete
   */
  export type EventCheckinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter which EventCheckin to delete.
     */
    where: EventCheckinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * EventCheckin deleteMany
   */
  export type EventCheckinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCheckins to delete
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to delete.
     */
    limit?: number
  }

  /**
   * EventCheckin without action
   */
  export type EventCheckinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    autoExpireBadges: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    autoExpireBadges: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    startDate: number
    endDate: number
    status: number
    autoExpireBadges: number
    customRoles: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    customRoles?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    startDate: Date
    endDate: Date
    status: string
    autoExpireBadges: boolean | null
    customRoles: JsonValue | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventAttendees?: boolean | Event$eventAttendeesArgs<ExtArgs>
    visitors?: boolean | Event$visitorsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "startDate" | "endDate" | "status" | "autoExpireBadges" | "customRoles" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventAttendees?: boolean | Event$eventAttendeesArgs<ExtArgs>
    visitors?: boolean | Event$visitorsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      eventAttendees: Prisma.$EventAttendeePayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      startDate: Date
      endDate: Date
      status: string
      autoExpireBadges: boolean | null
      customRoles: Prisma.JsonValue | null
      createdBy: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventAttendees<T extends Event$eventAttendeesArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventAttendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Event$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Event$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly code: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly status: FieldRef<"Event", 'String'>
    readonly autoExpireBadges: FieldRef<"Event", 'Boolean'>
    readonly customRoles: FieldRef<"Event", 'Json'>
    readonly createdBy: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.eventAttendees
   */
  export type Event$eventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * Event.visitors
   */
  export type Event$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    missedCheckoutCount: number | null
  }

  export type MemberSumAggregateOutputType = {
    missedCheckoutCount: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    serviceNumber: string | null
    rankId: string | null
    rank: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string | null
    status: string | null
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
    missedCheckoutCount: number | null
    lastMissedCheckout: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    serviceNumber: string | null
    rankId: string | null
    rank: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string | null
    status: string | null
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
    missedCheckoutCount: number | null
    lastMissedCheckout: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    serviceNumber: number
    rankId: number
    rank: number
    firstName: number
    lastName: number
    email: number
    mobilePhone: number
    divisionId: number
    badgeId: number
    memberType: number
    status: number
    memberTypeId: number
    memberStatusId: number
    createdAt: number
    updatedAt: number
    employeeNumber: number
    initials: number
    mess: number
    moc: number
    classDetails: number
    homePhone: number
    notes: number
    contract_start: number
    contract_end: number
    missedCheckoutCount: number
    lastMissedCheckout: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    missedCheckoutCount?: true
  }

  export type MemberSumAggregateInputType = {
    missedCheckoutCount?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    serviceNumber?: true
    rankId?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
    missedCheckoutCount?: true
    lastMissedCheckout?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    serviceNumber?: true
    rankId?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
    missedCheckoutCount?: true
    lastMissedCheckout?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    serviceNumber?: true
    rankId?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
    missedCheckoutCount?: true
    lastMissedCheckout?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string
    status: string
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
    missedCheckoutCount: number
    lastMissedCheckout: Date | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rankId?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    missedCheckoutCount?: boolean
    lastMissedCheckout?: boolean
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    bmqEnrollments?: boolean | Member$bmqEnrollmentsArgs<ExtArgs>
    checkins?: boolean | Member$checkinsArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    visitors?: boolean | Member$visitorsArgs<ExtArgs>
    memberTags?: boolean | Member$memberTagsArgs<ExtArgs>
    ddsAssignments?: boolean | Member$ddsAssignmentsArgs<ExtArgs>
    ddsTransfers?: boolean | Member$ddsTransfersArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
    qualifications?: boolean | Member$qualificationsArgs<ExtArgs>
    scheduleAssignments?: boolean | Member$scheduleAssignmentsArgs<ExtArgs>
    lockupHolding?: boolean | Member$lockupHoldingArgs<ExtArgs>
    lockupSecured?: boolean | Member$lockupSecuredArgs<ExtArgs>
    lockupTransfersFrom?: boolean | Member$lockupTransfersFromArgs<ExtArgs>
    lockupTransfersTo?: boolean | Member$lockupTransfersToArgs<ExtArgs>
    lockupExecutions?: boolean | Member$lockupExecutionsArgs<ExtArgs>
    missedCheckouts?: boolean | Member$missedCheckoutsArgs<ExtArgs>
    unitEventDutyAssignments?: boolean | Member$unitEventDutyAssignmentsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rankId?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    missedCheckoutCount?: boolean
    lastMissedCheckout?: boolean
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rankId?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    missedCheckoutCount?: boolean
    lastMissedCheckout?: boolean
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    serviceNumber?: boolean
    rankId?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    missedCheckoutCount?: boolean
    lastMissedCheckout?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceNumber" | "rankId" | "rank" | "firstName" | "lastName" | "email" | "mobilePhone" | "divisionId" | "badgeId" | "memberType" | "status" | "memberTypeId" | "memberStatusId" | "createdAt" | "updatedAt" | "employeeNumber" | "initials" | "mess" | "moc" | "classDetails" | "homePhone" | "notes" | "contract_start" | "contract_end" | "missedCheckoutCount" | "lastMissedCheckout", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    bmqEnrollments?: boolean | Member$bmqEnrollmentsArgs<ExtArgs>
    checkins?: boolean | Member$checkinsArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    visitors?: boolean | Member$visitorsArgs<ExtArgs>
    memberTags?: boolean | Member$memberTagsArgs<ExtArgs>
    ddsAssignments?: boolean | Member$ddsAssignmentsArgs<ExtArgs>
    ddsTransfers?: boolean | Member$ddsTransfersArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
    qualifications?: boolean | Member$qualificationsArgs<ExtArgs>
    scheduleAssignments?: boolean | Member$scheduleAssignmentsArgs<ExtArgs>
    lockupHolding?: boolean | Member$lockupHoldingArgs<ExtArgs>
    lockupSecured?: boolean | Member$lockupSecuredArgs<ExtArgs>
    lockupTransfersFrom?: boolean | Member$lockupTransfersFromArgs<ExtArgs>
    lockupTransfersTo?: boolean | Member$lockupTransfersToArgs<ExtArgs>
    lockupExecutions?: boolean | Member$lockupExecutionsArgs<ExtArgs>
    missedCheckouts?: boolean | Member$missedCheckoutsArgs<ExtArgs>
    unitEventDutyAssignments?: boolean | Member$unitEventDutyAssignmentsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rankRef?: boolean | Member$rankRefArgs<ExtArgs>
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      rankRef: Prisma.$RankPayload<ExtArgs> | null
      badge: Prisma.$BadgePayload<ExtArgs> | null
      bmqEnrollments: Prisma.$BmqEnrollmentPayload<ExtArgs>[]
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      division: Prisma.$DivisionPayload<ExtArgs> | null
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      memberTags: Prisma.$MemberTagPayload<ExtArgs>[]
      ddsAssignments: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      ddsTransfers: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      memberTypeRef: Prisma.$MemberTypePayload<ExtArgs> | null
      memberStatusRef: Prisma.$MemberStatusPayload<ExtArgs> | null
      qualifications: Prisma.$MemberQualificationPayload<ExtArgs>[]
      scheduleAssignments: Prisma.$ScheduleAssignmentPayload<ExtArgs>[]
      lockupHolding: Prisma.$LockupStatusPayload<ExtArgs>[]
      lockupSecured: Prisma.$LockupStatusPayload<ExtArgs>[]
      lockupTransfersFrom: Prisma.$LockupTransferPayload<ExtArgs>[]
      lockupTransfersTo: Prisma.$LockupTransferPayload<ExtArgs>[]
      lockupExecutions: Prisma.$LockupExecutionPayload<ExtArgs>[]
      missedCheckouts: Prisma.$MissedCheckoutPayload<ExtArgs>[]
      unitEventDutyAssignments: Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceNumber: string
      rankId: string
      rank: string
      firstName: string
      lastName: string
      email: string | null
      mobilePhone: string | null
      divisionId: string | null
      badgeId: string | null
      memberType: string
      status: string
      memberTypeId: string | null
      memberStatusId: string | null
      createdAt: Date | null
      updatedAt: Date | null
      employeeNumber: string | null
      initials: string | null
      mess: string | null
      moc: string | null
      classDetails: string | null
      homePhone: string | null
      notes: string | null
      contract_start: Date | null
      contract_end: Date | null
      missedCheckoutCount: number
      lastMissedCheckout: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rankRef<T extends Member$rankRefArgs<ExtArgs> = {}>(args?: Subset<T, Member$rankRefArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    badge<T extends Member$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Member$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bmqEnrollments<T extends Member$bmqEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$bmqEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkins<T extends Member$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Member$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    division<T extends Member$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Member$divisionArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitors<T extends Member$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Member$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberTags<T extends Member$memberTagsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsAssignments<T extends Member$ddsAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$ddsAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsTransfers<T extends Member$ddsTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Member$ddsTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberTypeRef<T extends Member$memberTypeRefArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberTypeRefArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    memberStatusRef<T extends Member$memberStatusRefArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberStatusRefArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qualifications<T extends Member$qualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$qualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleAssignments<T extends Member$scheduleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$scheduleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lockupHolding<T extends Member$lockupHoldingArgs<ExtArgs> = {}>(args?: Subset<T, Member$lockupHoldingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lockupSecured<T extends Member$lockupSecuredArgs<ExtArgs> = {}>(args?: Subset<T, Member$lockupSecuredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lockupTransfersFrom<T extends Member$lockupTransfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Member$lockupTransfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lockupTransfersTo<T extends Member$lockupTransfersToArgs<ExtArgs> = {}>(args?: Subset<T, Member$lockupTransfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lockupExecutions<T extends Member$lockupExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Member$lockupExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    missedCheckouts<T extends Member$missedCheckoutsArgs<ExtArgs> = {}>(args?: Subset<T, Member$missedCheckoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitEventDutyAssignments<T extends Member$unitEventDutyAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$unitEventDutyAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly serviceNumber: FieldRef<"Member", 'String'>
    readonly rankId: FieldRef<"Member", 'String'>
    readonly rank: FieldRef<"Member", 'String'>
    readonly firstName: FieldRef<"Member", 'String'>
    readonly lastName: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly mobilePhone: FieldRef<"Member", 'String'>
    readonly divisionId: FieldRef<"Member", 'String'>
    readonly badgeId: FieldRef<"Member", 'String'>
    readonly memberType: FieldRef<"Member", 'String'>
    readonly status: FieldRef<"Member", 'String'>
    readonly memberTypeId: FieldRef<"Member", 'String'>
    readonly memberStatusId: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly employeeNumber: FieldRef<"Member", 'String'>
    readonly initials: FieldRef<"Member", 'String'>
    readonly mess: FieldRef<"Member", 'String'>
    readonly moc: FieldRef<"Member", 'String'>
    readonly classDetails: FieldRef<"Member", 'String'>
    readonly homePhone: FieldRef<"Member", 'String'>
    readonly notes: FieldRef<"Member", 'String'>
    readonly contract_start: FieldRef<"Member", 'DateTime'>
    readonly contract_end: FieldRef<"Member", 'DateTime'>
    readonly missedCheckoutCount: FieldRef<"Member", 'Int'>
    readonly lastMissedCheckout: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.rankRef
   */
  export type Member$rankRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    where?: RankWhereInput
  }

  /**
   * Member.badge
   */
  export type Member$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Member.bmqEnrollments
   */
  export type Member$bmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    cursor?: BmqEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * Member.checkins
   */
  export type Member$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Member.division
   */
  export type Member$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
  }

  /**
   * Member.visitors
   */
  export type Member$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Member.memberTags
   */
  export type Member$memberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    cursor?: MemberTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * Member.ddsAssignments
   */
  export type Member$ddsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * Member.ddsTransfers
   */
  export type Member$ddsTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * Member.memberTypeRef
   */
  export type Member$memberTypeRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    where?: MemberTypeWhereInput
  }

  /**
   * Member.memberStatusRef
   */
  export type Member$memberStatusRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    where?: MemberStatusWhereInput
  }

  /**
   * Member.qualifications
   */
  export type Member$qualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    where?: MemberQualificationWhereInput
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    cursor?: MemberQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
  }

  /**
   * Member.scheduleAssignments
   */
  export type Member$scheduleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    where?: ScheduleAssignmentWhereInput
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    cursor?: ScheduleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
  }

  /**
   * Member.lockupHolding
   */
  export type Member$lockupHoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    where?: LockupStatusWhereInput
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    cursor?: LockupStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupStatusScalarFieldEnum | LockupStatusScalarFieldEnum[]
  }

  /**
   * Member.lockupSecured
   */
  export type Member$lockupSecuredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    where?: LockupStatusWhereInput
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    cursor?: LockupStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupStatusScalarFieldEnum | LockupStatusScalarFieldEnum[]
  }

  /**
   * Member.lockupTransfersFrom
   */
  export type Member$lockupTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    where?: LockupTransferWhereInput
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    cursor?: LockupTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
  }

  /**
   * Member.lockupTransfersTo
   */
  export type Member$lockupTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    where?: LockupTransferWhereInput
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    cursor?: LockupTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
  }

  /**
   * Member.lockupExecutions
   */
  export type Member$lockupExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    where?: LockupExecutionWhereInput
    orderBy?: LockupExecutionOrderByWithRelationInput | LockupExecutionOrderByWithRelationInput[]
    cursor?: LockupExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupExecutionScalarFieldEnum | LockupExecutionScalarFieldEnum[]
  }

  /**
   * Member.missedCheckouts
   */
  export type Member$missedCheckoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    where?: MissedCheckoutWhereInput
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    cursor?: MissedCheckoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissedCheckoutScalarFieldEnum | MissedCheckoutScalarFieldEnum[]
  }

  /**
   * Member.unitEventDutyAssignments
   */
  export type Member$unitEventDutyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    where?: UnitEventDutyAssignmentWhereInput
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TagSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    displayOrder: number
    chipVariant: number
    chipColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TagSumAggregateInputType = {
    displayOrder?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    displayOrder: number
    chipVariant: string
    chipColor: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberTags?: boolean | Tag$memberTagsArgs<ExtArgs>
    qualificationTypes?: boolean | Tag$qualificationTypesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "displayOrder" | "chipVariant" | "chipColor" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberTags?: boolean | Tag$memberTagsArgs<ExtArgs>
    qualificationTypes?: boolean | Tag$qualificationTypesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      memberTags: Prisma.$MemberTagPayload<ExtArgs>[]
      qualificationTypes: Prisma.$QualificationTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      displayOrder: number
      chipVariant: string
      chipColor: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberTags<T extends Tag$memberTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$memberTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualificationTypes<T extends Tag$qualificationTypesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$qualificationTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly displayOrder: FieldRef<"Tag", 'Int'>
    readonly chipVariant: FieldRef<"Tag", 'String'>
    readonly chipColor: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.memberTags
   */
  export type Tag$memberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    cursor?: MemberTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * Tag.qualificationTypes
   */
  export type Tag$qualificationTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    where?: QualificationTypeWhereInput
    orderBy?: QualificationTypeOrderByWithRelationInput | QualificationTypeOrderByWithRelationInput[]
    cursor?: QualificationTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualificationTypeScalarFieldEnum | QualificationTypeScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model MemberTag
   */

  export type AggregateMemberTag = {
    _count: MemberTagCountAggregateOutputType | null
    _min: MemberTagMinAggregateOutputType | null
    _max: MemberTagMaxAggregateOutputType | null
  }

  export type MemberTagMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MemberTagMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MemberTagCountAggregateOutputType = {
    id: number
    memberId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type MemberTagMinAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
  }

  export type MemberTagMaxAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
  }

  export type MemberTagCountAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type MemberTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTag to aggregate.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberTags
    **/
    _count?: true | MemberTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberTagMaxAggregateInputType
  }

  export type GetMemberTagAggregateType<T extends MemberTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberTag[P]>
      : GetScalarType<T[P], AggregateMemberTag[P]>
  }




  export type MemberTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithAggregationInput | MemberTagOrderByWithAggregationInput[]
    by: MemberTagScalarFieldEnum[] | MemberTagScalarFieldEnum
    having?: MemberTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberTagCountAggregateInputType | true
    _min?: MemberTagMinAggregateInputType
    _max?: MemberTagMaxAggregateInputType
  }

  export type MemberTagGroupByOutputType = {
    id: string
    memberId: string
    tagId: string
    createdAt: Date | null
    _count: MemberTagCountAggregateOutputType | null
    _min: MemberTagMinAggregateOutputType | null
    _max: MemberTagMaxAggregateOutputType | null
  }

  type GetMemberTagGroupByPayload<T extends MemberTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberTagGroupByOutputType[P]>
            : GetScalarType<T[P], MemberTagGroupByOutputType[P]>
        }
      >
    >


  export type MemberTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectScalar = {
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type MemberTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "tagId" | "createdAt", ExtArgs["result"]["memberTag"]>
  export type MemberTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MemberTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MemberTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $MemberTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberTag"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      tagId: string
      createdAt: Date | null
    }, ExtArgs["result"]["memberTag"]>
    composites: {}
  }

  type MemberTagGetPayload<S extends boolean | null | undefined | MemberTagDefaultArgs> = $Result.GetResult<Prisma.$MemberTagPayload, S>

  type MemberTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MemberTagCountAggregateInputType | true
    }

  export interface MemberTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberTag'], meta: { name: 'MemberTag' } }
    /**
     * Find zero or one MemberTag that matches the filter.
     * @param {MemberTagFindUniqueArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberTagFindUniqueArgs>(args: SelectSubset<T, MemberTagFindUniqueArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberTagFindUniqueOrThrowArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberTagFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindFirstArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberTagFindFirstArgs>(args?: SelectSubset<T, MemberTagFindFirstArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindFirstOrThrowArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberTagFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberTags
     * const memberTags = await prisma.memberTag.findMany()
     * 
     * // Get first 10 MemberTags
     * const memberTags = await prisma.memberTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberTagFindManyArgs>(args?: SelectSubset<T, MemberTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberTag.
     * @param {MemberTagCreateArgs} args - Arguments to create a MemberTag.
     * @example
     * // Create one MemberTag
     * const MemberTag = await prisma.memberTag.create({
     *   data: {
     *     // ... data to create a MemberTag
     *   }
     * })
     * 
     */
    create<T extends MemberTagCreateArgs>(args: SelectSubset<T, MemberTagCreateArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberTags.
     * @param {MemberTagCreateManyArgs} args - Arguments to create many MemberTags.
     * @example
     * // Create many MemberTags
     * const memberTag = await prisma.memberTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberTagCreateManyArgs>(args?: SelectSubset<T, MemberTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberTags and returns the data saved in the database.
     * @param {MemberTagCreateManyAndReturnArgs} args - Arguments to create many MemberTags.
     * @example
     * // Create many MemberTags
     * const memberTag = await prisma.memberTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberTags and only return the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberTagCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberTag.
     * @param {MemberTagDeleteArgs} args - Arguments to delete one MemberTag.
     * @example
     * // Delete one MemberTag
     * const MemberTag = await prisma.memberTag.delete({
     *   where: {
     *     // ... filter to delete one MemberTag
     *   }
     * })
     * 
     */
    delete<T extends MemberTagDeleteArgs>(args: SelectSubset<T, MemberTagDeleteArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberTag.
     * @param {MemberTagUpdateArgs} args - Arguments to update one MemberTag.
     * @example
     * // Update one MemberTag
     * const memberTag = await prisma.memberTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberTagUpdateArgs>(args: SelectSubset<T, MemberTagUpdateArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberTags.
     * @param {MemberTagDeleteManyArgs} args - Arguments to filter MemberTags to delete.
     * @example
     * // Delete a few MemberTags
     * const { count } = await prisma.memberTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberTagDeleteManyArgs>(args?: SelectSubset<T, MemberTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberTags
     * const memberTag = await prisma.memberTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberTagUpdateManyArgs>(args: SelectSubset<T, MemberTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTags and returns the data updated in the database.
     * @param {MemberTagUpdateManyAndReturnArgs} args - Arguments to update many MemberTags.
     * @example
     * // Update many MemberTags
     * const memberTag = await prisma.memberTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberTags and only return the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberTagUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberTag.
     * @param {MemberTagUpsertArgs} args - Arguments to update or create a MemberTag.
     * @example
     * // Update or create a MemberTag
     * const memberTag = await prisma.memberTag.upsert({
     *   create: {
     *     // ... data to create a MemberTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberTag we want to update
     *   }
     * })
     */
    upsert<T extends MemberTagUpsertArgs>(args: SelectSubset<T, MemberTagUpsertArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagCountArgs} args - Arguments to filter MemberTags to count.
     * @example
     * // Count the number of MemberTags
     * const count = await prisma.memberTag.count({
     *   where: {
     *     // ... the filter for the MemberTags we want to count
     *   }
     * })
    **/
    count<T extends MemberTagCountArgs>(
      args?: Subset<T, MemberTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberTagAggregateArgs>(args: Subset<T, MemberTagAggregateArgs>): Prisma.PrismaPromise<GetMemberTagAggregateType<T>>

    /**
     * Group by MemberTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberTagGroupByArgs['orderBy'] }
        : { orderBy?: MemberTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberTag model
   */
  readonly fields: MemberTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberTag model
   */
  interface MemberTagFieldRefs {
    readonly id: FieldRef<"MemberTag", 'String'>
    readonly memberId: FieldRef<"MemberTag", 'String'>
    readonly tagId: FieldRef<"MemberTag", 'String'>
    readonly createdAt: FieldRef<"MemberTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberTag findUnique
   */
  export type MemberTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where: MemberTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag findUniqueOrThrow
   */
  export type MemberTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where: MemberTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag findFirst
   */
  export type MemberTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTags.
     */
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag findFirstOrThrow
   */
  export type MemberTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTags.
     */
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag findMany
   */
  export type MemberTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTags to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag create
   */
  export type MemberTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberTag.
     */
    data: XOR<MemberTagCreateInput, MemberTagUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag createMany
   */
  export type MemberTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberTags.
     */
    data: MemberTagCreateManyInput | MemberTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberTag createManyAndReturn
   */
  export type MemberTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * The data used to create many MemberTags.
     */
    data: MemberTagCreateManyInput | MemberTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberTag update
   */
  export type MemberTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberTag.
     */
    data: XOR<MemberTagUpdateInput, MemberTagUncheckedUpdateInput>
    /**
     * Choose, which MemberTag to update.
     */
    where: MemberTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag updateMany
   */
  export type MemberTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberTags.
     */
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyInput>
    /**
     * Filter which MemberTags to update
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to update.
     */
    limit?: number
  }

  /**
   * MemberTag updateManyAndReturn
   */
  export type MemberTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * The data used to update MemberTags.
     */
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyInput>
    /**
     * Filter which MemberTags to update
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberTag upsert
   */
  export type MemberTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberTag to update in case it exists.
     */
    where: MemberTagWhereUniqueInput
    /**
     * In case the MemberTag found by the `where` argument doesn't exist, create a new MemberTag with this data.
     */
    create: XOR<MemberTagCreateInput, MemberTagUncheckedCreateInput>
    /**
     * In case the MemberTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberTagUpdateInput, MemberTagUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag delete
   */
  export type MemberTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter which MemberTag to delete.
     */
    where: MemberTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberTag deleteMany
   */
  export type MemberTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTags to delete
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to delete.
     */
    limit?: number
  }

  /**
   * MemberTag without action
   */
  export type MemberTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
  }


  /**
   * Model SecurityAlert
   */

  export type AggregateSecurityAlert = {
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  export type SecurityAlertMinAggregateOutputType = {
    id: string | null
    alertType: string | null
    severity: string | null
    badgeSerial: string | null
    memberId: string | null
    kioskId: string | null
    message: string | null
    status: string | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date | null
  }

  export type SecurityAlertMaxAggregateOutputType = {
    id: string | null
    alertType: string | null
    severity: string | null
    badgeSerial: string | null
    memberId: string | null
    kioskId: string | null
    message: string | null
    status: string | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date | null
  }

  export type SecurityAlertCountAggregateOutputType = {
    id: number
    alertType: number
    severity: number
    badgeSerial: number
    memberId: number
    kioskId: number
    message: number
    details: number
    status: number
    acknowledgedBy: number
    acknowledgedAt: number
    acknowledgeNote: number
    createdAt: number
    _all: number
  }


  export type SecurityAlertMinAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
  }

  export type SecurityAlertMaxAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
  }

  export type SecurityAlertCountAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    details?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlert to aggregate.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityAlerts
    **/
    _count?: true | SecurityAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type GetSecurityAlertAggregateType<T extends SecurityAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityAlert[P]>
      : GetScalarType<T[P], AggregateSecurityAlert[P]>
  }




  export type SecurityAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithAggregationInput | SecurityAlertOrderByWithAggregationInput[]
    by: SecurityAlertScalarFieldEnum[] | SecurityAlertScalarFieldEnum
    having?: SecurityAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityAlertCountAggregateInputType | true
    _min?: SecurityAlertMinAggregateInputType
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type SecurityAlertGroupByOutputType = {
    id: string
    alertType: string
    severity: string
    badgeSerial: string | null
    memberId: string | null
    kioskId: string
    message: string
    details: JsonValue | null
    status: string
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  type GetSecurityAlertGroupByPayload<T extends SecurityAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
        }
      >
    >


  export type SecurityAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectScalar = {
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
  }

  export type SecurityAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alertType" | "severity" | "badgeSerial" | "memberId" | "kioskId" | "message" | "details" | "status" | "acknowledgedBy" | "acknowledgedAt" | "acknowledgeNote" | "createdAt", ExtArgs["result"]["securityAlert"]>
  export type SecurityAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }
  export type SecurityAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }
  export type SecurityAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }

  export type $SecurityAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityAlert"
    objects: {
      acknowledgedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertType: string
      severity: string
      badgeSerial: string | null
      memberId: string | null
      kioskId: string
      message: string
      details: Prisma.JsonValue | null
      status: string
      acknowledgedBy: string | null
      acknowledgedAt: Date | null
      acknowledgeNote: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityAlert"]>
    composites: {}
  }

  type SecurityAlertGetPayload<S extends boolean | null | undefined | SecurityAlertDefaultArgs> = $Result.GetResult<Prisma.$SecurityAlertPayload, S>

  type SecurityAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SecurityAlertCountAggregateInputType | true
    }

  export interface SecurityAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityAlert'], meta: { name: 'SecurityAlert' } }
    /**
     * Find zero or one SecurityAlert that matches the filter.
     * @param {SecurityAlertFindUniqueArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityAlertFindUniqueArgs>(args: SelectSubset<T, SecurityAlertFindUniqueArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityAlertFindUniqueOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityAlertFindFirstArgs>(args?: SelectSubset<T, SecurityAlertFindFirstArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany()
     * 
     * // Get first 10 SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityAlertFindManyArgs>(args?: SelectSubset<T, SecurityAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityAlert.
     * @param {SecurityAlertCreateArgs} args - Arguments to create a SecurityAlert.
     * @example
     * // Create one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.create({
     *   data: {
     *     // ... data to create a SecurityAlert
     *   }
     * })
     * 
     */
    create<T extends SecurityAlertCreateArgs>(args: SelectSubset<T, SecurityAlertCreateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityAlerts.
     * @param {SecurityAlertCreateManyArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityAlertCreateManyArgs>(args?: SelectSubset<T, SecurityAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityAlerts and returns the data saved in the database.
     * @param {SecurityAlertCreateManyAndReturnArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityAlert.
     * @param {SecurityAlertDeleteArgs} args - Arguments to delete one SecurityAlert.
     * @example
     * // Delete one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.delete({
     *   where: {
     *     // ... filter to delete one SecurityAlert
     *   }
     * })
     * 
     */
    delete<T extends SecurityAlertDeleteArgs>(args: SelectSubset<T, SecurityAlertDeleteArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityAlert.
     * @param {SecurityAlertUpdateArgs} args - Arguments to update one SecurityAlert.
     * @example
     * // Update one SecurityAlert
     * const securityAlert = await prisma.securityAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityAlertUpdateArgs>(args: SelectSubset<T, SecurityAlertUpdateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityAlerts.
     * @param {SecurityAlertDeleteManyArgs} args - Arguments to filter SecurityAlerts to delete.
     * @example
     * // Delete a few SecurityAlerts
     * const { count } = await prisma.securityAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityAlertDeleteManyArgs>(args?: SelectSubset<T, SecurityAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityAlertUpdateManyArgs>(args: SelectSubset<T, SecurityAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts and returns the data updated in the database.
     * @param {SecurityAlertUpdateManyAndReturnArgs} args - Arguments to update many SecurityAlerts.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityAlert.
     * @param {SecurityAlertUpsertArgs} args - Arguments to update or create a SecurityAlert.
     * @example
     * // Update or create a SecurityAlert
     * const securityAlert = await prisma.securityAlert.upsert({
     *   create: {
     *     // ... data to create a SecurityAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityAlert we want to update
     *   }
     * })
     */
    upsert<T extends SecurityAlertUpsertArgs>(args: SelectSubset<T, SecurityAlertUpsertArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertCountArgs} args - Arguments to filter SecurityAlerts to count.
     * @example
     * // Count the number of SecurityAlerts
     * const count = await prisma.securityAlert.count({
     *   where: {
     *     // ... the filter for the SecurityAlerts we want to count
     *   }
     * })
    **/
    count<T extends SecurityAlertCountArgs>(
      args?: Subset<T, SecurityAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityAlertAggregateArgs>(args: Subset<T, SecurityAlertAggregateArgs>): Prisma.PrismaPromise<GetSecurityAlertAggregateType<T>>

    /**
     * Group by SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityAlertGroupByArgs['orderBy'] }
        : { orderBy?: SecurityAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityAlert model
   */
  readonly fields: SecurityAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acknowledgedByAdmin<T extends SecurityAlert$acknowledgedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, SecurityAlert$acknowledgedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityAlert model
   */
  interface SecurityAlertFieldRefs {
    readonly id: FieldRef<"SecurityAlert", 'String'>
    readonly alertType: FieldRef<"SecurityAlert", 'String'>
    readonly severity: FieldRef<"SecurityAlert", 'String'>
    readonly badgeSerial: FieldRef<"SecurityAlert", 'String'>
    readonly memberId: FieldRef<"SecurityAlert", 'String'>
    readonly kioskId: FieldRef<"SecurityAlert", 'String'>
    readonly message: FieldRef<"SecurityAlert", 'String'>
    readonly details: FieldRef<"SecurityAlert", 'Json'>
    readonly status: FieldRef<"SecurityAlert", 'String'>
    readonly acknowledgedBy: FieldRef<"SecurityAlert", 'String'>
    readonly acknowledgedAt: FieldRef<"SecurityAlert", 'DateTime'>
    readonly acknowledgeNote: FieldRef<"SecurityAlert", 'String'>
    readonly createdAt: FieldRef<"SecurityAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityAlert findUnique
   */
  export type SecurityAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert findUniqueOrThrow
   */
  export type SecurityAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert findFirst
   */
  export type SecurityAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert findFirstOrThrow
   */
  export type SecurityAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert findMany
   */
  export type SecurityAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlerts to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert create
   */
  export type SecurityAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityAlert.
     */
    data: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert createMany
   */
  export type SecurityAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAlert createManyAndReturn
   */
  export type SecurityAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert update
   */
  export type SecurityAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityAlert.
     */
    data: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
    /**
     * Choose, which SecurityAlert to update.
     */
    where: SecurityAlertWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert updateMany
   */
  export type SecurityAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
  }

  /**
   * SecurityAlert updateManyAndReturn
   */
  export type SecurityAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert upsert
   */
  export type SecurityAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityAlert to update in case it exists.
     */
    where: SecurityAlertWhereUniqueInput
    /**
     * In case the SecurityAlert found by the `where` argument doesn't exist, create a new SecurityAlert with this data.
     */
    create: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
    /**
     * In case the SecurityAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert delete
   */
  export type SecurityAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter which SecurityAlert to delete.
     */
    where: SecurityAlertWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SecurityAlert deleteMany
   */
  export type SecurityAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlerts to delete
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to delete.
     */
    limit?: number
  }

  /**
   * SecurityAlert.acknowledgedByAdmin
   */
  export type SecurityAlert$acknowledgedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * SecurityAlert without action
   */
  export type SecurityAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorMinAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    visitType: string | null
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string | null
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    visitType: string | null
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string | null
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    name: number
    organization: number
    visitType: number
    visitTypeId: number
    visitReason: number
    eventId: number
    hostMemberId: number
    checkInTime: number
    checkOutTime: number
    temporaryBadgeId: number
    kioskId: number
    createdAt: number
    adminNotes: number
    checkInMethod: number
    createdByAdmin: number
    _all: number
  }


  export type VisitorMinAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: string
    name: string
    organization: string | null
    visitType: string
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectScalar = {
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organization" | "visitType" | "visitTypeId" | "visitReason" | "eventId" | "hostMemberId" | "checkInTime" | "checkOutTime" | "temporaryBadgeId" | "kioskId" | "createdAt" | "adminNotes" | "checkInMethod" | "createdByAdmin", ExtArgs["result"]["visitor"]>
  export type VisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }
  export type VisitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }
  export type VisitorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs> | null
      hostMember: Prisma.$MemberPayload<ExtArgs> | null
      badge: Prisma.$BadgePayload<ExtArgs> | null
      visitTypeRef: Prisma.$VisitTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      organization: string | null
      visitType: string
      visitTypeId: string | null
      visitReason: string | null
      eventId: string | null
      hostMemberId: string | null
      checkInTime: Date
      checkOutTime: Date | null
      temporaryBadgeId: string | null
      kioskId: string
      createdAt: Date | null
      adminNotes: string | null
      checkInMethod: string | null
      createdByAdmin: string | null
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visitors and returns the data saved in the database.
     * @param {VisitorCreateManyAndReturnArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visitors and only return the `id`
     * const visitorWithIdOnly = await prisma.visitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors and returns the data updated in the database.
     * @param {VisitorUpdateManyAndReturnArgs} args - Arguments to update many Visitors.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visitors and only return the `id`
     * const visitorWithIdOnly = await prisma.visitor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitorUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_users<T extends Visitor$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends Visitor$eventArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$eventArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hostMember<T extends Visitor$hostMemberArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$hostMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    badge<T extends Visitor$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitTypeRef<T extends Visitor$visitTypeRefArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$visitTypeRefArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'String'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly organization: FieldRef<"Visitor", 'String'>
    readonly visitType: FieldRef<"Visitor", 'String'>
    readonly visitTypeId: FieldRef<"Visitor", 'String'>
    readonly visitReason: FieldRef<"Visitor", 'String'>
    readonly eventId: FieldRef<"Visitor", 'String'>
    readonly hostMemberId: FieldRef<"Visitor", 'String'>
    readonly checkInTime: FieldRef<"Visitor", 'DateTime'>
    readonly checkOutTime: FieldRef<"Visitor", 'DateTime'>
    readonly temporaryBadgeId: FieldRef<"Visitor", 'String'>
    readonly kioskId: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly adminNotes: FieldRef<"Visitor", 'String'>
    readonly checkInMethod: FieldRef<"Visitor", 'String'>
    readonly createdByAdmin: FieldRef<"Visitor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor createManyAndReturn
   */
  export type VisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor updateManyAndReturn
   */
  export type VisitorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor.admin_users
   */
  export type Visitor$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * Visitor.event
   */
  export type Visitor$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
  }

  /**
   * Visitor.hostMember
   */
  export type Visitor$hostMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Visitor.badge
   */
  export type Visitor$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Visitor.visitTypeRef
   */
  export type Visitor$visitTypeRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    where?: VisitTypeWhereInput
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
  }


  /**
   * Model BmqCourse
   */

  export type AggregateBmqCourse = {
    _count: BmqCourseCountAggregateOutputType | null
    _min: BmqCourseMinAggregateOutputType | null
    _max: BmqCourseMaxAggregateOutputType | null
  }

  export type BmqCourseMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    trainingStartTime: Date | null
    trainingEndTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BmqCourseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    trainingStartTime: Date | null
    trainingEndTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BmqCourseCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    trainingStartTime: number
    trainingEndTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    trainingDays: number
    _all: number
  }


  export type BmqCourseMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BmqCourseMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BmqCourseCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    trainingDays?: true
    _all?: true
  }

  export type BmqCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqCourse to aggregate.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmqCourses
    **/
    _count?: true | BmqCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmqCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmqCourseMaxAggregateInputType
  }

  export type GetBmqCourseAggregateType<T extends BmqCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateBmqCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmqCourse[P]>
      : GetScalarType<T[P], AggregateBmqCourse[P]>
  }




  export type BmqCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqCourseWhereInput
    orderBy?: BmqCourseOrderByWithAggregationInput | BmqCourseOrderByWithAggregationInput[]
    by: BmqCourseScalarFieldEnum[] | BmqCourseScalarFieldEnum
    having?: BmqCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmqCourseCountAggregateInputType | true
    _min?: BmqCourseMinAggregateInputType
    _max?: BmqCourseMaxAggregateInputType
  }

  export type BmqCourseGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    trainingStartTime: Date
    trainingEndTime: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    trainingDays: string[]
    _count: BmqCourseCountAggregateOutputType | null
    _min: BmqCourseMinAggregateOutputType | null
    _max: BmqCourseMaxAggregateOutputType | null
  }

  type GetBmqCourseGroupByPayload<T extends BmqCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmqCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmqCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmqCourseGroupByOutputType[P]>
            : GetScalarType<T[P], BmqCourseGroupByOutputType[P]>
        }
      >
    >


  export type BmqCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
    bmqEnrollments?: boolean | BmqCourse$bmqEnrollmentsArgs<ExtArgs>
    _count?: boolean | BmqCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }

  export type BmqCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "trainingStartTime" | "trainingEndTime" | "isActive" | "createdAt" | "updatedAt" | "trainingDays", ExtArgs["result"]["bmqCourse"]>
  export type BmqCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | BmqCourse$bmqEnrollmentsArgs<ExtArgs>
    _count?: boolean | BmqCourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BmqCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BmqCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BmqCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmqCourse"
    objects: {
      bmqEnrollments: Prisma.$BmqEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      trainingStartTime: Date
      trainingEndTime: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      trainingDays: string[]
    }, ExtArgs["result"]["bmqCourse"]>
    composites: {}
  }

  type BmqCourseGetPayload<S extends boolean | null | undefined | BmqCourseDefaultArgs> = $Result.GetResult<Prisma.$BmqCoursePayload, S>

  type BmqCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmqCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BmqCourseCountAggregateInputType | true
    }

  export interface BmqCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmqCourse'], meta: { name: 'BmqCourse' } }
    /**
     * Find zero or one BmqCourse that matches the filter.
     * @param {BmqCourseFindUniqueArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmqCourseFindUniqueArgs>(args: SelectSubset<T, BmqCourseFindUniqueArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BmqCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmqCourseFindUniqueOrThrowArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmqCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, BmqCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindFirstArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmqCourseFindFirstArgs>(args?: SelectSubset<T, BmqCourseFindFirstArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindFirstOrThrowArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmqCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, BmqCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BmqCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmqCourses
     * const bmqCourses = await prisma.bmqCourse.findMany()
     * 
     * // Get first 10 BmqCourses
     * const bmqCourses = await prisma.bmqCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BmqCourseFindManyArgs>(args?: SelectSubset<T, BmqCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BmqCourse.
     * @param {BmqCourseCreateArgs} args - Arguments to create a BmqCourse.
     * @example
     * // Create one BmqCourse
     * const BmqCourse = await prisma.bmqCourse.create({
     *   data: {
     *     // ... data to create a BmqCourse
     *   }
     * })
     * 
     */
    create<T extends BmqCourseCreateArgs>(args: SelectSubset<T, BmqCourseCreateArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BmqCourses.
     * @param {BmqCourseCreateManyArgs} args - Arguments to create many BmqCourses.
     * @example
     * // Create many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmqCourseCreateManyArgs>(args?: SelectSubset<T, BmqCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BmqCourses and returns the data saved in the database.
     * @param {BmqCourseCreateManyAndReturnArgs} args - Arguments to create many BmqCourses.
     * @example
     * // Create many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BmqCourses and only return the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BmqCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, BmqCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BmqCourse.
     * @param {BmqCourseDeleteArgs} args - Arguments to delete one BmqCourse.
     * @example
     * // Delete one BmqCourse
     * const BmqCourse = await prisma.bmqCourse.delete({
     *   where: {
     *     // ... filter to delete one BmqCourse
     *   }
     * })
     * 
     */
    delete<T extends BmqCourseDeleteArgs>(args: SelectSubset<T, BmqCourseDeleteArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BmqCourse.
     * @param {BmqCourseUpdateArgs} args - Arguments to update one BmqCourse.
     * @example
     * // Update one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmqCourseUpdateArgs>(args: SelectSubset<T, BmqCourseUpdateArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BmqCourses.
     * @param {BmqCourseDeleteManyArgs} args - Arguments to filter BmqCourses to delete.
     * @example
     * // Delete a few BmqCourses
     * const { count } = await prisma.bmqCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmqCourseDeleteManyArgs>(args?: SelectSubset<T, BmqCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmqCourseUpdateManyArgs>(args: SelectSubset<T, BmqCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqCourses and returns the data updated in the database.
     * @param {BmqCourseUpdateManyAndReturnArgs} args - Arguments to update many BmqCourses.
     * @example
     * // Update many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BmqCourses and only return the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BmqCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, BmqCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BmqCourse.
     * @param {BmqCourseUpsertArgs} args - Arguments to update or create a BmqCourse.
     * @example
     * // Update or create a BmqCourse
     * const bmqCourse = await prisma.bmqCourse.upsert({
     *   create: {
     *     // ... data to create a BmqCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmqCourse we want to update
     *   }
     * })
     */
    upsert<T extends BmqCourseUpsertArgs>(args: SelectSubset<T, BmqCourseUpsertArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BmqCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseCountArgs} args - Arguments to filter BmqCourses to count.
     * @example
     * // Count the number of BmqCourses
     * const count = await prisma.bmqCourse.count({
     *   where: {
     *     // ... the filter for the BmqCourses we want to count
     *   }
     * })
    **/
    count<T extends BmqCourseCountArgs>(
      args?: Subset<T, BmqCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmqCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmqCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmqCourseAggregateArgs>(args: Subset<T, BmqCourseAggregateArgs>): Prisma.PrismaPromise<GetBmqCourseAggregateType<T>>

    /**
     * Group by BmqCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmqCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmqCourseGroupByArgs['orderBy'] }
        : { orderBy?: BmqCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmqCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmqCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmqCourse model
   */
  readonly fields: BmqCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmqCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmqCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bmqEnrollments<T extends BmqCourse$bmqEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, BmqCourse$bmqEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmqCourse model
   */
  interface BmqCourseFieldRefs {
    readonly id: FieldRef<"BmqCourse", 'String'>
    readonly name: FieldRef<"BmqCourse", 'String'>
    readonly startDate: FieldRef<"BmqCourse", 'DateTime'>
    readonly endDate: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingStartTime: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingEndTime: FieldRef<"BmqCourse", 'DateTime'>
    readonly isActive: FieldRef<"BmqCourse", 'Boolean'>
    readonly createdAt: FieldRef<"BmqCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingDays: FieldRef<"BmqCourse", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * BmqCourse findUnique
   */
  export type BmqCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where: BmqCourseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse findUniqueOrThrow
   */
  export type BmqCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where: BmqCourseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse findFirst
   */
  export type BmqCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqCourses.
     */
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse findFirstOrThrow
   */
  export type BmqCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqCourses.
     */
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse findMany
   */
  export type BmqCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourses to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse create
   */
  export type BmqCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a BmqCourse.
     */
    data: XOR<BmqCourseCreateInput, BmqCourseUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse createMany
   */
  export type BmqCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmqCourses.
     */
    data: BmqCourseCreateManyInput | BmqCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqCourse createManyAndReturn
   */
  export type BmqCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * The data used to create many BmqCourses.
     */
    data: BmqCourseCreateManyInput | BmqCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqCourse update
   */
  export type BmqCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a BmqCourse.
     */
    data: XOR<BmqCourseUpdateInput, BmqCourseUncheckedUpdateInput>
    /**
     * Choose, which BmqCourse to update.
     */
    where: BmqCourseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse updateMany
   */
  export type BmqCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmqCourses.
     */
    data: XOR<BmqCourseUpdateManyMutationInput, BmqCourseUncheckedUpdateManyInput>
    /**
     * Filter which BmqCourses to update
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to update.
     */
    limit?: number
  }

  /**
   * BmqCourse updateManyAndReturn
   */
  export type BmqCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * The data used to update BmqCourses.
     */
    data: XOR<BmqCourseUpdateManyMutationInput, BmqCourseUncheckedUpdateManyInput>
    /**
     * Filter which BmqCourses to update
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to update.
     */
    limit?: number
  }

  /**
   * BmqCourse upsert
   */
  export type BmqCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the BmqCourse to update in case it exists.
     */
    where: BmqCourseWhereUniqueInput
    /**
     * In case the BmqCourse found by the `where` argument doesn't exist, create a new BmqCourse with this data.
     */
    create: XOR<BmqCourseCreateInput, BmqCourseUncheckedCreateInput>
    /**
     * In case the BmqCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmqCourseUpdateInput, BmqCourseUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse delete
   */
  export type BmqCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter which BmqCourse to delete.
     */
    where: BmqCourseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqCourse deleteMany
   */
  export type BmqCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqCourses to delete
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to delete.
     */
    limit?: number
  }

  /**
   * BmqCourse.bmqEnrollments
   */
  export type BmqCourse$bmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    cursor?: BmqEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * BmqCourse without action
   */
  export type BmqCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
  }


  /**
   * Model BmqEnrollment
   */

  export type AggregateBmqEnrollment = {
    _count: BmqEnrollmentCountAggregateOutputType | null
    _min: BmqEnrollmentMinAggregateOutputType | null
    _max: BmqEnrollmentMaxAggregateOutputType | null
  }

  export type BmqEnrollmentMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    bmqCourseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
  }

  export type BmqEnrollmentMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    bmqCourseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
  }

  export type BmqEnrollmentCountAggregateOutputType = {
    id: number
    memberId: number
    bmqCourseId: number
    enrolledAt: number
    completedAt: number
    status: number
    _all: number
  }


  export type BmqEnrollmentMinAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
  }

  export type BmqEnrollmentMaxAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
  }

  export type BmqEnrollmentCountAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
    _all?: true
  }

  export type BmqEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqEnrollment to aggregate.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmqEnrollments
    **/
    _count?: true | BmqEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmqEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmqEnrollmentMaxAggregateInputType
  }

  export type GetBmqEnrollmentAggregateType<T extends BmqEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBmqEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmqEnrollment[P]>
      : GetScalarType<T[P], AggregateBmqEnrollment[P]>
  }




  export type BmqEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithAggregationInput | BmqEnrollmentOrderByWithAggregationInput[]
    by: BmqEnrollmentScalarFieldEnum[] | BmqEnrollmentScalarFieldEnum
    having?: BmqEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmqEnrollmentCountAggregateInputType | true
    _min?: BmqEnrollmentMinAggregateInputType
    _max?: BmqEnrollmentMaxAggregateInputType
  }

  export type BmqEnrollmentGroupByOutputType = {
    id: string
    memberId: string
    bmqCourseId: string
    enrolledAt: Date
    completedAt: Date | null
    status: string
    _count: BmqEnrollmentCountAggregateOutputType | null
    _min: BmqEnrollmentMinAggregateOutputType | null
    _max: BmqEnrollmentMaxAggregateOutputType | null
  }

  type GetBmqEnrollmentGroupByPayload<T extends BmqEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmqEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmqEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmqEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], BmqEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type BmqEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectScalar = {
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
  }

  export type BmqEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "bmqCourseId" | "enrolledAt" | "completedAt" | "status", ExtArgs["result"]["bmqEnrollment"]>
  export type BmqEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BmqEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BmqEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $BmqEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmqEnrollment"
    objects: {
      bmqCourse: Prisma.$BmqCoursePayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      bmqCourseId: string
      enrolledAt: Date
      completedAt: Date | null
      status: string
    }, ExtArgs["result"]["bmqEnrollment"]>
    composites: {}
  }

  type BmqEnrollmentGetPayload<S extends boolean | null | undefined | BmqEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$BmqEnrollmentPayload, S>

  type BmqEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmqEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BmqEnrollmentCountAggregateInputType | true
    }

  export interface BmqEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmqEnrollment'], meta: { name: 'BmqEnrollment' } }
    /**
     * Find zero or one BmqEnrollment that matches the filter.
     * @param {BmqEnrollmentFindUniqueArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmqEnrollmentFindUniqueArgs>(args: SelectSubset<T, BmqEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BmqEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmqEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmqEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindFirstArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmqEnrollmentFindFirstArgs>(args?: SelectSubset<T, BmqEnrollmentFindFirstArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindFirstOrThrowArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmqEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, BmqEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BmqEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmqEnrollments
     * const bmqEnrollments = await prisma.bmqEnrollment.findMany()
     * 
     * // Get first 10 BmqEnrollments
     * const bmqEnrollments = await prisma.bmqEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BmqEnrollmentFindManyArgs>(args?: SelectSubset<T, BmqEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BmqEnrollment.
     * @param {BmqEnrollmentCreateArgs} args - Arguments to create a BmqEnrollment.
     * @example
     * // Create one BmqEnrollment
     * const BmqEnrollment = await prisma.bmqEnrollment.create({
     *   data: {
     *     // ... data to create a BmqEnrollment
     *   }
     * })
     * 
     */
    create<T extends BmqEnrollmentCreateArgs>(args: SelectSubset<T, BmqEnrollmentCreateArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BmqEnrollments.
     * @param {BmqEnrollmentCreateManyArgs} args - Arguments to create many BmqEnrollments.
     * @example
     * // Create many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmqEnrollmentCreateManyArgs>(args?: SelectSubset<T, BmqEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BmqEnrollments and returns the data saved in the database.
     * @param {BmqEnrollmentCreateManyAndReturnArgs} args - Arguments to create many BmqEnrollments.
     * @example
     * // Create many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BmqEnrollments and only return the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BmqEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, BmqEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BmqEnrollment.
     * @param {BmqEnrollmentDeleteArgs} args - Arguments to delete one BmqEnrollment.
     * @example
     * // Delete one BmqEnrollment
     * const BmqEnrollment = await prisma.bmqEnrollment.delete({
     *   where: {
     *     // ... filter to delete one BmqEnrollment
     *   }
     * })
     * 
     */
    delete<T extends BmqEnrollmentDeleteArgs>(args: SelectSubset<T, BmqEnrollmentDeleteArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BmqEnrollment.
     * @param {BmqEnrollmentUpdateArgs} args - Arguments to update one BmqEnrollment.
     * @example
     * // Update one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmqEnrollmentUpdateArgs>(args: SelectSubset<T, BmqEnrollmentUpdateArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BmqEnrollments.
     * @param {BmqEnrollmentDeleteManyArgs} args - Arguments to filter BmqEnrollments to delete.
     * @example
     * // Delete a few BmqEnrollments
     * const { count } = await prisma.bmqEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmqEnrollmentDeleteManyArgs>(args?: SelectSubset<T, BmqEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmqEnrollmentUpdateManyArgs>(args: SelectSubset<T, BmqEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqEnrollments and returns the data updated in the database.
     * @param {BmqEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many BmqEnrollments.
     * @example
     * // Update many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BmqEnrollments and only return the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BmqEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BmqEnrollment.
     * @param {BmqEnrollmentUpsertArgs} args - Arguments to update or create a BmqEnrollment.
     * @example
     * // Update or create a BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.upsert({
     *   create: {
     *     // ... data to create a BmqEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmqEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends BmqEnrollmentUpsertArgs>(args: SelectSubset<T, BmqEnrollmentUpsertArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BmqEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentCountArgs} args - Arguments to filter BmqEnrollments to count.
     * @example
     * // Count the number of BmqEnrollments
     * const count = await prisma.bmqEnrollment.count({
     *   where: {
     *     // ... the filter for the BmqEnrollments we want to count
     *   }
     * })
    **/
    count<T extends BmqEnrollmentCountArgs>(
      args?: Subset<T, BmqEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmqEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmqEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmqEnrollmentAggregateArgs>(args: Subset<T, BmqEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetBmqEnrollmentAggregateType<T>>

    /**
     * Group by BmqEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmqEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmqEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: BmqEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmqEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmqEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmqEnrollment model
   */
  readonly fields: BmqEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmqEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmqEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bmqCourse<T extends BmqCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmqCourseDefaultArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmqEnrollment model
   */
  interface BmqEnrollmentFieldRefs {
    readonly id: FieldRef<"BmqEnrollment", 'String'>
    readonly memberId: FieldRef<"BmqEnrollment", 'String'>
    readonly bmqCourseId: FieldRef<"BmqEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"BmqEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"BmqEnrollment", 'DateTime'>
    readonly status: FieldRef<"BmqEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmqEnrollment findUnique
   */
  export type BmqEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where: BmqEnrollmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment findUniqueOrThrow
   */
  export type BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where: BmqEnrollmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment findFirst
   */
  export type BmqEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqEnrollments.
     */
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment findFirstOrThrow
   */
  export type BmqEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqEnrollments.
     */
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment findMany
   */
  export type BmqEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollments to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment create
   */
  export type BmqEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a BmqEnrollment.
     */
    data: XOR<BmqEnrollmentCreateInput, BmqEnrollmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment createMany
   */
  export type BmqEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmqEnrollments.
     */
    data: BmqEnrollmentCreateManyInput | BmqEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqEnrollment createManyAndReturn
   */
  export type BmqEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many BmqEnrollments.
     */
    data: BmqEnrollmentCreateManyInput | BmqEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BmqEnrollment update
   */
  export type BmqEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a BmqEnrollment.
     */
    data: XOR<BmqEnrollmentUpdateInput, BmqEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which BmqEnrollment to update.
     */
    where: BmqEnrollmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment updateMany
   */
  export type BmqEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmqEnrollments.
     */
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which BmqEnrollments to update
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to update.
     */
    limit?: number
  }

  /**
   * BmqEnrollment updateManyAndReturn
   */
  export type BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update BmqEnrollments.
     */
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which BmqEnrollments to update
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BmqEnrollment upsert
   */
  export type BmqEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the BmqEnrollment to update in case it exists.
     */
    where: BmqEnrollmentWhereUniqueInput
    /**
     * In case the BmqEnrollment found by the `where` argument doesn't exist, create a new BmqEnrollment with this data.
     */
    create: XOR<BmqEnrollmentCreateInput, BmqEnrollmentUncheckedCreateInput>
    /**
     * In case the BmqEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmqEnrollmentUpdateInput, BmqEnrollmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment delete
   */
  export type BmqEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which BmqEnrollment to delete.
     */
    where: BmqEnrollmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BmqEnrollment deleteMany
   */
  export type BmqEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqEnrollments to delete
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to delete.
     */
    limit?: number
  }

  /**
   * BmqEnrollment without action
   */
  export type BmqEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    name: number
    applied_at: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    name: string
    applied_at: Date | null
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "applied_at", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      applied_at: Date | null
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly name: FieldRef<"migrations", 'String'>
    readonly applied_at: FieldRef<"migrations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model report_audit_log
   */

  export type AggregateReport_audit_log = {
    _count: Report_audit_logCountAggregateOutputType | null
    _avg: Report_audit_logAvgAggregateOutputType | null
    _sum: Report_audit_logSumAggregateOutputType | null
    _min: Report_audit_logMinAggregateOutputType | null
    _max: Report_audit_logMaxAggregateOutputType | null
  }

  export type Report_audit_logAvgAggregateOutputType = {
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logSumAggregateOutputType = {
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logMinAggregateOutputType = {
    id: string | null
    report_type: string | null
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logMaxAggregateOutputType = {
    id: string | null
    report_type: string | null
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logCountAggregateOutputType = {
    id: number
    report_type: number
    report_config: number
    generated_by: number
    is_scheduled: number
    scheduled_report_id: number
    generated_at: number
    file_size_bytes: number
    generation_time_ms: number
    _all: number
  }


  export type Report_audit_logAvgAggregateInputType = {
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logSumAggregateInputType = {
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logMinAggregateInputType = {
    id?: true
    report_type?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logMaxAggregateInputType = {
    id?: true
    report_type?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logCountAggregateInputType = {
    id?: true
    report_type?: true
    report_config?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
    _all?: true
  }

  export type Report_audit_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_audit_log to aggregate.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned report_audit_logs
    **/
    _count?: true | Report_audit_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Report_audit_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Report_audit_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_audit_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_audit_logMaxAggregateInputType
  }

  export type GetReport_audit_logAggregateType<T extends Report_audit_logAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_audit_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_audit_log[P]>
      : GetScalarType<T[P], AggregateReport_audit_log[P]>
  }




  export type report_audit_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_audit_logWhereInput
    orderBy?: report_audit_logOrderByWithAggregationInput | report_audit_logOrderByWithAggregationInput[]
    by: Report_audit_logScalarFieldEnum[] | Report_audit_logScalarFieldEnum
    having?: report_audit_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_audit_logCountAggregateInputType | true
    _avg?: Report_audit_logAvgAggregateInputType
    _sum?: Report_audit_logSumAggregateInputType
    _min?: Report_audit_logMinAggregateInputType
    _max?: Report_audit_logMaxAggregateInputType
  }

  export type Report_audit_logGroupByOutputType = {
    id: string
    report_type: string
    report_config: JsonValue
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
    _count: Report_audit_logCountAggregateOutputType | null
    _avg: Report_audit_logAvgAggregateOutputType | null
    _sum: Report_audit_logSumAggregateOutputType | null
    _min: Report_audit_logMinAggregateOutputType | null
    _max: Report_audit_logMaxAggregateOutputType | null
  }

  type GetReport_audit_logGroupByPayload<T extends report_audit_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Report_audit_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_audit_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_audit_logGroupByOutputType[P]>
            : GetScalarType<T[P], Report_audit_logGroupByOutputType[P]>
        }
      >
    >


  export type report_audit_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectScalar = {
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
  }

  export type report_audit_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "report_type" | "report_config" | "generated_by" | "is_scheduled" | "scheduled_report_id" | "generated_at" | "file_size_bytes" | "generation_time_ms", ExtArgs["result"]["report_audit_log"]>
  export type report_audit_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }
  export type report_audit_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }
  export type report_audit_logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }

  export type $report_audit_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report_audit_log"
    objects: {
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      report_type: string
      report_config: Prisma.JsonValue
      generated_by: string | null
      is_scheduled: boolean | null
      scheduled_report_id: string | null
      generated_at: Date | null
      file_size_bytes: number | null
      generation_time_ms: number | null
    }, ExtArgs["result"]["report_audit_log"]>
    composites: {}
  }

  type report_audit_logGetPayload<S extends boolean | null | undefined | report_audit_logDefaultArgs> = $Result.GetResult<Prisma.$report_audit_logPayload, S>

  type report_audit_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<report_audit_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: Report_audit_logCountAggregateInputType | true
    }

  export interface report_audit_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report_audit_log'], meta: { name: 'report_audit_log' } }
    /**
     * Find zero or one Report_audit_log that matches the filter.
     * @param {report_audit_logFindUniqueArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends report_audit_logFindUniqueArgs>(args: SelectSubset<T, report_audit_logFindUniqueArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report_audit_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {report_audit_logFindUniqueOrThrowArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends report_audit_logFindUniqueOrThrowArgs>(args: SelectSubset<T, report_audit_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_audit_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindFirstArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends report_audit_logFindFirstArgs>(args?: SelectSubset<T, report_audit_logFindFirstArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_audit_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindFirstOrThrowArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends report_audit_logFindFirstOrThrowArgs>(args?: SelectSubset<T, report_audit_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Report_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_audit_logs
     * const report_audit_logs = await prisma.report_audit_log.findMany()
     * 
     * // Get first 10 Report_audit_logs
     * const report_audit_logs = await prisma.report_audit_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends report_audit_logFindManyArgs>(args?: SelectSubset<T, report_audit_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report_audit_log.
     * @param {report_audit_logCreateArgs} args - Arguments to create a Report_audit_log.
     * @example
     * // Create one Report_audit_log
     * const Report_audit_log = await prisma.report_audit_log.create({
     *   data: {
     *     // ... data to create a Report_audit_log
     *   }
     * })
     * 
     */
    create<T extends report_audit_logCreateArgs>(args: SelectSubset<T, report_audit_logCreateArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Report_audit_logs.
     * @param {report_audit_logCreateManyArgs} args - Arguments to create many Report_audit_logs.
     * @example
     * // Create many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends report_audit_logCreateManyArgs>(args?: SelectSubset<T, report_audit_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Report_audit_logs and returns the data saved in the database.
     * @param {report_audit_logCreateManyAndReturnArgs} args - Arguments to create many Report_audit_logs.
     * @example
     * // Create many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Report_audit_logs and only return the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends report_audit_logCreateManyAndReturnArgs>(args?: SelectSubset<T, report_audit_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report_audit_log.
     * @param {report_audit_logDeleteArgs} args - Arguments to delete one Report_audit_log.
     * @example
     * // Delete one Report_audit_log
     * const Report_audit_log = await prisma.report_audit_log.delete({
     *   where: {
     *     // ... filter to delete one Report_audit_log
     *   }
     * })
     * 
     */
    delete<T extends report_audit_logDeleteArgs>(args: SelectSubset<T, report_audit_logDeleteArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report_audit_log.
     * @param {report_audit_logUpdateArgs} args - Arguments to update one Report_audit_log.
     * @example
     * // Update one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends report_audit_logUpdateArgs>(args: SelectSubset<T, report_audit_logUpdateArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Report_audit_logs.
     * @param {report_audit_logDeleteManyArgs} args - Arguments to filter Report_audit_logs to delete.
     * @example
     * // Delete a few Report_audit_logs
     * const { count } = await prisma.report_audit_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends report_audit_logDeleteManyArgs>(args?: SelectSubset<T, report_audit_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends report_audit_logUpdateManyArgs>(args: SelectSubset<T, report_audit_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_audit_logs and returns the data updated in the database.
     * @param {report_audit_logUpdateManyAndReturnArgs} args - Arguments to update many Report_audit_logs.
     * @example
     * // Update many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Report_audit_logs and only return the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends report_audit_logUpdateManyAndReturnArgs>(args: SelectSubset<T, report_audit_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report_audit_log.
     * @param {report_audit_logUpsertArgs} args - Arguments to update or create a Report_audit_log.
     * @example
     * // Update or create a Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.upsert({
     *   create: {
     *     // ... data to create a Report_audit_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_audit_log we want to update
     *   }
     * })
     */
    upsert<T extends report_audit_logUpsertArgs>(args: SelectSubset<T, report_audit_logUpsertArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Report_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logCountArgs} args - Arguments to filter Report_audit_logs to count.
     * @example
     * // Count the number of Report_audit_logs
     * const count = await prisma.report_audit_log.count({
     *   where: {
     *     // ... the filter for the Report_audit_logs we want to count
     *   }
     * })
    **/
    count<T extends report_audit_logCountArgs>(
      args?: Subset<T, report_audit_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_audit_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_audit_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_audit_logAggregateArgs>(args: Subset<T, Report_audit_logAggregateArgs>): Prisma.PrismaPromise<GetReport_audit_logAggregateType<T>>

    /**
     * Group by Report_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends report_audit_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: report_audit_logGroupByArgs['orderBy'] }
        : { orderBy?: report_audit_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, report_audit_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_audit_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report_audit_log model
   */
  readonly fields: report_audit_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report_audit_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__report_audit_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_users<T extends report_audit_log$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, report_audit_log$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report_audit_log model
   */
  interface report_audit_logFieldRefs {
    readonly id: FieldRef<"report_audit_log", 'String'>
    readonly report_type: FieldRef<"report_audit_log", 'String'>
    readonly report_config: FieldRef<"report_audit_log", 'Json'>
    readonly generated_by: FieldRef<"report_audit_log", 'String'>
    readonly is_scheduled: FieldRef<"report_audit_log", 'Boolean'>
    readonly scheduled_report_id: FieldRef<"report_audit_log", 'String'>
    readonly generated_at: FieldRef<"report_audit_log", 'DateTime'>
    readonly file_size_bytes: FieldRef<"report_audit_log", 'Int'>
    readonly generation_time_ms: FieldRef<"report_audit_log", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * report_audit_log findUnique
   */
  export type report_audit_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where: report_audit_logWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log findUniqueOrThrow
   */
  export type report_audit_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where: report_audit_logWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log findFirst
   */
  export type report_audit_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_audit_logs.
     */
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log findFirstOrThrow
   */
  export type report_audit_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_audit_logs.
     */
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log findMany
   */
  export type report_audit_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_logs to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log create
   */
  export type report_audit_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to create a report_audit_log.
     */
    data: XOR<report_audit_logCreateInput, report_audit_logUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log createMany
   */
  export type report_audit_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many report_audit_logs.
     */
    data: report_audit_logCreateManyInput | report_audit_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report_audit_log createManyAndReturn
   */
  export type report_audit_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * The data used to create many report_audit_logs.
     */
    data: report_audit_logCreateManyInput | report_audit_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_audit_log update
   */
  export type report_audit_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to update a report_audit_log.
     */
    data: XOR<report_audit_logUpdateInput, report_audit_logUncheckedUpdateInput>
    /**
     * Choose, which report_audit_log to update.
     */
    where: report_audit_logWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log updateMany
   */
  export type report_audit_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update report_audit_logs.
     */
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyInput>
    /**
     * Filter which report_audit_logs to update
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to update.
     */
    limit?: number
  }

  /**
   * report_audit_log updateManyAndReturn
   */
  export type report_audit_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * The data used to update report_audit_logs.
     */
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyInput>
    /**
     * Filter which report_audit_logs to update
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_audit_log upsert
   */
  export type report_audit_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The filter to search for the report_audit_log to update in case it exists.
     */
    where: report_audit_logWhereUniqueInput
    /**
     * In case the report_audit_log found by the `where` argument doesn't exist, create a new report_audit_log with this data.
     */
    create: XOR<report_audit_logCreateInput, report_audit_logUncheckedCreateInput>
    /**
     * In case the report_audit_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<report_audit_logUpdateInput, report_audit_logUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log delete
   */
  export type report_audit_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter which report_audit_log to delete.
     */
    where: report_audit_logWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * report_audit_log deleteMany
   */
  export type report_audit_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_audit_logs to delete
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to delete.
     */
    limit?: number
  }

  /**
   * report_audit_log.admin_users
   */
  export type report_audit_log$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * report_audit_log without action
   */
  export type report_audit_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
  }


  /**
   * Model ReportSetting
   */

  export type AggregateReportSetting = {
    _count: ReportSettingCountAggregateOutputType | null
    _min: ReportSettingMinAggregateOutputType | null
    _max: ReportSettingMaxAggregateOutputType | null
  }

  export type ReportSettingMinAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type ReportSettingMaxAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type ReportSettingCountAggregateOutputType = {
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type ReportSettingMinAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type ReportSettingMaxAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type ReportSettingCountAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportSetting to aggregate.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportSettings
    **/
    _count?: true | ReportSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportSettingMaxAggregateInputType
  }

  export type GetReportSettingAggregateType<T extends ReportSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateReportSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportSetting[P]>
      : GetScalarType<T[P], AggregateReportSetting[P]>
  }




  export type ReportSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportSettingWhereInput
    orderBy?: ReportSettingOrderByWithAggregationInput | ReportSettingOrderByWithAggregationInput[]
    by: ReportSettingScalarFieldEnum[] | ReportSettingScalarFieldEnum
    having?: ReportSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportSettingCountAggregateInputType | true
    _min?: ReportSettingMinAggregateInputType
    _max?: ReportSettingMaxAggregateInputType
  }

  export type ReportSettingGroupByOutputType = {
    key: string
    value: JsonValue
    updatedAt: Date
    _count: ReportSettingCountAggregateOutputType | null
    _min: ReportSettingMinAggregateOutputType | null
    _max: ReportSettingMaxAggregateOutputType | null
  }

  type GetReportSettingGroupByPayload<T extends ReportSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportSettingGroupByOutputType[P]>
            : GetScalarType<T[P], ReportSettingGroupByOutputType[P]>
        }
      >
    >


  export type ReportSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectScalar = {
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type ReportSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "updatedAt", ExtArgs["result"]["reportSetting"]>

  export type $ReportSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["reportSetting"]>
    composites: {}
  }

  type ReportSettingGetPayload<S extends boolean | null | undefined | ReportSettingDefaultArgs> = $Result.GetResult<Prisma.$ReportSettingPayload, S>

  type ReportSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ReportSettingCountAggregateInputType | true
    }

  export interface ReportSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportSetting'], meta: { name: 'ReportSetting' } }
    /**
     * Find zero or one ReportSetting that matches the filter.
     * @param {ReportSettingFindUniqueArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportSettingFindUniqueArgs>(args: SelectSubset<T, ReportSettingFindUniqueArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportSettingFindUniqueOrThrowArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindFirstArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportSettingFindFirstArgs>(args?: SelectSubset<T, ReportSettingFindFirstArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindFirstOrThrowArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportSettings
     * const reportSettings = await prisma.reportSetting.findMany()
     * 
     * // Get first 10 ReportSettings
     * const reportSettings = await prisma.reportSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends ReportSettingFindManyArgs>(args?: SelectSubset<T, ReportSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportSetting.
     * @param {ReportSettingCreateArgs} args - Arguments to create a ReportSetting.
     * @example
     * // Create one ReportSetting
     * const ReportSetting = await prisma.reportSetting.create({
     *   data: {
     *     // ... data to create a ReportSetting
     *   }
     * })
     * 
     */
    create<T extends ReportSettingCreateArgs>(args: SelectSubset<T, ReportSettingCreateArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportSettings.
     * @param {ReportSettingCreateManyArgs} args - Arguments to create many ReportSettings.
     * @example
     * // Create many ReportSettings
     * const reportSetting = await prisma.reportSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportSettingCreateManyArgs>(args?: SelectSubset<T, ReportSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportSettings and returns the data saved in the database.
     * @param {ReportSettingCreateManyAndReturnArgs} args - Arguments to create many ReportSettings.
     * @example
     * // Create many ReportSettings
     * const reportSetting = await prisma.reportSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportSettings and only return the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportSetting.
     * @param {ReportSettingDeleteArgs} args - Arguments to delete one ReportSetting.
     * @example
     * // Delete one ReportSetting
     * const ReportSetting = await prisma.reportSetting.delete({
     *   where: {
     *     // ... filter to delete one ReportSetting
     *   }
     * })
     * 
     */
    delete<T extends ReportSettingDeleteArgs>(args: SelectSubset<T, ReportSettingDeleteArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportSetting.
     * @param {ReportSettingUpdateArgs} args - Arguments to update one ReportSetting.
     * @example
     * // Update one ReportSetting
     * const reportSetting = await prisma.reportSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportSettingUpdateArgs>(args: SelectSubset<T, ReportSettingUpdateArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportSettings.
     * @param {ReportSettingDeleteManyArgs} args - Arguments to filter ReportSettings to delete.
     * @example
     * // Delete a few ReportSettings
     * const { count } = await prisma.reportSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportSettingDeleteManyArgs>(args?: SelectSubset<T, ReportSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportSettings
     * const reportSetting = await prisma.reportSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportSettingUpdateManyArgs>(args: SelectSubset<T, ReportSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportSettings and returns the data updated in the database.
     * @param {ReportSettingUpdateManyAndReturnArgs} args - Arguments to update many ReportSettings.
     * @example
     * // Update many ReportSettings
     * const reportSetting = await prisma.reportSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportSettings and only return the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportSetting.
     * @param {ReportSettingUpsertArgs} args - Arguments to update or create a ReportSetting.
     * @example
     * // Update or create a ReportSetting
     * const reportSetting = await prisma.reportSetting.upsert({
     *   create: {
     *     // ... data to create a ReportSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportSetting we want to update
     *   }
     * })
     */
    upsert<T extends ReportSettingUpsertArgs>(args: SelectSubset<T, ReportSettingUpsertArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingCountArgs} args - Arguments to filter ReportSettings to count.
     * @example
     * // Count the number of ReportSettings
     * const count = await prisma.reportSetting.count({
     *   where: {
     *     // ... the filter for the ReportSettings we want to count
     *   }
     * })
    **/
    count<T extends ReportSettingCountArgs>(
      args?: Subset<T, ReportSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportSettingAggregateArgs>(args: Subset<T, ReportSettingAggregateArgs>): Prisma.PrismaPromise<GetReportSettingAggregateType<T>>

    /**
     * Group by ReportSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportSettingGroupByArgs['orderBy'] }
        : { orderBy?: ReportSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportSetting model
   */
  readonly fields: ReportSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportSetting model
   */
  interface ReportSettingFieldRefs {
    readonly key: FieldRef<"ReportSetting", 'String'>
    readonly value: FieldRef<"ReportSetting", 'Json'>
    readonly updatedAt: FieldRef<"ReportSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportSetting findUnique
   */
  export type ReportSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where: ReportSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting findUniqueOrThrow
   */
  export type ReportSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where: ReportSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting findFirst
   */
  export type ReportSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportSettings.
     */
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting findFirstOrThrow
   */
  export type ReportSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportSettings.
     */
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting findMany
   */
  export type ReportSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSettings to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting create
   */
  export type ReportSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a ReportSetting.
     */
    data: XOR<ReportSettingCreateInput, ReportSettingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting createMany
   */
  export type ReportSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportSettings.
     */
    data: ReportSettingCreateManyInput | ReportSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportSetting createManyAndReturn
   */
  export type ReportSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data used to create many ReportSettings.
     */
    data: ReportSettingCreateManyInput | ReportSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportSetting update
   */
  export type ReportSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a ReportSetting.
     */
    data: XOR<ReportSettingUpdateInput, ReportSettingUncheckedUpdateInput>
    /**
     * Choose, which ReportSetting to update.
     */
    where: ReportSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting updateMany
   */
  export type ReportSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportSettings.
     */
    data: XOR<ReportSettingUpdateManyMutationInput, ReportSettingUncheckedUpdateManyInput>
    /**
     * Filter which ReportSettings to update
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to update.
     */
    limit?: number
  }

  /**
   * ReportSetting updateManyAndReturn
   */
  export type ReportSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data used to update ReportSettings.
     */
    data: XOR<ReportSettingUpdateManyMutationInput, ReportSettingUncheckedUpdateManyInput>
    /**
     * Filter which ReportSettings to update
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to update.
     */
    limit?: number
  }

  /**
   * ReportSetting upsert
   */
  export type ReportSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the ReportSetting to update in case it exists.
     */
    where: ReportSettingWhereUniqueInput
    /**
     * In case the ReportSetting found by the `where` argument doesn't exist, create a new ReportSetting with this data.
     */
    create: XOR<ReportSettingCreateInput, ReportSettingUncheckedCreateInput>
    /**
     * In case the ReportSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportSettingUpdateInput, ReportSettingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting delete
   */
  export type ReportSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter which ReportSetting to delete.
     */
    where: ReportSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ReportSetting deleteMany
   */
  export type ReportSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportSettings to delete
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to delete.
     */
    limit?: number
  }

  /**
   * ReportSetting without action
   */
  export type ReportSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
  }


  /**
   * Model TrainingYear
   */

  export type AggregateTrainingYear = {
    _count: TrainingYearCountAggregateOutputType | null
    _min: TrainingYearMinAggregateOutputType | null
    _max: TrainingYearMaxAggregateOutputType | null
  }

  export type TrainingYearMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingYearMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingYearCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    holidayExclusions: number
    dayExceptions: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingYearMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingYearMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingYearCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    holidayExclusions?: true
    dayExceptions?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingYear to aggregate.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingYears
    **/
    _count?: true | TrainingYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingYearMaxAggregateInputType
  }

  export type GetTrainingYearAggregateType<T extends TrainingYearAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingYear[P]>
      : GetScalarType<T[P], AggregateTrainingYear[P]>
  }




  export type TrainingYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingYearWhereInput
    orderBy?: TrainingYearOrderByWithAggregationInput | TrainingYearOrderByWithAggregationInput[]
    by: TrainingYearScalarFieldEnum[] | TrainingYearScalarFieldEnum
    having?: TrainingYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingYearCountAggregateInputType | true
    _min?: TrainingYearMinAggregateInputType
    _max?: TrainingYearMaxAggregateInputType
  }

  export type TrainingYearGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    holidayExclusions: JsonValue
    dayExceptions: JsonValue
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingYearCountAggregateOutputType | null
    _min: TrainingYearMinAggregateOutputType | null
    _max: TrainingYearMaxAggregateOutputType | null
  }

  type GetTrainingYearGroupByPayload<T extends TrainingYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingYearGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingYearGroupByOutputType[P]>
        }
      >
    >


  export type TrainingYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "holidayExclusions" | "dayExceptions" | "isCurrent" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingYear"]>

  export type $TrainingYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingYear"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      holidayExclusions: Prisma.JsonValue
      dayExceptions: Prisma.JsonValue
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingYear"]>
    composites: {}
  }

  type TrainingYearGetPayload<S extends boolean | null | undefined | TrainingYearDefaultArgs> = $Result.GetResult<Prisma.$TrainingYearPayload, S>

  type TrainingYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TrainingYearCountAggregateInputType | true
    }

  export interface TrainingYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingYear'], meta: { name: 'TrainingYear' } }
    /**
     * Find zero or one TrainingYear that matches the filter.
     * @param {TrainingYearFindUniqueArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingYearFindUniqueArgs>(args: SelectSubset<T, TrainingYearFindUniqueArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingYearFindUniqueOrThrowArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingYearFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindFirstArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingYearFindFirstArgs>(args?: SelectSubset<T, TrainingYearFindFirstArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindFirstOrThrowArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingYearFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingYears
     * const trainingYears = await prisma.trainingYear.findMany()
     * 
     * // Get first 10 TrainingYears
     * const trainingYears = await prisma.trainingYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingYearFindManyArgs>(args?: SelectSubset<T, TrainingYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingYear.
     * @param {TrainingYearCreateArgs} args - Arguments to create a TrainingYear.
     * @example
     * // Create one TrainingYear
     * const TrainingYear = await prisma.trainingYear.create({
     *   data: {
     *     // ... data to create a TrainingYear
     *   }
     * })
     * 
     */
    create<T extends TrainingYearCreateArgs>(args: SelectSubset<T, TrainingYearCreateArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingYears.
     * @param {TrainingYearCreateManyArgs} args - Arguments to create many TrainingYears.
     * @example
     * // Create many TrainingYears
     * const trainingYear = await prisma.trainingYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingYearCreateManyArgs>(args?: SelectSubset<T, TrainingYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingYears and returns the data saved in the database.
     * @param {TrainingYearCreateManyAndReturnArgs} args - Arguments to create many TrainingYears.
     * @example
     * // Create many TrainingYears
     * const trainingYear = await prisma.trainingYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingYears and only return the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingYearCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingYear.
     * @param {TrainingYearDeleteArgs} args - Arguments to delete one TrainingYear.
     * @example
     * // Delete one TrainingYear
     * const TrainingYear = await prisma.trainingYear.delete({
     *   where: {
     *     // ... filter to delete one TrainingYear
     *   }
     * })
     * 
     */
    delete<T extends TrainingYearDeleteArgs>(args: SelectSubset<T, TrainingYearDeleteArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingYear.
     * @param {TrainingYearUpdateArgs} args - Arguments to update one TrainingYear.
     * @example
     * // Update one TrainingYear
     * const trainingYear = await prisma.trainingYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingYearUpdateArgs>(args: SelectSubset<T, TrainingYearUpdateArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingYears.
     * @param {TrainingYearDeleteManyArgs} args - Arguments to filter TrainingYears to delete.
     * @example
     * // Delete a few TrainingYears
     * const { count } = await prisma.trainingYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingYearDeleteManyArgs>(args?: SelectSubset<T, TrainingYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingYears
     * const trainingYear = await prisma.trainingYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingYearUpdateManyArgs>(args: SelectSubset<T, TrainingYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingYears and returns the data updated in the database.
     * @param {TrainingYearUpdateManyAndReturnArgs} args - Arguments to update many TrainingYears.
     * @example
     * // Update many TrainingYears
     * const trainingYear = await prisma.trainingYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingYears and only return the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingYearUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingYear.
     * @param {TrainingYearUpsertArgs} args - Arguments to update or create a TrainingYear.
     * @example
     * // Update or create a TrainingYear
     * const trainingYear = await prisma.trainingYear.upsert({
     *   create: {
     *     // ... data to create a TrainingYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingYear we want to update
     *   }
     * })
     */
    upsert<T extends TrainingYearUpsertArgs>(args: SelectSubset<T, TrainingYearUpsertArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearCountArgs} args - Arguments to filter TrainingYears to count.
     * @example
     * // Count the number of TrainingYears
     * const count = await prisma.trainingYear.count({
     *   where: {
     *     // ... the filter for the TrainingYears we want to count
     *   }
     * })
    **/
    count<T extends TrainingYearCountArgs>(
      args?: Subset<T, TrainingYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingYearAggregateArgs>(args: Subset<T, TrainingYearAggregateArgs>): Prisma.PrismaPromise<GetTrainingYearAggregateType<T>>

    /**
     * Group by TrainingYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingYearGroupByArgs['orderBy'] }
        : { orderBy?: TrainingYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingYear model
   */
  readonly fields: TrainingYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingYear model
   */
  interface TrainingYearFieldRefs {
    readonly id: FieldRef<"TrainingYear", 'String'>
    readonly name: FieldRef<"TrainingYear", 'String'>
    readonly startDate: FieldRef<"TrainingYear", 'DateTime'>
    readonly endDate: FieldRef<"TrainingYear", 'DateTime'>
    readonly holidayExclusions: FieldRef<"TrainingYear", 'Json'>
    readonly dayExceptions: FieldRef<"TrainingYear", 'Json'>
    readonly isCurrent: FieldRef<"TrainingYear", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingYear", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingYear findUnique
   */
  export type TrainingYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where: TrainingYearWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear findUniqueOrThrow
   */
  export type TrainingYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where: TrainingYearWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear findFirst
   */
  export type TrainingYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingYears.
     */
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear findFirstOrThrow
   */
  export type TrainingYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingYears.
     */
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear findMany
   */
  export type TrainingYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYears to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear create
   */
  export type TrainingYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data needed to create a TrainingYear.
     */
    data: XOR<TrainingYearCreateInput, TrainingYearUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear createMany
   */
  export type TrainingYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingYears.
     */
    data: TrainingYearCreateManyInput | TrainingYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingYear createManyAndReturn
   */
  export type TrainingYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingYears.
     */
    data: TrainingYearCreateManyInput | TrainingYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingYear update
   */
  export type TrainingYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data needed to update a TrainingYear.
     */
    data: XOR<TrainingYearUpdateInput, TrainingYearUncheckedUpdateInput>
    /**
     * Choose, which TrainingYear to update.
     */
    where: TrainingYearWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear updateMany
   */
  export type TrainingYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingYears.
     */
    data: XOR<TrainingYearUpdateManyMutationInput, TrainingYearUncheckedUpdateManyInput>
    /**
     * Filter which TrainingYears to update
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to update.
     */
    limit?: number
  }

  /**
   * TrainingYear updateManyAndReturn
   */
  export type TrainingYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data used to update TrainingYears.
     */
    data: XOR<TrainingYearUpdateManyMutationInput, TrainingYearUncheckedUpdateManyInput>
    /**
     * Filter which TrainingYears to update
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to update.
     */
    limit?: number
  }

  /**
   * TrainingYear upsert
   */
  export type TrainingYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The filter to search for the TrainingYear to update in case it exists.
     */
    where: TrainingYearWhereUniqueInput
    /**
     * In case the TrainingYear found by the `where` argument doesn't exist, create a new TrainingYear with this data.
     */
    create: XOR<TrainingYearCreateInput, TrainingYearUncheckedCreateInput>
    /**
     * In case the TrainingYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingYearUpdateInput, TrainingYearUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear delete
   */
  export type TrainingYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter which TrainingYear to delete.
     */
    where: TrainingYearWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TrainingYear deleteMany
   */
  export type TrainingYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingYears to delete
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to delete.
     */
    limit?: number
  }

  /**
   * TrainingYear without action
   */
  export type TrainingYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
  }


  /**
   * Model DdsAssignment
   */

  export type AggregateDdsAssignment = {
    _count: DdsAssignmentCountAggregateOutputType | null
    _min: DdsAssignmentMinAggregateOutputType | null
    _max: DdsAssignmentMaxAggregateOutputType | null
  }

  export type DdsAssignmentMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    assignedDate: Date | null
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DdsAssignmentMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    assignedDate: Date | null
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DdsAssignmentCountAggregateOutputType = {
    id: number
    memberId: number
    assignedDate: number
    acceptedAt: number
    releasedAt: number
    transferredTo: number
    assignedBy: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DdsAssignmentMinAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DdsAssignmentMaxAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DdsAssignmentCountAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DdsAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DdsAssignment to aggregate.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DdsAssignments
    **/
    _count?: true | DdsAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DdsAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DdsAssignmentMaxAggregateInputType
  }

  export type GetDdsAssignmentAggregateType<T extends DdsAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDdsAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDdsAssignment[P]>
      : GetScalarType<T[P], AggregateDdsAssignment[P]>
  }




  export type DdsAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithAggregationInput | DdsAssignmentOrderByWithAggregationInput[]
    by: DdsAssignmentScalarFieldEnum[] | DdsAssignmentScalarFieldEnum
    having?: DdsAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DdsAssignmentCountAggregateInputType | true
    _min?: DdsAssignmentMinAggregateInputType
    _max?: DdsAssignmentMaxAggregateInputType
  }

  export type DdsAssignmentGroupByOutputType = {
    id: string
    memberId: string
    assignedDate: Date
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DdsAssignmentCountAggregateOutputType | null
    _min: DdsAssignmentMinAggregateOutputType | null
    _max: DdsAssignmentMaxAggregateOutputType | null
  }

  type GetDdsAssignmentGroupByPayload<T extends DdsAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DdsAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DdsAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DdsAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DdsAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DdsAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectScalar = {
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DdsAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "assignedDate" | "acceptedAt" | "releasedAt" | "transferredTo" | "assignedBy" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["ddsAssignment"]>
  export type DdsAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }
  export type DdsAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }
  export type DdsAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }

  export type $DdsAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DdsAssignment"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      transferredToMember: Prisma.$MemberPayload<ExtArgs> | null
      assignedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      assignedDate: Date
      acceptedAt: Date | null
      releasedAt: Date | null
      transferredTo: string | null
      assignedBy: string | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ddsAssignment"]>
    composites: {}
  }

  type DdsAssignmentGetPayload<S extends boolean | null | undefined | DdsAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DdsAssignmentPayload, S>

  type DdsAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DdsAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DdsAssignmentCountAggregateInputType | true
    }

  export interface DdsAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DdsAssignment'], meta: { name: 'DdsAssignment' } }
    /**
     * Find zero or one DdsAssignment that matches the filter.
     * @param {DdsAssignmentFindUniqueArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DdsAssignmentFindUniqueArgs>(args: SelectSubset<T, DdsAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DdsAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DdsAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DdsAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DdsAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DdsAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindFirstArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DdsAssignmentFindFirstArgs>(args?: SelectSubset<T, DdsAssignmentFindFirstArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DdsAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindFirstOrThrowArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DdsAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DdsAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DdsAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DdsAssignments
     * const ddsAssignments = await prisma.ddsAssignment.findMany()
     * 
     * // Get first 10 DdsAssignments
     * const ddsAssignments = await prisma.ddsAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DdsAssignmentFindManyArgs>(args?: SelectSubset<T, DdsAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DdsAssignment.
     * @param {DdsAssignmentCreateArgs} args - Arguments to create a DdsAssignment.
     * @example
     * // Create one DdsAssignment
     * const DdsAssignment = await prisma.ddsAssignment.create({
     *   data: {
     *     // ... data to create a DdsAssignment
     *   }
     * })
     * 
     */
    create<T extends DdsAssignmentCreateArgs>(args: SelectSubset<T, DdsAssignmentCreateArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DdsAssignments.
     * @param {DdsAssignmentCreateManyArgs} args - Arguments to create many DdsAssignments.
     * @example
     * // Create many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DdsAssignmentCreateManyArgs>(args?: SelectSubset<T, DdsAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DdsAssignments and returns the data saved in the database.
     * @param {DdsAssignmentCreateManyAndReturnArgs} args - Arguments to create many DdsAssignments.
     * @example
     * // Create many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DdsAssignments and only return the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DdsAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DdsAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DdsAssignment.
     * @param {DdsAssignmentDeleteArgs} args - Arguments to delete one DdsAssignment.
     * @example
     * // Delete one DdsAssignment
     * const DdsAssignment = await prisma.ddsAssignment.delete({
     *   where: {
     *     // ... filter to delete one DdsAssignment
     *   }
     * })
     * 
     */
    delete<T extends DdsAssignmentDeleteArgs>(args: SelectSubset<T, DdsAssignmentDeleteArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DdsAssignment.
     * @param {DdsAssignmentUpdateArgs} args - Arguments to update one DdsAssignment.
     * @example
     * // Update one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DdsAssignmentUpdateArgs>(args: SelectSubset<T, DdsAssignmentUpdateArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DdsAssignments.
     * @param {DdsAssignmentDeleteManyArgs} args - Arguments to filter DdsAssignments to delete.
     * @example
     * // Delete a few DdsAssignments
     * const { count } = await prisma.ddsAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DdsAssignmentDeleteManyArgs>(args?: SelectSubset<T, DdsAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DdsAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DdsAssignmentUpdateManyArgs>(args: SelectSubset<T, DdsAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DdsAssignments and returns the data updated in the database.
     * @param {DdsAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DdsAssignments.
     * @example
     * // Update many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DdsAssignments and only return the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DdsAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DdsAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DdsAssignment.
     * @param {DdsAssignmentUpsertArgs} args - Arguments to update or create a DdsAssignment.
     * @example
     * // Update or create a DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.upsert({
     *   create: {
     *     // ... data to create a DdsAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DdsAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DdsAssignmentUpsertArgs>(args: SelectSubset<T, DdsAssignmentUpsertArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DdsAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentCountArgs} args - Arguments to filter DdsAssignments to count.
     * @example
     * // Count the number of DdsAssignments
     * const count = await prisma.ddsAssignment.count({
     *   where: {
     *     // ... the filter for the DdsAssignments we want to count
     *   }
     * })
    **/
    count<T extends DdsAssignmentCountArgs>(
      args?: Subset<T, DdsAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DdsAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DdsAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DdsAssignmentAggregateArgs>(args: Subset<T, DdsAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDdsAssignmentAggregateType<T>>

    /**
     * Group by DdsAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DdsAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DdsAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DdsAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DdsAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDdsAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DdsAssignment model
   */
  readonly fields: DdsAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DdsAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DdsAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transferredToMember<T extends DdsAssignment$transferredToMemberArgs<ExtArgs> = {}>(args?: Subset<T, DdsAssignment$transferredToMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedByAdmin<T extends DdsAssignment$assignedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, DdsAssignment$assignedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DdsAssignment model
   */
  interface DdsAssignmentFieldRefs {
    readonly id: FieldRef<"DdsAssignment", 'String'>
    readonly memberId: FieldRef<"DdsAssignment", 'String'>
    readonly assignedDate: FieldRef<"DdsAssignment", 'DateTime'>
    readonly acceptedAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly releasedAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly transferredTo: FieldRef<"DdsAssignment", 'String'>
    readonly assignedBy: FieldRef<"DdsAssignment", 'String'>
    readonly status: FieldRef<"DdsAssignment", 'String'>
    readonly notes: FieldRef<"DdsAssignment", 'String'>
    readonly createdAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"DdsAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DdsAssignment findUnique
   */
  export type DdsAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where: DdsAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment findUniqueOrThrow
   */
  export type DdsAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where: DdsAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment findFirst
   */
  export type DdsAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DdsAssignments.
     */
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment findFirstOrThrow
   */
  export type DdsAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DdsAssignments.
     */
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment findMany
   */
  export type DdsAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignments to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment create
   */
  export type DdsAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DdsAssignment.
     */
    data: XOR<DdsAssignmentCreateInput, DdsAssignmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment createMany
   */
  export type DdsAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DdsAssignments.
     */
    data: DdsAssignmentCreateManyInput | DdsAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DdsAssignment createManyAndReturn
   */
  export type DdsAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DdsAssignments.
     */
    data: DdsAssignmentCreateManyInput | DdsAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DdsAssignment update
   */
  export type DdsAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DdsAssignment.
     */
    data: XOR<DdsAssignmentUpdateInput, DdsAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DdsAssignment to update.
     */
    where: DdsAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment updateMany
   */
  export type DdsAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DdsAssignments.
     */
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DdsAssignments to update
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to update.
     */
    limit?: number
  }

  /**
   * DdsAssignment updateManyAndReturn
   */
  export type DdsAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DdsAssignments.
     */
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DdsAssignments to update
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DdsAssignment upsert
   */
  export type DdsAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DdsAssignment to update in case it exists.
     */
    where: DdsAssignmentWhereUniqueInput
    /**
     * In case the DdsAssignment found by the `where` argument doesn't exist, create a new DdsAssignment with this data.
     */
    create: XOR<DdsAssignmentCreateInput, DdsAssignmentUncheckedCreateInput>
    /**
     * In case the DdsAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DdsAssignmentUpdateInput, DdsAssignmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment delete
   */
  export type DdsAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DdsAssignment to delete.
     */
    where: DdsAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DdsAssignment deleteMany
   */
  export type DdsAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DdsAssignments to delete
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to delete.
     */
    limit?: number
  }

  /**
   * DdsAssignment.transferredToMember
   */
  export type DdsAssignment$transferredToMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * DdsAssignment.assignedByAdmin
   */
  export type DdsAssignment$assignedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * DdsAssignment without action
   */
  export type DdsAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ResponsibilityAuditLog
   */

  export type AggregateResponsibilityAuditLog = {
    _count: ResponsibilityAuditLogCountAggregateOutputType | null
    _min: ResponsibilityAuditLogMinAggregateOutputType | null
    _max: ResponsibilityAuditLogMaxAggregateOutputType | null
  }

  export type ResponsibilityAuditLogMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagName: string | null
    action: string | null
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string | null
    timestamp: Date | null
    notes: string | null
  }

  export type ResponsibilityAuditLogMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagName: string | null
    action: string | null
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string | null
    timestamp: Date | null
    notes: string | null
  }

  export type ResponsibilityAuditLogCountAggregateOutputType = {
    id: number
    memberId: number
    tagName: number
    action: number
    fromMemberId: number
    toMemberId: number
    performedBy: number
    performedByType: number
    timestamp: number
    notes: number
    _all: number
  }


  export type ResponsibilityAuditLogMinAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
  }

  export type ResponsibilityAuditLogMaxAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
  }

  export type ResponsibilityAuditLogCountAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
    _all?: true
  }

  export type ResponsibilityAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsibilityAuditLog to aggregate.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponsibilityAuditLogs
    **/
    _count?: true | ResponsibilityAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsibilityAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsibilityAuditLogMaxAggregateInputType
  }

  export type GetResponsibilityAuditLogAggregateType<T extends ResponsibilityAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsibilityAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsibilityAuditLog[P]>
      : GetScalarType<T[P], AggregateResponsibilityAuditLog[P]>
  }




  export type ResponsibilityAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsibilityAuditLogWhereInput
    orderBy?: ResponsibilityAuditLogOrderByWithAggregationInput | ResponsibilityAuditLogOrderByWithAggregationInput[]
    by: ResponsibilityAuditLogScalarFieldEnum[] | ResponsibilityAuditLogScalarFieldEnum
    having?: ResponsibilityAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsibilityAuditLogCountAggregateInputType | true
    _min?: ResponsibilityAuditLogMinAggregateInputType
    _max?: ResponsibilityAuditLogMaxAggregateInputType
  }

  export type ResponsibilityAuditLogGroupByOutputType = {
    id: string
    memberId: string
    tagName: string
    action: string
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string
    timestamp: Date
    notes: string | null
    _count: ResponsibilityAuditLogCountAggregateOutputType | null
    _min: ResponsibilityAuditLogMinAggregateOutputType | null
    _max: ResponsibilityAuditLogMaxAggregateOutputType | null
  }

  type GetResponsibilityAuditLogGroupByPayload<T extends ResponsibilityAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponsibilityAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsibilityAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsibilityAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsibilityAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type ResponsibilityAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectScalar = {
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }

  export type ResponsibilityAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "tagName" | "action" | "fromMemberId" | "toMemberId" | "performedBy" | "performedByType" | "timestamp" | "notes", ExtArgs["result"]["responsibilityAuditLog"]>

  export type $ResponsibilityAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponsibilityAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      tagName: string
      action: string
      fromMemberId: string | null
      toMemberId: string | null
      performedBy: string | null
      performedByType: string
      timestamp: Date
      notes: string | null
    }, ExtArgs["result"]["responsibilityAuditLog"]>
    composites: {}
  }

  type ResponsibilityAuditLogGetPayload<S extends boolean | null | undefined | ResponsibilityAuditLogDefaultArgs> = $Result.GetResult<Prisma.$ResponsibilityAuditLogPayload, S>

  type ResponsibilityAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponsibilityAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ResponsibilityAuditLogCountAggregateInputType | true
    }

  export interface ResponsibilityAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponsibilityAuditLog'], meta: { name: 'ResponsibilityAuditLog' } }
    /**
     * Find zero or one ResponsibilityAuditLog that matches the filter.
     * @param {ResponsibilityAuditLogFindUniqueArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponsibilityAuditLogFindUniqueArgs>(args: SelectSubset<T, ResponsibilityAuditLogFindUniqueArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResponsibilityAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponsibilityAuditLogFindUniqueOrThrowArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponsibilityAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsibilityAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindFirstArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponsibilityAuditLogFindFirstArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindFirstArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsibilityAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindFirstOrThrowArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponsibilityAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResponsibilityAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponsibilityAuditLogs
     * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany()
     * 
     * // Get first 10 ResponsibilityAuditLogs
     * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponsibilityAuditLogFindManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogCreateArgs} args - Arguments to create a ResponsibilityAuditLog.
     * @example
     * // Create one ResponsibilityAuditLog
     * const ResponsibilityAuditLog = await prisma.responsibilityAuditLog.create({
     *   data: {
     *     // ... data to create a ResponsibilityAuditLog
     *   }
     * })
     * 
     */
    create<T extends ResponsibilityAuditLogCreateArgs>(args: SelectSubset<T, ResponsibilityAuditLogCreateArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResponsibilityAuditLogs.
     * @param {ResponsibilityAuditLogCreateManyArgs} args - Arguments to create many ResponsibilityAuditLogs.
     * @example
     * // Create many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponsibilityAuditLogCreateManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponsibilityAuditLogs and returns the data saved in the database.
     * @param {ResponsibilityAuditLogCreateManyAndReturnArgs} args - Arguments to create many ResponsibilityAuditLogs.
     * @example
     * // Create many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponsibilityAuditLogs and only return the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponsibilityAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogDeleteArgs} args - Arguments to delete one ResponsibilityAuditLog.
     * @example
     * // Delete one ResponsibilityAuditLog
     * const ResponsibilityAuditLog = await prisma.responsibilityAuditLog.delete({
     *   where: {
     *     // ... filter to delete one ResponsibilityAuditLog
     *   }
     * })
     * 
     */
    delete<T extends ResponsibilityAuditLogDeleteArgs>(args: SelectSubset<T, ResponsibilityAuditLogDeleteArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogUpdateArgs} args - Arguments to update one ResponsibilityAuditLog.
     * @example
     * // Update one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponsibilityAuditLogUpdateArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResponsibilityAuditLogs.
     * @param {ResponsibilityAuditLogDeleteManyArgs} args - Arguments to filter ResponsibilityAuditLogs to delete.
     * @example
     * // Delete a few ResponsibilityAuditLogs
     * const { count } = await prisma.responsibilityAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponsibilityAuditLogDeleteManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsibilityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponsibilityAuditLogUpdateManyArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsibilityAuditLogs and returns the data updated in the database.
     * @param {ResponsibilityAuditLogUpdateManyAndReturnArgs} args - Arguments to update many ResponsibilityAuditLogs.
     * @example
     * // Update many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResponsibilityAuditLogs and only return the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResponsibilityAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogUpsertArgs} args - Arguments to update or create a ResponsibilityAuditLog.
     * @example
     * // Update or create a ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.upsert({
     *   create: {
     *     // ... data to create a ResponsibilityAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponsibilityAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends ResponsibilityAuditLogUpsertArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpsertArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResponsibilityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogCountArgs} args - Arguments to filter ResponsibilityAuditLogs to count.
     * @example
     * // Count the number of ResponsibilityAuditLogs
     * const count = await prisma.responsibilityAuditLog.count({
     *   where: {
     *     // ... the filter for the ResponsibilityAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends ResponsibilityAuditLogCountArgs>(
      args?: Subset<T, ResponsibilityAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsibilityAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponsibilityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsibilityAuditLogAggregateArgs>(args: Subset<T, ResponsibilityAuditLogAggregateArgs>): Prisma.PrismaPromise<GetResponsibilityAuditLogAggregateType<T>>

    /**
     * Group by ResponsibilityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponsibilityAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponsibilityAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: ResponsibilityAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponsibilityAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsibilityAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponsibilityAuditLog model
   */
  readonly fields: ResponsibilityAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponsibilityAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponsibilityAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponsibilityAuditLog model
   */
  interface ResponsibilityAuditLogFieldRefs {
    readonly id: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly memberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly tagName: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly action: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly fromMemberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly toMemberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly performedBy: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly performedByType: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly timestamp: FieldRef<"ResponsibilityAuditLog", 'DateTime'>
    readonly notes: FieldRef<"ResponsibilityAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResponsibilityAuditLog findUnique
   */
  export type ResponsibilityAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog findUniqueOrThrow
   */
  export type ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog findFirst
   */
  export type ResponsibilityAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsibilityAuditLogs.
     */
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog findFirstOrThrow
   */
  export type ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsibilityAuditLogs.
     */
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog findMany
   */
  export type ResponsibilityAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLogs to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog create
   */
  export type ResponsibilityAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ResponsibilityAuditLog.
     */
    data: XOR<ResponsibilityAuditLogCreateInput, ResponsibilityAuditLogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog createMany
   */
  export type ResponsibilityAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponsibilityAuditLogs.
     */
    data: ResponsibilityAuditLogCreateManyInput | ResponsibilityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsibilityAuditLog createManyAndReturn
   */
  export type ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many ResponsibilityAuditLogs.
     */
    data: ResponsibilityAuditLogCreateManyInput | ResponsibilityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsibilityAuditLog update
   */
  export type ResponsibilityAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ResponsibilityAuditLog.
     */
    data: XOR<ResponsibilityAuditLogUpdateInput, ResponsibilityAuditLogUncheckedUpdateInput>
    /**
     * Choose, which ResponsibilityAuditLog to update.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog updateMany
   */
  export type ResponsibilityAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponsibilityAuditLogs.
     */
    data: XOR<ResponsibilityAuditLogUpdateManyMutationInput, ResponsibilityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ResponsibilityAuditLogs to update
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog updateManyAndReturn
   */
  export type ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update ResponsibilityAuditLogs.
     */
    data: XOR<ResponsibilityAuditLogUpdateManyMutationInput, ResponsibilityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ResponsibilityAuditLogs to update
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog upsert
   */
  export type ResponsibilityAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ResponsibilityAuditLog to update in case it exists.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    /**
     * In case the ResponsibilityAuditLog found by the `where` argument doesn't exist, create a new ResponsibilityAuditLog with this data.
     */
    create: XOR<ResponsibilityAuditLogCreateInput, ResponsibilityAuditLogUncheckedCreateInput>
    /**
     * In case the ResponsibilityAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponsibilityAuditLogUpdateInput, ResponsibilityAuditLogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog delete
   */
  export type ResponsibilityAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter which ResponsibilityAuditLog to delete.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ResponsibilityAuditLog deleteMany
   */
  export type ResponsibilityAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsibilityAuditLogs to delete
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog without action
   */
  export type ResponsibilityAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model MemberStatus
   */

  export type AggregateMemberStatus = {
    _count: MemberStatusCountAggregateOutputType | null
    _min: MemberStatusMinAggregateOutputType | null
    _max: MemberStatusMaxAggregateOutputType | null
  }

  export type MemberStatusMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberStatusMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberStatusCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    chipVariant: number
    chipColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberStatusMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberStatusMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberStatusCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberStatus to aggregate.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberStatuses
    **/
    _count?: true | MemberStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberStatusMaxAggregateInputType
  }

  export type GetMemberStatusAggregateType<T extends MemberStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberStatus[P]>
      : GetScalarType<T[P], AggregateMemberStatus[P]>
  }




  export type MemberStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberStatusWhereInput
    orderBy?: MemberStatusOrderByWithAggregationInput | MemberStatusOrderByWithAggregationInput[]
    by: MemberStatusScalarFieldEnum[] | MemberStatusScalarFieldEnum
    having?: MemberStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberStatusCountAggregateInputType | true
    _min?: MemberStatusMinAggregateInputType
    _max?: MemberStatusMaxAggregateInputType
  }

  export type MemberStatusGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    chipVariant: string
    chipColor: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberStatusCountAggregateOutputType | null
    _min: MemberStatusMinAggregateOutputType | null
    _max: MemberStatusMaxAggregateOutputType | null
  }

  type GetMemberStatusGroupByPayload<T extends MemberStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MemberStatusGroupByOutputType[P]>
        }
      >
    >


  export type MemberStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | MemberStatus$membersArgs<ExtArgs>
    _count?: boolean | MemberStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "chipVariant" | "chipColor" | "createdAt" | "updatedAt", ExtArgs["result"]["memberStatus"]>
  export type MemberStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberStatus$membersArgs<ExtArgs>
    _count?: boolean | MemberStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberStatus"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      chipVariant: string
      chipColor: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberStatus"]>
    composites: {}
  }

  type MemberStatusGetPayload<S extends boolean | null | undefined | MemberStatusDefaultArgs> = $Result.GetResult<Prisma.$MemberStatusPayload, S>

  type MemberStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MemberStatusCountAggregateInputType | true
    }

  export interface MemberStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberStatus'], meta: { name: 'MemberStatus' } }
    /**
     * Find zero or one MemberStatus that matches the filter.
     * @param {MemberStatusFindUniqueArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberStatusFindUniqueArgs>(args: SelectSubset<T, MemberStatusFindUniqueArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberStatusFindUniqueOrThrowArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindFirstArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberStatusFindFirstArgs>(args?: SelectSubset<T, MemberStatusFindFirstArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindFirstOrThrowArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberStatuses
     * const memberStatuses = await prisma.memberStatus.findMany()
     * 
     * // Get first 10 MemberStatuses
     * const memberStatuses = await prisma.memberStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberStatusFindManyArgs>(args?: SelectSubset<T, MemberStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberStatus.
     * @param {MemberStatusCreateArgs} args - Arguments to create a MemberStatus.
     * @example
     * // Create one MemberStatus
     * const MemberStatus = await prisma.memberStatus.create({
     *   data: {
     *     // ... data to create a MemberStatus
     *   }
     * })
     * 
     */
    create<T extends MemberStatusCreateArgs>(args: SelectSubset<T, MemberStatusCreateArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberStatuses.
     * @param {MemberStatusCreateManyArgs} args - Arguments to create many MemberStatuses.
     * @example
     * // Create many MemberStatuses
     * const memberStatus = await prisma.memberStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberStatusCreateManyArgs>(args?: SelectSubset<T, MemberStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberStatuses and returns the data saved in the database.
     * @param {MemberStatusCreateManyAndReturnArgs} args - Arguments to create many MemberStatuses.
     * @example
     * // Create many MemberStatuses
     * const memberStatus = await prisma.memberStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberStatuses and only return the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberStatus.
     * @param {MemberStatusDeleteArgs} args - Arguments to delete one MemberStatus.
     * @example
     * // Delete one MemberStatus
     * const MemberStatus = await prisma.memberStatus.delete({
     *   where: {
     *     // ... filter to delete one MemberStatus
     *   }
     * })
     * 
     */
    delete<T extends MemberStatusDeleteArgs>(args: SelectSubset<T, MemberStatusDeleteArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberStatus.
     * @param {MemberStatusUpdateArgs} args - Arguments to update one MemberStatus.
     * @example
     * // Update one MemberStatus
     * const memberStatus = await prisma.memberStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberStatusUpdateArgs>(args: SelectSubset<T, MemberStatusUpdateArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberStatuses.
     * @param {MemberStatusDeleteManyArgs} args - Arguments to filter MemberStatuses to delete.
     * @example
     * // Delete a few MemberStatuses
     * const { count } = await prisma.memberStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberStatusDeleteManyArgs>(args?: SelectSubset<T, MemberStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberStatuses
     * const memberStatus = await prisma.memberStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberStatusUpdateManyArgs>(args: SelectSubset<T, MemberStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberStatuses and returns the data updated in the database.
     * @param {MemberStatusUpdateManyAndReturnArgs} args - Arguments to update many MemberStatuses.
     * @example
     * // Update many MemberStatuses
     * const memberStatus = await prisma.memberStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberStatuses and only return the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberStatus.
     * @param {MemberStatusUpsertArgs} args - Arguments to update or create a MemberStatus.
     * @example
     * // Update or create a MemberStatus
     * const memberStatus = await prisma.memberStatus.upsert({
     *   create: {
     *     // ... data to create a MemberStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberStatus we want to update
     *   }
     * })
     */
    upsert<T extends MemberStatusUpsertArgs>(args: SelectSubset<T, MemberStatusUpsertArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusCountArgs} args - Arguments to filter MemberStatuses to count.
     * @example
     * // Count the number of MemberStatuses
     * const count = await prisma.memberStatus.count({
     *   where: {
     *     // ... the filter for the MemberStatuses we want to count
     *   }
     * })
    **/
    count<T extends MemberStatusCountArgs>(
      args?: Subset<T, MemberStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberStatusAggregateArgs>(args: Subset<T, MemberStatusAggregateArgs>): Prisma.PrismaPromise<GetMemberStatusAggregateType<T>>

    /**
     * Group by MemberStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberStatusGroupByArgs['orderBy'] }
        : { orderBy?: MemberStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberStatus model
   */
  readonly fields: MemberStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MemberStatus$membersArgs<ExtArgs> = {}>(args?: Subset<T, MemberStatus$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberStatus model
   */
  interface MemberStatusFieldRefs {
    readonly id: FieldRef<"MemberStatus", 'String'>
    readonly code: FieldRef<"MemberStatus", 'String'>
    readonly name: FieldRef<"MemberStatus", 'String'>
    readonly description: FieldRef<"MemberStatus", 'String'>
    readonly chipVariant: FieldRef<"MemberStatus", 'String'>
    readonly chipColor: FieldRef<"MemberStatus", 'String'>
    readonly createdAt: FieldRef<"MemberStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberStatus findUnique
   */
  export type MemberStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where: MemberStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus findUniqueOrThrow
   */
  export type MemberStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where: MemberStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus findFirst
   */
  export type MemberStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberStatuses.
     */
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus findFirstOrThrow
   */
  export type MemberStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberStatuses.
     */
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus findMany
   */
  export type MemberStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatuses to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus create
   */
  export type MemberStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberStatus.
     */
    data: XOR<MemberStatusCreateInput, MemberStatusUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus createMany
   */
  export type MemberStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberStatuses.
     */
    data: MemberStatusCreateManyInput | MemberStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberStatus createManyAndReturn
   */
  export type MemberStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * The data used to create many MemberStatuses.
     */
    data: MemberStatusCreateManyInput | MemberStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberStatus update
   */
  export type MemberStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberStatus.
     */
    data: XOR<MemberStatusUpdateInput, MemberStatusUncheckedUpdateInput>
    /**
     * Choose, which MemberStatus to update.
     */
    where: MemberStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus updateMany
   */
  export type MemberStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberStatuses.
     */
    data: XOR<MemberStatusUpdateManyMutationInput, MemberStatusUncheckedUpdateManyInput>
    /**
     * Filter which MemberStatuses to update
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to update.
     */
    limit?: number
  }

  /**
   * MemberStatus updateManyAndReturn
   */
  export type MemberStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * The data used to update MemberStatuses.
     */
    data: XOR<MemberStatusUpdateManyMutationInput, MemberStatusUncheckedUpdateManyInput>
    /**
     * Filter which MemberStatuses to update
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to update.
     */
    limit?: number
  }

  /**
   * MemberStatus upsert
   */
  export type MemberStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberStatus to update in case it exists.
     */
    where: MemberStatusWhereUniqueInput
    /**
     * In case the MemberStatus found by the `where` argument doesn't exist, create a new MemberStatus with this data.
     */
    create: XOR<MemberStatusCreateInput, MemberStatusUncheckedCreateInput>
    /**
     * In case the MemberStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberStatusUpdateInput, MemberStatusUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus delete
   */
  export type MemberStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter which MemberStatus to delete.
     */
    where: MemberStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberStatus deleteMany
   */
  export type MemberStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberStatuses to delete
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to delete.
     */
    limit?: number
  }

  /**
   * MemberStatus.members
   */
  export type MemberStatus$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * MemberStatus without action
   */
  export type MemberStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
  }


  /**
   * Model MemberType
   */

  export type AggregateMemberType = {
    _count: MemberTypeCountAggregateOutputType | null
    _min: MemberTypeMinAggregateOutputType | null
    _max: MemberTypeMaxAggregateOutputType | null
  }

  export type MemberTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    chipVariant: number
    chipColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberType to aggregate.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberTypes
    **/
    _count?: true | MemberTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberTypeMaxAggregateInputType
  }

  export type GetMemberTypeAggregateType<T extends MemberTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberType[P]>
      : GetScalarType<T[P], AggregateMemberType[P]>
  }




  export type MemberTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTypeWhereInput
    orderBy?: MemberTypeOrderByWithAggregationInput | MemberTypeOrderByWithAggregationInput[]
    by: MemberTypeScalarFieldEnum[] | MemberTypeScalarFieldEnum
    having?: MemberTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberTypeCountAggregateInputType | true
    _min?: MemberTypeMinAggregateInputType
    _max?: MemberTypeMaxAggregateInputType
  }

  export type MemberTypeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    chipVariant: string
    chipColor: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberTypeCountAggregateOutputType | null
    _min: MemberTypeMinAggregateOutputType | null
    _max: MemberTypeMaxAggregateOutputType | null
  }

  type GetMemberTypeGroupByPayload<T extends MemberTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberTypeGroupByOutputType[P]>
            : GetScalarType<T[P], MemberTypeGroupByOutputType[P]>
        }
      >
    >


  export type MemberTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | MemberType$membersArgs<ExtArgs>
    _count?: boolean | MemberTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "chipVariant" | "chipColor" | "createdAt" | "updatedAt", ExtArgs["result"]["memberType"]>
  export type MemberTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberType$membersArgs<ExtArgs>
    _count?: boolean | MemberTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberType"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      chipVariant: string
      chipColor: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberType"]>
    composites: {}
  }

  type MemberTypeGetPayload<S extends boolean | null | undefined | MemberTypeDefaultArgs> = $Result.GetResult<Prisma.$MemberTypePayload, S>

  type MemberTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MemberTypeCountAggregateInputType | true
    }

  export interface MemberTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberType'], meta: { name: 'MemberType' } }
    /**
     * Find zero or one MemberType that matches the filter.
     * @param {MemberTypeFindUniqueArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberTypeFindUniqueArgs>(args: SelectSubset<T, MemberTypeFindUniqueArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberTypeFindUniqueOrThrowArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindFirstArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberTypeFindFirstArgs>(args?: SelectSubset<T, MemberTypeFindFirstArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindFirstOrThrowArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberTypes
     * const memberTypes = await prisma.memberType.findMany()
     * 
     * // Get first 10 MemberTypes
     * const memberTypes = await prisma.memberType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberTypeFindManyArgs>(args?: SelectSubset<T, MemberTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberType.
     * @param {MemberTypeCreateArgs} args - Arguments to create a MemberType.
     * @example
     * // Create one MemberType
     * const MemberType = await prisma.memberType.create({
     *   data: {
     *     // ... data to create a MemberType
     *   }
     * })
     * 
     */
    create<T extends MemberTypeCreateArgs>(args: SelectSubset<T, MemberTypeCreateArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberTypes.
     * @param {MemberTypeCreateManyArgs} args - Arguments to create many MemberTypes.
     * @example
     * // Create many MemberTypes
     * const memberType = await prisma.memberType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberTypeCreateManyArgs>(args?: SelectSubset<T, MemberTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberTypes and returns the data saved in the database.
     * @param {MemberTypeCreateManyAndReturnArgs} args - Arguments to create many MemberTypes.
     * @example
     * // Create many MemberTypes
     * const memberType = await prisma.memberType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberTypes and only return the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberType.
     * @param {MemberTypeDeleteArgs} args - Arguments to delete one MemberType.
     * @example
     * // Delete one MemberType
     * const MemberType = await prisma.memberType.delete({
     *   where: {
     *     // ... filter to delete one MemberType
     *   }
     * })
     * 
     */
    delete<T extends MemberTypeDeleteArgs>(args: SelectSubset<T, MemberTypeDeleteArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberType.
     * @param {MemberTypeUpdateArgs} args - Arguments to update one MemberType.
     * @example
     * // Update one MemberType
     * const memberType = await prisma.memberType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberTypeUpdateArgs>(args: SelectSubset<T, MemberTypeUpdateArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberTypes.
     * @param {MemberTypeDeleteManyArgs} args - Arguments to filter MemberTypes to delete.
     * @example
     * // Delete a few MemberTypes
     * const { count } = await prisma.memberType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberTypeDeleteManyArgs>(args?: SelectSubset<T, MemberTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberTypes
     * const memberType = await prisma.memberType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberTypeUpdateManyArgs>(args: SelectSubset<T, MemberTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTypes and returns the data updated in the database.
     * @param {MemberTypeUpdateManyAndReturnArgs} args - Arguments to update many MemberTypes.
     * @example
     * // Update many MemberTypes
     * const memberType = await prisma.memberType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberTypes and only return the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberType.
     * @param {MemberTypeUpsertArgs} args - Arguments to update or create a MemberType.
     * @example
     * // Update or create a MemberType
     * const memberType = await prisma.memberType.upsert({
     *   create: {
     *     // ... data to create a MemberType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberType we want to update
     *   }
     * })
     */
    upsert<T extends MemberTypeUpsertArgs>(args: SelectSubset<T, MemberTypeUpsertArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeCountArgs} args - Arguments to filter MemberTypes to count.
     * @example
     * // Count the number of MemberTypes
     * const count = await prisma.memberType.count({
     *   where: {
     *     // ... the filter for the MemberTypes we want to count
     *   }
     * })
    **/
    count<T extends MemberTypeCountArgs>(
      args?: Subset<T, MemberTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberTypeAggregateArgs>(args: Subset<T, MemberTypeAggregateArgs>): Prisma.PrismaPromise<GetMemberTypeAggregateType<T>>

    /**
     * Group by MemberType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberTypeGroupByArgs['orderBy'] }
        : { orderBy?: MemberTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberType model
   */
  readonly fields: MemberTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MemberType$membersArgs<ExtArgs> = {}>(args?: Subset<T, MemberType$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberType model
   */
  interface MemberTypeFieldRefs {
    readonly id: FieldRef<"MemberType", 'String'>
    readonly code: FieldRef<"MemberType", 'String'>
    readonly name: FieldRef<"MemberType", 'String'>
    readonly description: FieldRef<"MemberType", 'String'>
    readonly chipVariant: FieldRef<"MemberType", 'String'>
    readonly chipColor: FieldRef<"MemberType", 'String'>
    readonly createdAt: FieldRef<"MemberType", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberType findUnique
   */
  export type MemberTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where: MemberTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType findUniqueOrThrow
   */
  export type MemberTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where: MemberTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType findFirst
   */
  export type MemberTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTypes.
     */
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType findFirstOrThrow
   */
  export type MemberTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTypes.
     */
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType findMany
   */
  export type MemberTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberTypes to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType create
   */
  export type MemberTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberType.
     */
    data: XOR<MemberTypeCreateInput, MemberTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType createMany
   */
  export type MemberTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberTypes.
     */
    data: MemberTypeCreateManyInput | MemberTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberType createManyAndReturn
   */
  export type MemberTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * The data used to create many MemberTypes.
     */
    data: MemberTypeCreateManyInput | MemberTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberType update
   */
  export type MemberTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberType.
     */
    data: XOR<MemberTypeUpdateInput, MemberTypeUncheckedUpdateInput>
    /**
     * Choose, which MemberType to update.
     */
    where: MemberTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType updateMany
   */
  export type MemberTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberTypes.
     */
    data: XOR<MemberTypeUpdateManyMutationInput, MemberTypeUncheckedUpdateManyInput>
    /**
     * Filter which MemberTypes to update
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to update.
     */
    limit?: number
  }

  /**
   * MemberType updateManyAndReturn
   */
  export type MemberTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * The data used to update MemberTypes.
     */
    data: XOR<MemberTypeUpdateManyMutationInput, MemberTypeUncheckedUpdateManyInput>
    /**
     * Filter which MemberTypes to update
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to update.
     */
    limit?: number
  }

  /**
   * MemberType upsert
   */
  export type MemberTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberType to update in case it exists.
     */
    where: MemberTypeWhereUniqueInput
    /**
     * In case the MemberType found by the `where` argument doesn't exist, create a new MemberType with this data.
     */
    create: XOR<MemberTypeCreateInput, MemberTypeUncheckedCreateInput>
    /**
     * In case the MemberType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberTypeUpdateInput, MemberTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType delete
   */
  export type MemberTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter which MemberType to delete.
     */
    where: MemberTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberType deleteMany
   */
  export type MemberTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTypes to delete
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to delete.
     */
    limit?: number
  }

  /**
   * MemberType.members
   */
  export type MemberType$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * MemberType without action
   */
  export type MemberTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
  }


  /**
   * Model VisitType
   */

  export type AggregateVisitType = {
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  export type VisitTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    chipVariant: number
    chipColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitType to aggregate.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitTypes
    **/
    _count?: true | VisitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitTypeMaxAggregateInputType
  }

  export type GetVisitTypeAggregateType<T extends VisitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitType[P]>
      : GetScalarType<T[P], AggregateVisitType[P]>
  }




  export type VisitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTypeWhereInput
    orderBy?: VisitTypeOrderByWithAggregationInput | VisitTypeOrderByWithAggregationInput[]
    by: VisitTypeScalarFieldEnum[] | VisitTypeScalarFieldEnum
    having?: VisitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitTypeCountAggregateInputType | true
    _min?: VisitTypeMinAggregateInputType
    _max?: VisitTypeMaxAggregateInputType
  }

  export type VisitTypeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    chipVariant: string
    chipColor: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  type GetVisitTypeGroupByPayload<T extends VisitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
        }
      >
    >


  export type VisitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visitors?: boolean | VisitType$visitorsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "chipVariant" | "chipColor" | "createdAt" | "updatedAt", ExtArgs["result"]["visitType"]>
  export type VisitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | VisitType$visitorsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisitTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VisitTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VisitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitType"
    objects: {
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      chipVariant: string
      chipColor: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["visitType"]>
    composites: {}
  }

  type VisitTypeGetPayload<S extends boolean | null | undefined | VisitTypeDefaultArgs> = $Result.GetResult<Prisma.$VisitTypePayload, S>

  type VisitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VisitTypeCountAggregateInputType | true
    }

  export interface VisitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitType'], meta: { name: 'VisitType' } }
    /**
     * Find zero or one VisitType that matches the filter.
     * @param {VisitTypeFindUniqueArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitTypeFindUniqueArgs>(args: SelectSubset<T, VisitTypeFindUniqueArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitTypeFindUniqueOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitTypeFindFirstArgs>(args?: SelectSubset<T, VisitTypeFindFirstArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitTypes
     * const visitTypes = await prisma.visitType.findMany()
     * 
     * // Get first 10 VisitTypes
     * const visitTypes = await prisma.visitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitTypeFindManyArgs>(args?: SelectSubset<T, VisitTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitType.
     * @param {VisitTypeCreateArgs} args - Arguments to create a VisitType.
     * @example
     * // Create one VisitType
     * const VisitType = await prisma.visitType.create({
     *   data: {
     *     // ... data to create a VisitType
     *   }
     * })
     * 
     */
    create<T extends VisitTypeCreateArgs>(args: SelectSubset<T, VisitTypeCreateArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitTypes.
     * @param {VisitTypeCreateManyArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitTypeCreateManyArgs>(args?: SelectSubset<T, VisitTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitTypes and returns the data saved in the database.
     * @param {VisitTypeCreateManyAndReturnArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisitType.
     * @param {VisitTypeDeleteArgs} args - Arguments to delete one VisitType.
     * @example
     * // Delete one VisitType
     * const VisitType = await prisma.visitType.delete({
     *   where: {
     *     // ... filter to delete one VisitType
     *   }
     * })
     * 
     */
    delete<T extends VisitTypeDeleteArgs>(args: SelectSubset<T, VisitTypeDeleteArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitType.
     * @param {VisitTypeUpdateArgs} args - Arguments to update one VisitType.
     * @example
     * // Update one VisitType
     * const visitType = await prisma.visitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitTypeUpdateArgs>(args: SelectSubset<T, VisitTypeUpdateArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitTypes.
     * @param {VisitTypeDeleteManyArgs} args - Arguments to filter VisitTypes to delete.
     * @example
     * // Delete a few VisitTypes
     * const { count } = await prisma.visitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitTypeDeleteManyArgs>(args?: SelectSubset<T, VisitTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitTypeUpdateManyArgs>(args: SelectSubset<T, VisitTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes and returns the data updated in the database.
     * @param {VisitTypeUpdateManyAndReturnArgs} args - Arguments to update many VisitTypes.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisitType.
     * @param {VisitTypeUpsertArgs} args - Arguments to update or create a VisitType.
     * @example
     * // Update or create a VisitType
     * const visitType = await prisma.visitType.upsert({
     *   create: {
     *     // ... data to create a VisitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitType we want to update
     *   }
     * })
     */
    upsert<T extends VisitTypeUpsertArgs>(args: SelectSubset<T, VisitTypeUpsertArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeCountArgs} args - Arguments to filter VisitTypes to count.
     * @example
     * // Count the number of VisitTypes
     * const count = await prisma.visitType.count({
     *   where: {
     *     // ... the filter for the VisitTypes we want to count
     *   }
     * })
    **/
    count<T extends VisitTypeCountArgs>(
      args?: Subset<T, VisitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitTypeAggregateArgs>(args: Subset<T, VisitTypeAggregateArgs>): Prisma.PrismaPromise<GetVisitTypeAggregateType<T>>

    /**
     * Group by VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitTypeGroupByArgs['orderBy'] }
        : { orderBy?: VisitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitType model
   */
  readonly fields: VisitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitors<T extends VisitType$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, VisitType$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitType model
   */
  interface VisitTypeFieldRefs {
    readonly id: FieldRef<"VisitType", 'String'>
    readonly code: FieldRef<"VisitType", 'String'>
    readonly name: FieldRef<"VisitType", 'String'>
    readonly description: FieldRef<"VisitType", 'String'>
    readonly chipVariant: FieldRef<"VisitType", 'String'>
    readonly chipColor: FieldRef<"VisitType", 'String'>
    readonly createdAt: FieldRef<"VisitType", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitType findUnique
   */
  export type VisitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType findUniqueOrThrow
   */
  export type VisitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType findFirst
   */
  export type VisitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType findFirstOrThrow
   */
  export type VisitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType findMany
   */
  export type VisitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitTypes to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType create
   */
  export type VisitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitType.
     */
    data: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType createMany
   */
  export type VisitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType createManyAndReturn
   */
  export type VisitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType update
   */
  export type VisitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitType.
     */
    data: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
    /**
     * Choose, which VisitType to update.
     */
    where: VisitTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType updateMany
   */
  export type VisitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to update.
     */
    limit?: number
  }

  /**
   * VisitType updateManyAndReturn
   */
  export type VisitTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to update.
     */
    limit?: number
  }

  /**
   * VisitType upsert
   */
  export type VisitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitType to update in case it exists.
     */
    where: VisitTypeWhereUniqueInput
    /**
     * In case the VisitType found by the `where` argument doesn't exist, create a new VisitType with this data.
     */
    create: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
    /**
     * In case the VisitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType delete
   */
  export type VisitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter which VisitType to delete.
     */
    where: VisitTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VisitType deleteMany
   */
  export type VisitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTypes to delete
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to delete.
     */
    limit?: number
  }

  /**
   * VisitType.visitors
   */
  export type VisitType$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * VisitType without action
   */
  export type VisitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
  }


  /**
   * Model BadgeStatus
   */

  export type AggregateBadgeStatus = {
    _count: BadgeStatusCountAggregateOutputType | null
    _min: BadgeStatusMinAggregateOutputType | null
    _max: BadgeStatusMaxAggregateOutputType | null
  }

  export type BadgeStatusMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeStatusMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    chipVariant: string | null
    chipColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeStatusCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    chipVariant: number
    chipColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeStatusMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeStatusMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeStatusCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    chipVariant?: true
    chipColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeStatus to aggregate.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BadgeStatuses
    **/
    _count?: true | BadgeStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeStatusMaxAggregateInputType
  }

  export type GetBadgeStatusAggregateType<T extends BadgeStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateBadgeStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadgeStatus[P]>
      : GetScalarType<T[P], AggregateBadgeStatus[P]>
  }




  export type BadgeStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeStatusWhereInput
    orderBy?: BadgeStatusOrderByWithAggregationInput | BadgeStatusOrderByWithAggregationInput[]
    by: BadgeStatusScalarFieldEnum[] | BadgeStatusScalarFieldEnum
    having?: BadgeStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeStatusCountAggregateInputType | true
    _min?: BadgeStatusMinAggregateInputType
    _max?: BadgeStatusMaxAggregateInputType
  }

  export type BadgeStatusGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    chipVariant: string
    chipColor: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BadgeStatusCountAggregateOutputType | null
    _min: BadgeStatusMinAggregateOutputType | null
    _max: BadgeStatusMaxAggregateOutputType | null
  }

  type GetBadgeStatusGroupByPayload<T extends BadgeStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeStatusGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeStatusGroupByOutputType[P]>
        }
      >
    >


  export type BadgeStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badges?: boolean | BadgeStatus$badgesArgs<ExtArgs>
    _count?: boolean | BadgeStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    chipVariant?: boolean
    chipColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "chipVariant" | "chipColor" | "createdAt" | "updatedAt", ExtArgs["result"]["badgeStatus"]>
  export type BadgeStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeStatus$badgesArgs<ExtArgs>
    _count?: boolean | BadgeStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgeStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BadgeStatus"
    objects: {
      badges: Prisma.$BadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      chipVariant: string
      chipColor: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["badgeStatus"]>
    composites: {}
  }

  type BadgeStatusGetPayload<S extends boolean | null | undefined | BadgeStatusDefaultArgs> = $Result.GetResult<Prisma.$BadgeStatusPayload, S>

  type BadgeStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BadgeStatusCountAggregateInputType | true
    }

  export interface BadgeStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BadgeStatus'], meta: { name: 'BadgeStatus' } }
    /**
     * Find zero or one BadgeStatus that matches the filter.
     * @param {BadgeStatusFindUniqueArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeStatusFindUniqueArgs>(args: SelectSubset<T, BadgeStatusFindUniqueArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BadgeStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeStatusFindUniqueOrThrowArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindFirstArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeStatusFindFirstArgs>(args?: SelectSubset<T, BadgeStatusFindFirstArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindFirstOrThrowArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BadgeStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BadgeStatuses
     * const badgeStatuses = await prisma.badgeStatus.findMany()
     * 
     * // Get first 10 BadgeStatuses
     * const badgeStatuses = await prisma.badgeStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeStatusFindManyArgs>(args?: SelectSubset<T, BadgeStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BadgeStatus.
     * @param {BadgeStatusCreateArgs} args - Arguments to create a BadgeStatus.
     * @example
     * // Create one BadgeStatus
     * const BadgeStatus = await prisma.badgeStatus.create({
     *   data: {
     *     // ... data to create a BadgeStatus
     *   }
     * })
     * 
     */
    create<T extends BadgeStatusCreateArgs>(args: SelectSubset<T, BadgeStatusCreateArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BadgeStatuses.
     * @param {BadgeStatusCreateManyArgs} args - Arguments to create many BadgeStatuses.
     * @example
     * // Create many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeStatusCreateManyArgs>(args?: SelectSubset<T, BadgeStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BadgeStatuses and returns the data saved in the database.
     * @param {BadgeStatusCreateManyAndReturnArgs} args - Arguments to create many BadgeStatuses.
     * @example
     * // Create many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BadgeStatuses and only return the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BadgeStatus.
     * @param {BadgeStatusDeleteArgs} args - Arguments to delete one BadgeStatus.
     * @example
     * // Delete one BadgeStatus
     * const BadgeStatus = await prisma.badgeStatus.delete({
     *   where: {
     *     // ... filter to delete one BadgeStatus
     *   }
     * })
     * 
     */
    delete<T extends BadgeStatusDeleteArgs>(args: SelectSubset<T, BadgeStatusDeleteArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BadgeStatus.
     * @param {BadgeStatusUpdateArgs} args - Arguments to update one BadgeStatus.
     * @example
     * // Update one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeStatusUpdateArgs>(args: SelectSubset<T, BadgeStatusUpdateArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BadgeStatuses.
     * @param {BadgeStatusDeleteManyArgs} args - Arguments to filter BadgeStatuses to delete.
     * @example
     * // Delete a few BadgeStatuses
     * const { count } = await prisma.badgeStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeStatusDeleteManyArgs>(args?: SelectSubset<T, BadgeStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeStatusUpdateManyArgs>(args: SelectSubset<T, BadgeStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeStatuses and returns the data updated in the database.
     * @param {BadgeStatusUpdateManyAndReturnArgs} args - Arguments to update many BadgeStatuses.
     * @example
     * // Update many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BadgeStatuses and only return the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BadgeStatus.
     * @param {BadgeStatusUpsertArgs} args - Arguments to update or create a BadgeStatus.
     * @example
     * // Update or create a BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.upsert({
     *   create: {
     *     // ... data to create a BadgeStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BadgeStatus we want to update
     *   }
     * })
     */
    upsert<T extends BadgeStatusUpsertArgs>(args: SelectSubset<T, BadgeStatusUpsertArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BadgeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusCountArgs} args - Arguments to filter BadgeStatuses to count.
     * @example
     * // Count the number of BadgeStatuses
     * const count = await prisma.badgeStatus.count({
     *   where: {
     *     // ... the filter for the BadgeStatuses we want to count
     *   }
     * })
    **/
    count<T extends BadgeStatusCountArgs>(
      args?: Subset<T, BadgeStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BadgeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeStatusAggregateArgs>(args: Subset<T, BadgeStatusAggregateArgs>): Prisma.PrismaPromise<GetBadgeStatusAggregateType<T>>

    /**
     * Group by BadgeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeStatusGroupByArgs['orderBy'] }
        : { orderBy?: BadgeStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BadgeStatus model
   */
  readonly fields: BadgeStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BadgeStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends BadgeStatus$badgesArgs<ExtArgs> = {}>(args?: Subset<T, BadgeStatus$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BadgeStatus model
   */
  interface BadgeStatusFieldRefs {
    readonly id: FieldRef<"BadgeStatus", 'String'>
    readonly code: FieldRef<"BadgeStatus", 'String'>
    readonly name: FieldRef<"BadgeStatus", 'String'>
    readonly description: FieldRef<"BadgeStatus", 'String'>
    readonly chipVariant: FieldRef<"BadgeStatus", 'String'>
    readonly chipColor: FieldRef<"BadgeStatus", 'String'>
    readonly createdAt: FieldRef<"BadgeStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"BadgeStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BadgeStatus findUnique
   */
  export type BadgeStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where: BadgeStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus findUniqueOrThrow
   */
  export type BadgeStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where: BadgeStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus findFirst
   */
  export type BadgeStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeStatuses.
     */
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus findFirstOrThrow
   */
  export type BadgeStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeStatuses.
     */
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus findMany
   */
  export type BadgeStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatuses to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus create
   */
  export type BadgeStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a BadgeStatus.
     */
    data: XOR<BadgeStatusCreateInput, BadgeStatusUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus createMany
   */
  export type BadgeStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BadgeStatuses.
     */
    data: BadgeStatusCreateManyInput | BadgeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeStatus createManyAndReturn
   */
  export type BadgeStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * The data used to create many BadgeStatuses.
     */
    data: BadgeStatusCreateManyInput | BadgeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeStatus update
   */
  export type BadgeStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a BadgeStatus.
     */
    data: XOR<BadgeStatusUpdateInput, BadgeStatusUncheckedUpdateInput>
    /**
     * Choose, which BadgeStatus to update.
     */
    where: BadgeStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus updateMany
   */
  export type BadgeStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BadgeStatuses.
     */
    data: XOR<BadgeStatusUpdateManyMutationInput, BadgeStatusUncheckedUpdateManyInput>
    /**
     * Filter which BadgeStatuses to update
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to update.
     */
    limit?: number
  }

  /**
   * BadgeStatus updateManyAndReturn
   */
  export type BadgeStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * The data used to update BadgeStatuses.
     */
    data: XOR<BadgeStatusUpdateManyMutationInput, BadgeStatusUncheckedUpdateManyInput>
    /**
     * Filter which BadgeStatuses to update
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to update.
     */
    limit?: number
  }

  /**
   * BadgeStatus upsert
   */
  export type BadgeStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the BadgeStatus to update in case it exists.
     */
    where: BadgeStatusWhereUniqueInput
    /**
     * In case the BadgeStatus found by the `where` argument doesn't exist, create a new BadgeStatus with this data.
     */
    create: XOR<BadgeStatusCreateInput, BadgeStatusUncheckedCreateInput>
    /**
     * In case the BadgeStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeStatusUpdateInput, BadgeStatusUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus delete
   */
  export type BadgeStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter which BadgeStatus to delete.
     */
    where: BadgeStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BadgeStatus deleteMany
   */
  export type BadgeStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeStatuses to delete
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to delete.
     */
    limit?: number
  }

  /**
   * BadgeStatus.badges
   */
  export type BadgeStatus$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * BadgeStatus without action
   */
  export type BadgeStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
  }


  /**
   * Model ListItem
   */

  export type AggregateListItem = {
    _count: ListItemCountAggregateOutputType | null
    _avg: ListItemAvgAggregateOutputType | null
    _sum: ListItemSumAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  export type ListItemAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ListItemSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ListItemMinAggregateOutputType = {
    id: string | null
    listType: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListItemMaxAggregateOutputType = {
    id: string | null
    listType: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListItemCountAggregateOutputType = {
    id: number
    listType: number
    code: number
    name: number
    displayOrder: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListItemAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ListItemSumAggregateInputType = {
    displayOrder?: true
  }

  export type ListItemMinAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListItemMaxAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListItemCountAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItem to aggregate.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListItems
    **/
    _count?: true | ListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListItemMaxAggregateInputType
  }

  export type GetListItemAggregateType<T extends ListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListItem[P]>
      : GetScalarType<T[P], AggregateListItem[P]>
  }




  export type ListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListItemWhereInput
    orderBy?: ListItemOrderByWithAggregationInput | ListItemOrderByWithAggregationInput[]
    by: ListItemScalarFieldEnum[] | ListItemScalarFieldEnum
    having?: ListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListItemCountAggregateInputType | true
    _avg?: ListItemAvgAggregateInputType
    _sum?: ListItemSumAggregateInputType
    _min?: ListItemMinAggregateInputType
    _max?: ListItemMaxAggregateInputType
  }

  export type ListItemGroupByOutputType = {
    id: string
    listType: string
    code: string
    name: string
    displayOrder: number
    description: string | null
    isSystem: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: ListItemCountAggregateOutputType | null
    _avg: ListItemAvgAggregateOutputType | null
    _sum: ListItemSumAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  type GetListItemGroupByPayload<T extends ListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListItemGroupByOutputType[P]>
            : GetScalarType<T[P], ListItemGroupByOutputType[P]>
        }
      >
    >


  export type ListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectScalar = {
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listType" | "code" | "name" | "displayOrder" | "description" | "isSystem" | "createdAt" | "updatedAt", ExtArgs["result"]["listItem"]>

  export type $ListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listType: string
      code: string
      name: string
      displayOrder: number
      description: string | null
      isSystem: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["listItem"]>
    composites: {}
  }

  type ListItemGetPayload<S extends boolean | null | undefined | ListItemDefaultArgs> = $Result.GetResult<Prisma.$ListItemPayload, S>

  type ListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ListItemCountAggregateInputType | true
    }

  export interface ListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListItem'], meta: { name: 'ListItem' } }
    /**
     * Find zero or one ListItem that matches the filter.
     * @param {ListItemFindUniqueArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListItemFindUniqueArgs>(args: SelectSubset<T, ListItemFindUniqueArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListItemFindUniqueOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListItemFindFirstArgs>(args?: SelectSubset<T, ListItemFindFirstArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListItems
     * const listItems = await prisma.listItem.findMany()
     * 
     * // Get first 10 ListItems
     * const listItems = await prisma.listItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listItemWithIdOnly = await prisma.listItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListItemFindManyArgs>(args?: SelectSubset<T, ListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListItem.
     * @param {ListItemCreateArgs} args - Arguments to create a ListItem.
     * @example
     * // Create one ListItem
     * const ListItem = await prisma.listItem.create({
     *   data: {
     *     // ... data to create a ListItem
     *   }
     * })
     * 
     */
    create<T extends ListItemCreateArgs>(args: SelectSubset<T, ListItemCreateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListItems.
     * @param {ListItemCreateManyArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListItemCreateManyArgs>(args?: SelectSubset<T, ListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListItems and returns the data saved in the database.
     * @param {ListItemCreateManyAndReturnArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ListItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListItem.
     * @param {ListItemDeleteArgs} args - Arguments to delete one ListItem.
     * @example
     * // Delete one ListItem
     * const ListItem = await prisma.listItem.delete({
     *   where: {
     *     // ... filter to delete one ListItem
     *   }
     * })
     * 
     */
    delete<T extends ListItemDeleteArgs>(args: SelectSubset<T, ListItemDeleteArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListItem.
     * @param {ListItemUpdateArgs} args - Arguments to update one ListItem.
     * @example
     * // Update one ListItem
     * const listItem = await prisma.listItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListItemUpdateArgs>(args: SelectSubset<T, ListItemUpdateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListItems.
     * @param {ListItemDeleteManyArgs} args - Arguments to filter ListItems to delete.
     * @example
     * // Delete a few ListItems
     * const { count } = await prisma.listItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListItemDeleteManyArgs>(args?: SelectSubset<T, ListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListItemUpdateManyArgs>(args: SelectSubset<T, ListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems and returns the data updated in the database.
     * @param {ListItemUpdateManyAndReturnArgs} args - Arguments to update many ListItems.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ListItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListItem.
     * @param {ListItemUpsertArgs} args - Arguments to update or create a ListItem.
     * @example
     * // Update or create a ListItem
     * const listItem = await prisma.listItem.upsert({
     *   create: {
     *     // ... data to create a ListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListItem we want to update
     *   }
     * })
     */
    upsert<T extends ListItemUpsertArgs>(args: SelectSubset<T, ListItemUpsertArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemCountArgs} args - Arguments to filter ListItems to count.
     * @example
     * // Count the number of ListItems
     * const count = await prisma.listItem.count({
     *   where: {
     *     // ... the filter for the ListItems we want to count
     *   }
     * })
    **/
    count<T extends ListItemCountArgs>(
      args?: Subset<T, ListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListItemAggregateArgs>(args: Subset<T, ListItemAggregateArgs>): Prisma.PrismaPromise<GetListItemAggregateType<T>>

    /**
     * Group by ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListItemGroupByArgs['orderBy'] }
        : { orderBy?: ListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListItem model
   */
  readonly fields: ListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListItem model
   */
  interface ListItemFieldRefs {
    readonly id: FieldRef<"ListItem", 'String'>
    readonly listType: FieldRef<"ListItem", 'String'>
    readonly code: FieldRef<"ListItem", 'String'>
    readonly name: FieldRef<"ListItem", 'String'>
    readonly displayOrder: FieldRef<"ListItem", 'Int'>
    readonly description: FieldRef<"ListItem", 'String'>
    readonly isSystem: FieldRef<"ListItem", 'Boolean'>
    readonly createdAt: FieldRef<"ListItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ListItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListItem findUnique
   */
  export type ListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem findUniqueOrThrow
   */
  export type ListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem findFirst
   */
  export type ListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem findFirstOrThrow
   */
  export type ListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem findMany
   */
  export type ListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItems to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem create
   */
  export type ListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data needed to create a ListItem.
     */
    data: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem createMany
   */
  export type ListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListItem createManyAndReturn
   */
  export type ListItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListItem update
   */
  export type ListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data needed to update a ListItem.
     */
    data: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
    /**
     * Choose, which ListItem to update.
     */
    where: ListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem updateMany
   */
  export type ListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
  }

  /**
   * ListItem updateManyAndReturn
   */
  export type ListItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
  }

  /**
   * ListItem upsert
   */
  export type ListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The filter to search for the ListItem to update in case it exists.
     */
    where: ListItemWhereUniqueInput
    /**
     * In case the ListItem found by the `where` argument doesn't exist, create a new ListItem with this data.
     */
    create: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
    /**
     * In case the ListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem delete
   */
  export type ListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter which ListItem to delete.
     */
    where: ListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ListItem deleteMany
   */
  export type ListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItems to delete
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to delete.
     */
    limit?: number
  }

  /**
   * ListItem without action
   */
  export type ListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
  }


  /**
   * Model Rank
   */

  export type AggregateRank = {
    _count: RankCountAggregateOutputType | null
    _avg: RankAvgAggregateOutputType | null
    _sum: RankSumAggregateOutputType | null
    _min: RankMinAggregateOutputType | null
    _max: RankMaxAggregateOutputType | null
  }

  export type RankAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type RankSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type RankMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    branch: string | null
    category: string | null
    displayOrder: number | null
    isActive: boolean | null
    replacedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RankMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    branch: string | null
    category: string | null
    displayOrder: number | null
    isActive: boolean | null
    replacedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RankCountAggregateOutputType = {
    id: number
    code: number
    name: number
    branch: number
    category: number
    displayOrder: number
    isActive: number
    replacedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RankAvgAggregateInputType = {
    displayOrder?: true
  }

  export type RankSumAggregateInputType = {
    displayOrder?: true
  }

  export type RankMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    branch?: true
    category?: true
    displayOrder?: true
    isActive?: true
    replacedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RankMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    branch?: true
    category?: true
    displayOrder?: true
    isActive?: true
    replacedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RankCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    branch?: true
    category?: true
    displayOrder?: true
    isActive?: true
    replacedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rank to aggregate.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ranks
    **/
    _count?: true | RankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankMaxAggregateInputType
  }

  export type GetRankAggregateType<T extends RankAggregateArgs> = {
        [P in keyof T & keyof AggregateRank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRank[P]>
      : GetScalarType<T[P], AggregateRank[P]>
  }




  export type RankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankWhereInput
    orderBy?: RankOrderByWithAggregationInput | RankOrderByWithAggregationInput[]
    by: RankScalarFieldEnum[] | RankScalarFieldEnum
    having?: RankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankCountAggregateInputType | true
    _avg?: RankAvgAggregateInputType
    _sum?: RankSumAggregateInputType
    _min?: RankMinAggregateInputType
    _max?: RankMaxAggregateInputType
  }

  export type RankGroupByOutputType = {
    id: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive: boolean
    replacedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: RankCountAggregateOutputType | null
    _avg: RankAvgAggregateOutputType | null
    _sum: RankSumAggregateOutputType | null
    _min: RankMinAggregateOutputType | null
    _max: RankMaxAggregateOutputType | null
  }

  type GetRankGroupByPayload<T extends RankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankGroupByOutputType[P]>
            : GetScalarType<T[P], RankGroupByOutputType[P]>
        }
      >
    >


  export type RankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    branch?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    replacedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Rank$membersArgs<ExtArgs>
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
    replacesRanks?: boolean | Rank$replacesRanksArgs<ExtArgs>
    _count?: boolean | RankCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rank"]>

  export type RankSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    branch?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    replacedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
  }, ExtArgs["result"]["rank"]>

  export type RankSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    branch?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    replacedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
  }, ExtArgs["result"]["rank"]>

  export type RankSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    branch?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    replacedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RankOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "branch" | "category" | "displayOrder" | "isActive" | "replacedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["rank"]>
  export type RankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Rank$membersArgs<ExtArgs>
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
    replacesRanks?: boolean | Rank$replacesRanksArgs<ExtArgs>
    _count?: boolean | RankCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RankIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
  }
  export type RankIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacedByRank?: boolean | Rank$replacedByRankArgs<ExtArgs>
  }

  export type $RankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rank"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      replacedByRank: Prisma.$RankPayload<ExtArgs> | null
      replacesRanks: Prisma.$RankPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      branch: string
      category: string
      displayOrder: number
      isActive: boolean
      replacedBy: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["rank"]>
    composites: {}
  }

  type RankGetPayload<S extends boolean | null | undefined | RankDefaultArgs> = $Result.GetResult<Prisma.$RankPayload, S>

  type RankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RankFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: RankCountAggregateInputType | true
    }

  export interface RankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rank'], meta: { name: 'Rank' } }
    /**
     * Find zero or one Rank that matches the filter.
     * @param {RankFindUniqueArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RankFindUniqueArgs>(args: SelectSubset<T, RankFindUniqueArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rank that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RankFindUniqueOrThrowArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RankFindUniqueOrThrowArgs>(args: SelectSubset<T, RankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindFirstArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RankFindFirstArgs>(args?: SelectSubset<T, RankFindFirstArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindFirstOrThrowArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RankFindFirstOrThrowArgs>(args?: SelectSubset<T, RankFindFirstOrThrowArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ranks
     * const ranks = await prisma.rank.findMany()
     * 
     * // Get first 10 Ranks
     * const ranks = await prisma.rank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankWithIdOnly = await prisma.rank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RankFindManyArgs>(args?: SelectSubset<T, RankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rank.
     * @param {RankCreateArgs} args - Arguments to create a Rank.
     * @example
     * // Create one Rank
     * const Rank = await prisma.rank.create({
     *   data: {
     *     // ... data to create a Rank
     *   }
     * })
     * 
     */
    create<T extends RankCreateArgs>(args: SelectSubset<T, RankCreateArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ranks.
     * @param {RankCreateManyArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const rank = await prisma.rank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RankCreateManyArgs>(args?: SelectSubset<T, RankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ranks and returns the data saved in the database.
     * @param {RankCreateManyAndReturnArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const rank = await prisma.rank.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ranks and only return the `id`
     * const rankWithIdOnly = await prisma.rank.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RankCreateManyAndReturnArgs>(args?: SelectSubset<T, RankCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rank.
     * @param {RankDeleteArgs} args - Arguments to delete one Rank.
     * @example
     * // Delete one Rank
     * const Rank = await prisma.rank.delete({
     *   where: {
     *     // ... filter to delete one Rank
     *   }
     * })
     * 
     */
    delete<T extends RankDeleteArgs>(args: SelectSubset<T, RankDeleteArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rank.
     * @param {RankUpdateArgs} args - Arguments to update one Rank.
     * @example
     * // Update one Rank
     * const rank = await prisma.rank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RankUpdateArgs>(args: SelectSubset<T, RankUpdateArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ranks.
     * @param {RankDeleteManyArgs} args - Arguments to filter Ranks to delete.
     * @example
     * // Delete a few Ranks
     * const { count } = await prisma.rank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RankDeleteManyArgs>(args?: SelectSubset<T, RankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ranks
     * const rank = await prisma.rank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RankUpdateManyArgs>(args: SelectSubset<T, RankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks and returns the data updated in the database.
     * @param {RankUpdateManyAndReturnArgs} args - Arguments to update many Ranks.
     * @example
     * // Update many Ranks
     * const rank = await prisma.rank.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ranks and only return the `id`
     * const rankWithIdOnly = await prisma.rank.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RankUpdateManyAndReturnArgs>(args: SelectSubset<T, RankUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rank.
     * @param {RankUpsertArgs} args - Arguments to update or create a Rank.
     * @example
     * // Update or create a Rank
     * const rank = await prisma.rank.upsert({
     *   create: {
     *     // ... data to create a Rank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rank we want to update
     *   }
     * })
     */
    upsert<T extends RankUpsertArgs>(args: SelectSubset<T, RankUpsertArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankCountArgs} args - Arguments to filter Ranks to count.
     * @example
     * // Count the number of Ranks
     * const count = await prisma.rank.count({
     *   where: {
     *     // ... the filter for the Ranks we want to count
     *   }
     * })
    **/
    count<T extends RankCountArgs>(
      args?: Subset<T, RankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankAggregateArgs>(args: Subset<T, RankAggregateArgs>): Prisma.PrismaPromise<GetRankAggregateType<T>>

    /**
     * Group by Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankGroupByArgs['orderBy'] }
        : { orderBy?: RankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rank model
   */
  readonly fields: RankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Rank$membersArgs<ExtArgs> = {}>(args?: Subset<T, Rank$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    replacedByRank<T extends Rank$replacedByRankArgs<ExtArgs> = {}>(args?: Subset<T, Rank$replacedByRankArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replacesRanks<T extends Rank$replacesRanksArgs<ExtArgs> = {}>(args?: Subset<T, Rank$replacesRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rank model
   */
  interface RankFieldRefs {
    readonly id: FieldRef<"Rank", 'String'>
    readonly code: FieldRef<"Rank", 'String'>
    readonly name: FieldRef<"Rank", 'String'>
    readonly branch: FieldRef<"Rank", 'String'>
    readonly category: FieldRef<"Rank", 'String'>
    readonly displayOrder: FieldRef<"Rank", 'Int'>
    readonly isActive: FieldRef<"Rank", 'Boolean'>
    readonly replacedBy: FieldRef<"Rank", 'String'>
    readonly createdAt: FieldRef<"Rank", 'DateTime'>
    readonly updatedAt: FieldRef<"Rank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rank findUnique
   */
  export type RankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where: RankWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank findUniqueOrThrow
   */
  export type RankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where: RankWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank findFirst
   */
  export type RankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank findFirstOrThrow
   */
  export type RankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank findMany
   */
  export type RankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank create
   */
  export type RankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * The data needed to create a Rank.
     */
    data: XOR<RankCreateInput, RankUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank createMany
   */
  export type RankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ranks.
     */
    data: RankCreateManyInput | RankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rank createManyAndReturn
   */
  export type RankCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * The data used to create many Ranks.
     */
    data: RankCreateManyInput | RankCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rank update
   */
  export type RankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * The data needed to update a Rank.
     */
    data: XOR<RankUpdateInput, RankUncheckedUpdateInput>
    /**
     * Choose, which Rank to update.
     */
    where: RankWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank updateMany
   */
  export type RankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ranks.
     */
    data: XOR<RankUpdateManyMutationInput, RankUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RankWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
  }

  /**
   * Rank updateManyAndReturn
   */
  export type RankUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * The data used to update Ranks.
     */
    data: XOR<RankUpdateManyMutationInput, RankUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RankWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rank upsert
   */
  export type RankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * The filter to search for the Rank to update in case it exists.
     */
    where: RankWhereUniqueInput
    /**
     * In case the Rank found by the `where` argument doesn't exist, create a new Rank with this data.
     */
    create: XOR<RankCreateInput, RankUncheckedCreateInput>
    /**
     * In case the Rank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankUpdateInput, RankUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank delete
   */
  export type RankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    /**
     * Filter which Rank to delete.
     */
    where: RankWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rank deleteMany
   */
  export type RankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to delete
     */
    where?: RankWhereInput
    /**
     * Limit how many Ranks to delete.
     */
    limit?: number
  }

  /**
   * Rank.members
   */
  export type Rank$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Rank.replacedByRank
   */
  export type Rank$replacedByRankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    where?: RankWhereInput
  }

  /**
   * Rank.replacesRanks
   */
  export type Rank$replacesRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
    where?: RankWhereInput
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    cursor?: RankWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
  }

  /**
   * Rank without action
   */
  export type RankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rank
     */
    omit?: RankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    role: string | null
    badgeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    role: string | null
    badgeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    name: number
    image: number
    role: number
    badgeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: boolean
    name: string | null
    image: string | null
    role: string
    badgeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "name" | "image" | "role" | "badgeId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: boolean
      name: string | null
      image: string | null
      role: string
      badgeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly badgeId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    expiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "expiresAt" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      expiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'Json'>
    readonly category: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model AlertConfig
   */

  export type AggregateAlertConfig = {
    _count: AlertConfigCountAggregateOutputType | null
    _min: AlertConfigMinAggregateOutputType | null
    _max: AlertConfigMaxAggregateOutputType | null
  }

  export type AlertConfigMinAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type AlertConfigMaxAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type AlertConfigCountAggregateOutputType = {
    key: number
    config: number
    updatedAt: number
    _all: number
  }


  export type AlertConfigMinAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type AlertConfigMaxAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type AlertConfigCountAggregateInputType = {
    key?: true
    config?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertConfig to aggregate.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertConfigs
    **/
    _count?: true | AlertConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertConfigMaxAggregateInputType
  }

  export type GetAlertConfigAggregateType<T extends AlertConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertConfig[P]>
      : GetScalarType<T[P], AggregateAlertConfig[P]>
  }




  export type AlertConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertConfigWhereInput
    orderBy?: AlertConfigOrderByWithAggregationInput | AlertConfigOrderByWithAggregationInput[]
    by: AlertConfigScalarFieldEnum[] | AlertConfigScalarFieldEnum
    having?: AlertConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertConfigCountAggregateInputType | true
    _min?: AlertConfigMinAggregateInputType
    _max?: AlertConfigMaxAggregateInputType
  }

  export type AlertConfigGroupByOutputType = {
    key: string
    config: JsonValue
    updatedAt: Date
    _count: AlertConfigCountAggregateOutputType | null
    _min: AlertConfigMinAggregateOutputType | null
    _max: AlertConfigMaxAggregateOutputType | null
  }

  type GetAlertConfigGroupByPayload<T extends AlertConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AlertConfigGroupByOutputType[P]>
        }
      >
    >


  export type AlertConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectScalar = {
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }

  export type AlertConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "config" | "updatedAt", ExtArgs["result"]["alertConfig"]>

  export type $AlertConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      config: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["alertConfig"]>
    composites: {}
  }

  type AlertConfigGetPayload<S extends boolean | null | undefined | AlertConfigDefaultArgs> = $Result.GetResult<Prisma.$AlertConfigPayload, S>

  type AlertConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AlertConfigCountAggregateInputType | true
    }

  export interface AlertConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertConfig'], meta: { name: 'AlertConfig' } }
    /**
     * Find zero or one AlertConfig that matches the filter.
     * @param {AlertConfigFindUniqueArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertConfigFindUniqueArgs>(args: SelectSubset<T, AlertConfigFindUniqueArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlertConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertConfigFindUniqueOrThrowArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindFirstArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertConfigFindFirstArgs>(args?: SelectSubset<T, AlertConfigFindFirstArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindFirstOrThrowArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlertConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertConfigs
     * const alertConfigs = await prisma.alertConfig.findMany()
     * 
     * // Get first 10 AlertConfigs
     * const alertConfigs = await prisma.alertConfig.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends AlertConfigFindManyArgs>(args?: SelectSubset<T, AlertConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlertConfig.
     * @param {AlertConfigCreateArgs} args - Arguments to create a AlertConfig.
     * @example
     * // Create one AlertConfig
     * const AlertConfig = await prisma.alertConfig.create({
     *   data: {
     *     // ... data to create a AlertConfig
     *   }
     * })
     * 
     */
    create<T extends AlertConfigCreateArgs>(args: SelectSubset<T, AlertConfigCreateArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlertConfigs.
     * @param {AlertConfigCreateManyArgs} args - Arguments to create many AlertConfigs.
     * @example
     * // Create many AlertConfigs
     * const alertConfig = await prisma.alertConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertConfigCreateManyArgs>(args?: SelectSubset<T, AlertConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertConfigs and returns the data saved in the database.
     * @param {AlertConfigCreateManyAndReturnArgs} args - Arguments to create many AlertConfigs.
     * @example
     * // Create many AlertConfigs
     * const alertConfig = await prisma.alertConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertConfigs and only return the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlertConfig.
     * @param {AlertConfigDeleteArgs} args - Arguments to delete one AlertConfig.
     * @example
     * // Delete one AlertConfig
     * const AlertConfig = await prisma.alertConfig.delete({
     *   where: {
     *     // ... filter to delete one AlertConfig
     *   }
     * })
     * 
     */
    delete<T extends AlertConfigDeleteArgs>(args: SelectSubset<T, AlertConfigDeleteArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlertConfig.
     * @param {AlertConfigUpdateArgs} args - Arguments to update one AlertConfig.
     * @example
     * // Update one AlertConfig
     * const alertConfig = await prisma.alertConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertConfigUpdateArgs>(args: SelectSubset<T, AlertConfigUpdateArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlertConfigs.
     * @param {AlertConfigDeleteManyArgs} args - Arguments to filter AlertConfigs to delete.
     * @example
     * // Delete a few AlertConfigs
     * const { count } = await prisma.alertConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertConfigDeleteManyArgs>(args?: SelectSubset<T, AlertConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertConfigs
     * const alertConfig = await prisma.alertConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertConfigUpdateManyArgs>(args: SelectSubset<T, AlertConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConfigs and returns the data updated in the database.
     * @param {AlertConfigUpdateManyAndReturnArgs} args - Arguments to update many AlertConfigs.
     * @example
     * // Update many AlertConfigs
     * const alertConfig = await prisma.alertConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertConfigs and only return the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlertConfig.
     * @param {AlertConfigUpsertArgs} args - Arguments to update or create a AlertConfig.
     * @example
     * // Update or create a AlertConfig
     * const alertConfig = await prisma.alertConfig.upsert({
     *   create: {
     *     // ... data to create a AlertConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertConfig we want to update
     *   }
     * })
     */
    upsert<T extends AlertConfigUpsertArgs>(args: SelectSubset<T, AlertConfigUpsertArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlertConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigCountArgs} args - Arguments to filter AlertConfigs to count.
     * @example
     * // Count the number of AlertConfigs
     * const count = await prisma.alertConfig.count({
     *   where: {
     *     // ... the filter for the AlertConfigs we want to count
     *   }
     * })
    **/
    count<T extends AlertConfigCountArgs>(
      args?: Subset<T, AlertConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertConfigAggregateArgs>(args: Subset<T, AlertConfigAggregateArgs>): Prisma.PrismaPromise<GetAlertConfigAggregateType<T>>

    /**
     * Group by AlertConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertConfigGroupByArgs['orderBy'] }
        : { orderBy?: AlertConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertConfig model
   */
  readonly fields: AlertConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertConfig model
   */
  interface AlertConfigFieldRefs {
    readonly key: FieldRef<"AlertConfig", 'String'>
    readonly config: FieldRef<"AlertConfig", 'Json'>
    readonly updatedAt: FieldRef<"AlertConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertConfig findUnique
   */
  export type AlertConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where: AlertConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig findUniqueOrThrow
   */
  export type AlertConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where: AlertConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig findFirst
   */
  export type AlertConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConfigs.
     */
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig findFirstOrThrow
   */
  export type AlertConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConfigs.
     */
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig findMany
   */
  export type AlertConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfigs to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig create
   */
  export type AlertConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AlertConfig.
     */
    data: XOR<AlertConfigCreateInput, AlertConfigUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig createMany
   */
  export type AlertConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertConfigs.
     */
    data: AlertConfigCreateManyInput | AlertConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertConfig createManyAndReturn
   */
  export type AlertConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AlertConfigs.
     */
    data: AlertConfigCreateManyInput | AlertConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertConfig update
   */
  export type AlertConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AlertConfig.
     */
    data: XOR<AlertConfigUpdateInput, AlertConfigUncheckedUpdateInput>
    /**
     * Choose, which AlertConfig to update.
     */
    where: AlertConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig updateMany
   */
  export type AlertConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertConfigs.
     */
    data: XOR<AlertConfigUpdateManyMutationInput, AlertConfigUncheckedUpdateManyInput>
    /**
     * Filter which AlertConfigs to update
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to update.
     */
    limit?: number
  }

  /**
   * AlertConfig updateManyAndReturn
   */
  export type AlertConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data used to update AlertConfigs.
     */
    data: XOR<AlertConfigUpdateManyMutationInput, AlertConfigUncheckedUpdateManyInput>
    /**
     * Filter which AlertConfigs to update
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to update.
     */
    limit?: number
  }

  /**
   * AlertConfig upsert
   */
  export type AlertConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AlertConfig to update in case it exists.
     */
    where: AlertConfigWhereUniqueInput
    /**
     * In case the AlertConfig found by the `where` argument doesn't exist, create a new AlertConfig with this data.
     */
    create: XOR<AlertConfigCreateInput, AlertConfigUncheckedCreateInput>
    /**
     * In case the AlertConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertConfigUpdateInput, AlertConfigUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig delete
   */
  export type AlertConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter which AlertConfig to delete.
     */
    where: AlertConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AlertConfig deleteMany
   */
  export type AlertConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertConfigs to delete
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to delete.
     */
    limit?: number
  }

  /**
   * AlertConfig without action
   */
  export type AlertConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
  }


  /**
   * Model StatHoliday
   */

  export type AggregateStatHoliday = {
    _count: StatHolidayCountAggregateOutputType | null
    _min: StatHolidayMinAggregateOutputType | null
    _max: StatHolidayMaxAggregateOutputType | null
  }

  export type StatHolidayMinAggregateOutputType = {
    id: string | null
    date: Date | null
    name: string | null
    province: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatHolidayMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    name: string | null
    province: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatHolidayCountAggregateOutputType = {
    id: number
    date: number
    name: number
    province: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatHolidayMinAggregateInputType = {
    id?: true
    date?: true
    name?: true
    province?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatHolidayMaxAggregateInputType = {
    id?: true
    date?: true
    name?: true
    province?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatHolidayCountAggregateInputType = {
    id?: true
    date?: true
    name?: true
    province?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatHolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatHoliday to aggregate.
     */
    where?: StatHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatHolidays to fetch.
     */
    orderBy?: StatHolidayOrderByWithRelationInput | StatHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatHolidays
    **/
    _count?: true | StatHolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatHolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatHolidayMaxAggregateInputType
  }

  export type GetStatHolidayAggregateType<T extends StatHolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateStatHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatHoliday[P]>
      : GetScalarType<T[P], AggregateStatHoliday[P]>
  }




  export type StatHolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatHolidayWhereInput
    orderBy?: StatHolidayOrderByWithAggregationInput | StatHolidayOrderByWithAggregationInput[]
    by: StatHolidayScalarFieldEnum[] | StatHolidayScalarFieldEnum
    having?: StatHolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatHolidayCountAggregateInputType | true
    _min?: StatHolidayMinAggregateInputType
    _max?: StatHolidayMaxAggregateInputType
  }

  export type StatHolidayGroupByOutputType = {
    id: string
    date: Date
    name: string
    province: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StatHolidayCountAggregateOutputType | null
    _min: StatHolidayMinAggregateOutputType | null
    _max: StatHolidayMaxAggregateOutputType | null
  }

  type GetStatHolidayGroupByPayload<T extends StatHolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatHolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatHolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatHolidayGroupByOutputType[P]>
            : GetScalarType<T[P], StatHolidayGroupByOutputType[P]>
        }
      >
    >


  export type StatHolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    province?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statHoliday"]>

  export type StatHolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    province?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statHoliday"]>

  export type StatHolidaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    province?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statHoliday"]>

  export type StatHolidaySelectScalar = {
    id?: boolean
    date?: boolean
    name?: boolean
    province?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatHolidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "name" | "province" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["statHoliday"]>

  export type $StatHolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatHoliday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      name: string
      province: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statHoliday"]>
    composites: {}
  }

  type StatHolidayGetPayload<S extends boolean | null | undefined | StatHolidayDefaultArgs> = $Result.GetResult<Prisma.$StatHolidayPayload, S>

  type StatHolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatHolidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: StatHolidayCountAggregateInputType | true
    }

  export interface StatHolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatHoliday'], meta: { name: 'StatHoliday' } }
    /**
     * Find zero or one StatHoliday that matches the filter.
     * @param {StatHolidayFindUniqueArgs} args - Arguments to find a StatHoliday
     * @example
     * // Get one StatHoliday
     * const statHoliday = await prisma.statHoliday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatHolidayFindUniqueArgs>(args: SelectSubset<T, StatHolidayFindUniqueArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatHoliday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatHolidayFindUniqueOrThrowArgs} args - Arguments to find a StatHoliday
     * @example
     * // Get one StatHoliday
     * const statHoliday = await prisma.statHoliday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatHolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, StatHolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatHoliday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayFindFirstArgs} args - Arguments to find a StatHoliday
     * @example
     * // Get one StatHoliday
     * const statHoliday = await prisma.statHoliday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatHolidayFindFirstArgs>(args?: SelectSubset<T, StatHolidayFindFirstArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatHoliday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayFindFirstOrThrowArgs} args - Arguments to find a StatHoliday
     * @example
     * // Get one StatHoliday
     * const statHoliday = await prisma.statHoliday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatHolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, StatHolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatHolidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatHolidays
     * const statHolidays = await prisma.statHoliday.findMany()
     * 
     * // Get first 10 StatHolidays
     * const statHolidays = await prisma.statHoliday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statHolidayWithIdOnly = await prisma.statHoliday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatHolidayFindManyArgs>(args?: SelectSubset<T, StatHolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatHoliday.
     * @param {StatHolidayCreateArgs} args - Arguments to create a StatHoliday.
     * @example
     * // Create one StatHoliday
     * const StatHoliday = await prisma.statHoliday.create({
     *   data: {
     *     // ... data to create a StatHoliday
     *   }
     * })
     * 
     */
    create<T extends StatHolidayCreateArgs>(args: SelectSubset<T, StatHolidayCreateArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatHolidays.
     * @param {StatHolidayCreateManyArgs} args - Arguments to create many StatHolidays.
     * @example
     * // Create many StatHolidays
     * const statHoliday = await prisma.statHoliday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatHolidayCreateManyArgs>(args?: SelectSubset<T, StatHolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatHolidays and returns the data saved in the database.
     * @param {StatHolidayCreateManyAndReturnArgs} args - Arguments to create many StatHolidays.
     * @example
     * // Create many StatHolidays
     * const statHoliday = await prisma.statHoliday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatHolidays and only return the `id`
     * const statHolidayWithIdOnly = await prisma.statHoliday.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatHolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, StatHolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StatHoliday.
     * @param {StatHolidayDeleteArgs} args - Arguments to delete one StatHoliday.
     * @example
     * // Delete one StatHoliday
     * const StatHoliday = await prisma.statHoliday.delete({
     *   where: {
     *     // ... filter to delete one StatHoliday
     *   }
     * })
     * 
     */
    delete<T extends StatHolidayDeleteArgs>(args: SelectSubset<T, StatHolidayDeleteArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatHoliday.
     * @param {StatHolidayUpdateArgs} args - Arguments to update one StatHoliday.
     * @example
     * // Update one StatHoliday
     * const statHoliday = await prisma.statHoliday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatHolidayUpdateArgs>(args: SelectSubset<T, StatHolidayUpdateArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatHolidays.
     * @param {StatHolidayDeleteManyArgs} args - Arguments to filter StatHolidays to delete.
     * @example
     * // Delete a few StatHolidays
     * const { count } = await prisma.statHoliday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatHolidayDeleteManyArgs>(args?: SelectSubset<T, StatHolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatHolidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatHolidays
     * const statHoliday = await prisma.statHoliday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatHolidayUpdateManyArgs>(args: SelectSubset<T, StatHolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatHolidays and returns the data updated in the database.
     * @param {StatHolidayUpdateManyAndReturnArgs} args - Arguments to update many StatHolidays.
     * @example
     * // Update many StatHolidays
     * const statHoliday = await prisma.statHoliday.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StatHolidays and only return the `id`
     * const statHolidayWithIdOnly = await prisma.statHoliday.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatHolidayUpdateManyAndReturnArgs>(args: SelectSubset<T, StatHolidayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StatHoliday.
     * @param {StatHolidayUpsertArgs} args - Arguments to update or create a StatHoliday.
     * @example
     * // Update or create a StatHoliday
     * const statHoliday = await prisma.statHoliday.upsert({
     *   create: {
     *     // ... data to create a StatHoliday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatHoliday we want to update
     *   }
     * })
     */
    upsert<T extends StatHolidayUpsertArgs>(args: SelectSubset<T, StatHolidayUpsertArgs<ExtArgs>>): Prisma__StatHolidayClient<$Result.GetResult<Prisma.$StatHolidayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatHolidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayCountArgs} args - Arguments to filter StatHolidays to count.
     * @example
     * // Count the number of StatHolidays
     * const count = await prisma.statHoliday.count({
     *   where: {
     *     // ... the filter for the StatHolidays we want to count
     *   }
     * })
    **/
    count<T extends StatHolidayCountArgs>(
      args?: Subset<T, StatHolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatHolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatHoliday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatHolidayAggregateArgs>(args: Subset<T, StatHolidayAggregateArgs>): Prisma.PrismaPromise<GetStatHolidayAggregateType<T>>

    /**
     * Group by StatHoliday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatHolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatHolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatHolidayGroupByArgs['orderBy'] }
        : { orderBy?: StatHolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatHolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatHoliday model
   */
  readonly fields: StatHolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatHoliday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatHolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatHoliday model
   */
  interface StatHolidayFieldRefs {
    readonly id: FieldRef<"StatHoliday", 'String'>
    readonly date: FieldRef<"StatHoliday", 'DateTime'>
    readonly name: FieldRef<"StatHoliday", 'String'>
    readonly province: FieldRef<"StatHoliday", 'String'>
    readonly isActive: FieldRef<"StatHoliday", 'Boolean'>
    readonly createdAt: FieldRef<"StatHoliday", 'DateTime'>
    readonly updatedAt: FieldRef<"StatHoliday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatHoliday findUnique
   */
  export type StatHolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter, which StatHoliday to fetch.
     */
    where: StatHolidayWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday findUniqueOrThrow
   */
  export type StatHolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter, which StatHoliday to fetch.
     */
    where: StatHolidayWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday findFirst
   */
  export type StatHolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter, which StatHoliday to fetch.
     */
    where?: StatHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatHolidays to fetch.
     */
    orderBy?: StatHolidayOrderByWithRelationInput | StatHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatHolidays.
     */
    cursor?: StatHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatHolidays.
     */
    distinct?: StatHolidayScalarFieldEnum | StatHolidayScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday findFirstOrThrow
   */
  export type StatHolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter, which StatHoliday to fetch.
     */
    where?: StatHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatHolidays to fetch.
     */
    orderBy?: StatHolidayOrderByWithRelationInput | StatHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatHolidays.
     */
    cursor?: StatHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatHolidays.
     */
    distinct?: StatHolidayScalarFieldEnum | StatHolidayScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday findMany
   */
  export type StatHolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter, which StatHolidays to fetch.
     */
    where?: StatHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatHolidays to fetch.
     */
    orderBy?: StatHolidayOrderByWithRelationInput | StatHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatHolidays.
     */
    cursor?: StatHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatHolidays.
     */
    skip?: number
    distinct?: StatHolidayScalarFieldEnum | StatHolidayScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday create
   */
  export type StatHolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * The data needed to create a StatHoliday.
     */
    data: XOR<StatHolidayCreateInput, StatHolidayUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday createMany
   */
  export type StatHolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatHolidays.
     */
    data: StatHolidayCreateManyInput | StatHolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatHoliday createManyAndReturn
   */
  export type StatHolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * The data used to create many StatHolidays.
     */
    data: StatHolidayCreateManyInput | StatHolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatHoliday update
   */
  export type StatHolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * The data needed to update a StatHoliday.
     */
    data: XOR<StatHolidayUpdateInput, StatHolidayUncheckedUpdateInput>
    /**
     * Choose, which StatHoliday to update.
     */
    where: StatHolidayWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday updateMany
   */
  export type StatHolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatHolidays.
     */
    data: XOR<StatHolidayUpdateManyMutationInput, StatHolidayUncheckedUpdateManyInput>
    /**
     * Filter which StatHolidays to update
     */
    where?: StatHolidayWhereInput
    /**
     * Limit how many StatHolidays to update.
     */
    limit?: number
  }

  /**
   * StatHoliday updateManyAndReturn
   */
  export type StatHolidayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * The data used to update StatHolidays.
     */
    data: XOR<StatHolidayUpdateManyMutationInput, StatHolidayUncheckedUpdateManyInput>
    /**
     * Filter which StatHolidays to update
     */
    where?: StatHolidayWhereInput
    /**
     * Limit how many StatHolidays to update.
     */
    limit?: number
  }

  /**
   * StatHoliday upsert
   */
  export type StatHolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * The filter to search for the StatHoliday to update in case it exists.
     */
    where: StatHolidayWhereUniqueInput
    /**
     * In case the StatHoliday found by the `where` argument doesn't exist, create a new StatHoliday with this data.
     */
    create: XOR<StatHolidayCreateInput, StatHolidayUncheckedCreateInput>
    /**
     * In case the StatHoliday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatHolidayUpdateInput, StatHolidayUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday delete
   */
  export type StatHolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
    /**
     * Filter which StatHoliday to delete.
     */
    where: StatHolidayWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * StatHoliday deleteMany
   */
  export type StatHolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatHolidays to delete
     */
    where?: StatHolidayWhereInput
    /**
     * Limit how many StatHolidays to delete.
     */
    limit?: number
  }

  /**
   * StatHoliday without action
   */
  export type StatHolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatHoliday
     */
    select?: StatHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatHoliday
     */
    omit?: StatHolidayOmit<ExtArgs> | null
  }


  /**
   * Model QualificationType
   */

  export type AggregateQualificationType = {
    _count: QualificationTypeCountAggregateOutputType | null
    _avg: QualificationTypeAvgAggregateOutputType | null
    _sum: QualificationTypeSumAggregateOutputType | null
    _min: QualificationTypeMinAggregateOutputType | null
    _max: QualificationTypeMaxAggregateOutputType | null
  }

  export type QualificationTypeAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type QualificationTypeSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type QualificationTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    canReceiveLockup: boolean | null
    displayOrder: number | null
    tagId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualificationTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    canReceiveLockup: boolean | null
    displayOrder: number | null
    tagId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualificationTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    canReceiveLockup: number
    displayOrder: number
    tagId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QualificationTypeAvgAggregateInputType = {
    displayOrder?: true
  }

  export type QualificationTypeSumAggregateInputType = {
    displayOrder?: true
  }

  export type QualificationTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    canReceiveLockup?: true
    displayOrder?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualificationTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    canReceiveLockup?: true
    displayOrder?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualificationTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    canReceiveLockup?: true
    displayOrder?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QualificationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualificationType to aggregate.
     */
    where?: QualificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualificationTypes to fetch.
     */
    orderBy?: QualificationTypeOrderByWithRelationInput | QualificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualificationTypes
    **/
    _count?: true | QualificationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualificationTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualificationTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualificationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualificationTypeMaxAggregateInputType
  }

  export type GetQualificationTypeAggregateType<T extends QualificationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateQualificationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualificationType[P]>
      : GetScalarType<T[P], AggregateQualificationType[P]>
  }




  export type QualificationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualificationTypeWhereInput
    orderBy?: QualificationTypeOrderByWithAggregationInput | QualificationTypeOrderByWithAggregationInput[]
    by: QualificationTypeScalarFieldEnum[] | QualificationTypeScalarFieldEnum
    having?: QualificationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualificationTypeCountAggregateInputType | true
    _avg?: QualificationTypeAvgAggregateInputType
    _sum?: QualificationTypeSumAggregateInputType
    _min?: QualificationTypeMinAggregateInputType
    _max?: QualificationTypeMaxAggregateInputType
  }

  export type QualificationTypeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    canReceiveLockup: boolean
    displayOrder: number
    tagId: string | null
    createdAt: Date
    updatedAt: Date
    _count: QualificationTypeCountAggregateOutputType | null
    _avg: QualificationTypeAvgAggregateOutputType | null
    _sum: QualificationTypeSumAggregateOutputType | null
    _min: QualificationTypeMinAggregateOutputType | null
    _max: QualificationTypeMaxAggregateOutputType | null
  }

  type GetQualificationTypeGroupByPayload<T extends QualificationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualificationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualificationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualificationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], QualificationTypeGroupByOutputType[P]>
        }
      >
    >


  export type QualificationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    canReceiveLockup?: boolean
    displayOrder?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberQualifications?: boolean | QualificationType$memberQualificationsArgs<ExtArgs>
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
    _count?: boolean | QualificationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualificationType"]>

  export type QualificationTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    canReceiveLockup?: boolean
    displayOrder?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
  }, ExtArgs["result"]["qualificationType"]>

  export type QualificationTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    canReceiveLockup?: boolean
    displayOrder?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
  }, ExtArgs["result"]["qualificationType"]>

  export type QualificationTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    canReceiveLockup?: boolean
    displayOrder?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QualificationTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "canReceiveLockup" | "displayOrder" | "tagId" | "createdAt" | "updatedAt", ExtArgs["result"]["qualificationType"]>
  export type QualificationTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberQualifications?: boolean | QualificationType$memberQualificationsArgs<ExtArgs>
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
    _count?: boolean | QualificationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QualificationTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
  }
  export type QualificationTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | QualificationType$tagArgs<ExtArgs>
  }

  export type $QualificationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualificationType"
    objects: {
      memberQualifications: Prisma.$MemberQualificationPayload<ExtArgs>[]
      tag: Prisma.$TagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      canReceiveLockup: boolean
      displayOrder: number
      tagId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qualificationType"]>
    composites: {}
  }

  type QualificationTypeGetPayload<S extends boolean | null | undefined | QualificationTypeDefaultArgs> = $Result.GetResult<Prisma.$QualificationTypePayload, S>

  type QualificationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QualificationTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: QualificationTypeCountAggregateInputType | true
    }

  export interface QualificationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualificationType'], meta: { name: 'QualificationType' } }
    /**
     * Find zero or one QualificationType that matches the filter.
     * @param {QualificationTypeFindUniqueArgs} args - Arguments to find a QualificationType
     * @example
     * // Get one QualificationType
     * const qualificationType = await prisma.qualificationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualificationTypeFindUniqueArgs>(args: SelectSubset<T, QualificationTypeFindUniqueArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QualificationType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QualificationTypeFindUniqueOrThrowArgs} args - Arguments to find a QualificationType
     * @example
     * // Get one QualificationType
     * const qualificationType = await prisma.qualificationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualificationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, QualificationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualificationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeFindFirstArgs} args - Arguments to find a QualificationType
     * @example
     * // Get one QualificationType
     * const qualificationType = await prisma.qualificationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualificationTypeFindFirstArgs>(args?: SelectSubset<T, QualificationTypeFindFirstArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualificationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeFindFirstOrThrowArgs} args - Arguments to find a QualificationType
     * @example
     * // Get one QualificationType
     * const qualificationType = await prisma.qualificationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualificationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, QualificationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QualificationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualificationTypes
     * const qualificationTypes = await prisma.qualificationType.findMany()
     * 
     * // Get first 10 QualificationTypes
     * const qualificationTypes = await prisma.qualificationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualificationTypeWithIdOnly = await prisma.qualificationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualificationTypeFindManyArgs>(args?: SelectSubset<T, QualificationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QualificationType.
     * @param {QualificationTypeCreateArgs} args - Arguments to create a QualificationType.
     * @example
     * // Create one QualificationType
     * const QualificationType = await prisma.qualificationType.create({
     *   data: {
     *     // ... data to create a QualificationType
     *   }
     * })
     * 
     */
    create<T extends QualificationTypeCreateArgs>(args: SelectSubset<T, QualificationTypeCreateArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QualificationTypes.
     * @param {QualificationTypeCreateManyArgs} args - Arguments to create many QualificationTypes.
     * @example
     * // Create many QualificationTypes
     * const qualificationType = await prisma.qualificationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualificationTypeCreateManyArgs>(args?: SelectSubset<T, QualificationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualificationTypes and returns the data saved in the database.
     * @param {QualificationTypeCreateManyAndReturnArgs} args - Arguments to create many QualificationTypes.
     * @example
     * // Create many QualificationTypes
     * const qualificationType = await prisma.qualificationType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualificationTypes and only return the `id`
     * const qualificationTypeWithIdOnly = await prisma.qualificationType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualificationTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, QualificationTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QualificationType.
     * @param {QualificationTypeDeleteArgs} args - Arguments to delete one QualificationType.
     * @example
     * // Delete one QualificationType
     * const QualificationType = await prisma.qualificationType.delete({
     *   where: {
     *     // ... filter to delete one QualificationType
     *   }
     * })
     * 
     */
    delete<T extends QualificationTypeDeleteArgs>(args: SelectSubset<T, QualificationTypeDeleteArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QualificationType.
     * @param {QualificationTypeUpdateArgs} args - Arguments to update one QualificationType.
     * @example
     * // Update one QualificationType
     * const qualificationType = await prisma.qualificationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualificationTypeUpdateArgs>(args: SelectSubset<T, QualificationTypeUpdateArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QualificationTypes.
     * @param {QualificationTypeDeleteManyArgs} args - Arguments to filter QualificationTypes to delete.
     * @example
     * // Delete a few QualificationTypes
     * const { count } = await prisma.qualificationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualificationTypeDeleteManyArgs>(args?: SelectSubset<T, QualificationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualificationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualificationTypes
     * const qualificationType = await prisma.qualificationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualificationTypeUpdateManyArgs>(args: SelectSubset<T, QualificationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualificationTypes and returns the data updated in the database.
     * @param {QualificationTypeUpdateManyAndReturnArgs} args - Arguments to update many QualificationTypes.
     * @example
     * // Update many QualificationTypes
     * const qualificationType = await prisma.qualificationType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QualificationTypes and only return the `id`
     * const qualificationTypeWithIdOnly = await prisma.qualificationType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QualificationTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, QualificationTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QualificationType.
     * @param {QualificationTypeUpsertArgs} args - Arguments to update or create a QualificationType.
     * @example
     * // Update or create a QualificationType
     * const qualificationType = await prisma.qualificationType.upsert({
     *   create: {
     *     // ... data to create a QualificationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualificationType we want to update
     *   }
     * })
     */
    upsert<T extends QualificationTypeUpsertArgs>(args: SelectSubset<T, QualificationTypeUpsertArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QualificationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeCountArgs} args - Arguments to filter QualificationTypes to count.
     * @example
     * // Count the number of QualificationTypes
     * const count = await prisma.qualificationType.count({
     *   where: {
     *     // ... the filter for the QualificationTypes we want to count
     *   }
     * })
    **/
    count<T extends QualificationTypeCountArgs>(
      args?: Subset<T, QualificationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualificationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualificationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualificationTypeAggregateArgs>(args: Subset<T, QualificationTypeAggregateArgs>): Prisma.PrismaPromise<GetQualificationTypeAggregateType<T>>

    /**
     * Group by QualificationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualificationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualificationTypeGroupByArgs['orderBy'] }
        : { orderBy?: QualificationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualificationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualificationType model
   */
  readonly fields: QualificationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualificationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualificationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberQualifications<T extends QualificationType$memberQualificationsArgs<ExtArgs> = {}>(args?: Subset<T, QualificationType$memberQualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tag<T extends QualificationType$tagArgs<ExtArgs> = {}>(args?: Subset<T, QualificationType$tagArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualificationType model
   */
  interface QualificationTypeFieldRefs {
    readonly id: FieldRef<"QualificationType", 'String'>
    readonly code: FieldRef<"QualificationType", 'String'>
    readonly name: FieldRef<"QualificationType", 'String'>
    readonly description: FieldRef<"QualificationType", 'String'>
    readonly canReceiveLockup: FieldRef<"QualificationType", 'Boolean'>
    readonly displayOrder: FieldRef<"QualificationType", 'Int'>
    readonly tagId: FieldRef<"QualificationType", 'String'>
    readonly createdAt: FieldRef<"QualificationType", 'DateTime'>
    readonly updatedAt: FieldRef<"QualificationType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QualificationType findUnique
   */
  export type QualificationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which QualificationType to fetch.
     */
    where: QualificationTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType findUniqueOrThrow
   */
  export type QualificationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which QualificationType to fetch.
     */
    where: QualificationTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType findFirst
   */
  export type QualificationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which QualificationType to fetch.
     */
    where?: QualificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualificationTypes to fetch.
     */
    orderBy?: QualificationTypeOrderByWithRelationInput | QualificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualificationTypes.
     */
    cursor?: QualificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualificationTypes.
     */
    distinct?: QualificationTypeScalarFieldEnum | QualificationTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType findFirstOrThrow
   */
  export type QualificationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which QualificationType to fetch.
     */
    where?: QualificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualificationTypes to fetch.
     */
    orderBy?: QualificationTypeOrderByWithRelationInput | QualificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualificationTypes.
     */
    cursor?: QualificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualificationTypes.
     */
    distinct?: QualificationTypeScalarFieldEnum | QualificationTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType findMany
   */
  export type QualificationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which QualificationTypes to fetch.
     */
    where?: QualificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualificationTypes to fetch.
     */
    orderBy?: QualificationTypeOrderByWithRelationInput | QualificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualificationTypes.
     */
    cursor?: QualificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualificationTypes.
     */
    skip?: number
    distinct?: QualificationTypeScalarFieldEnum | QualificationTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType create
   */
  export type QualificationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a QualificationType.
     */
    data: XOR<QualificationTypeCreateInput, QualificationTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType createMany
   */
  export type QualificationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualificationTypes.
     */
    data: QualificationTypeCreateManyInput | QualificationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualificationType createManyAndReturn
   */
  export type QualificationTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * The data used to create many QualificationTypes.
     */
    data: QualificationTypeCreateManyInput | QualificationTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualificationType update
   */
  export type QualificationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a QualificationType.
     */
    data: XOR<QualificationTypeUpdateInput, QualificationTypeUncheckedUpdateInput>
    /**
     * Choose, which QualificationType to update.
     */
    where: QualificationTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType updateMany
   */
  export type QualificationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualificationTypes.
     */
    data: XOR<QualificationTypeUpdateManyMutationInput, QualificationTypeUncheckedUpdateManyInput>
    /**
     * Filter which QualificationTypes to update
     */
    where?: QualificationTypeWhereInput
    /**
     * Limit how many QualificationTypes to update.
     */
    limit?: number
  }

  /**
   * QualificationType updateManyAndReturn
   */
  export type QualificationTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * The data used to update QualificationTypes.
     */
    data: XOR<QualificationTypeUpdateManyMutationInput, QualificationTypeUncheckedUpdateManyInput>
    /**
     * Filter which QualificationTypes to update
     */
    where?: QualificationTypeWhereInput
    /**
     * Limit how many QualificationTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualificationType upsert
   */
  export type QualificationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the QualificationType to update in case it exists.
     */
    where: QualificationTypeWhereUniqueInput
    /**
     * In case the QualificationType found by the `where` argument doesn't exist, create a new QualificationType with this data.
     */
    create: XOR<QualificationTypeCreateInput, QualificationTypeUncheckedCreateInput>
    /**
     * In case the QualificationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualificationTypeUpdateInput, QualificationTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType delete
   */
  export type QualificationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
    /**
     * Filter which QualificationType to delete.
     */
    where: QualificationTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QualificationType deleteMany
   */
  export type QualificationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualificationTypes to delete
     */
    where?: QualificationTypeWhereInput
    /**
     * Limit how many QualificationTypes to delete.
     */
    limit?: number
  }

  /**
   * QualificationType.memberQualifications
   */
  export type QualificationType$memberQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    where?: MemberQualificationWhereInput
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    cursor?: MemberQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
  }

  /**
   * QualificationType.tag
   */
  export type QualificationType$tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
  }

  /**
   * QualificationType without action
   */
  export type QualificationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationType
     */
    select?: QualificationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualificationType
     */
    omit?: QualificationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationTypeInclude<ExtArgs> | null
  }


  /**
   * Model MemberQualification
   */

  export type AggregateMemberQualification = {
    _count: MemberQualificationCountAggregateOutputType | null
    _min: MemberQualificationMinAggregateOutputType | null
    _max: MemberQualificationMaxAggregateOutputType | null
  }

  export type MemberQualificationMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    qualificationTypeId: string | null
    status: string | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    revokedBy: string | null
    revokeReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberQualificationMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    qualificationTypeId: string | null
    status: string | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    revokedBy: string | null
    revokeReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberQualificationCountAggregateOutputType = {
    id: number
    memberId: number
    qualificationTypeId: number
    status: number
    grantedAt: number
    grantedBy: number
    expiresAt: number
    revokedAt: number
    revokedBy: number
    revokeReason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberQualificationMinAggregateInputType = {
    id?: true
    memberId?: true
    qualificationTypeId?: true
    status?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
    revokedAt?: true
    revokedBy?: true
    revokeReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberQualificationMaxAggregateInputType = {
    id?: true
    memberId?: true
    qualificationTypeId?: true
    status?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
    revokedAt?: true
    revokedBy?: true
    revokeReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberQualificationCountAggregateInputType = {
    id?: true
    memberId?: true
    qualificationTypeId?: true
    status?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
    revokedAt?: true
    revokedBy?: true
    revokeReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberQualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberQualification to aggregate.
     */
    where?: MemberQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberQualifications to fetch.
     */
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberQualifications
    **/
    _count?: true | MemberQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberQualificationMaxAggregateInputType
  }

  export type GetMemberQualificationAggregateType<T extends MemberQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberQualification[P]>
      : GetScalarType<T[P], AggregateMemberQualification[P]>
  }




  export type MemberQualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberQualificationWhereInput
    orderBy?: MemberQualificationOrderByWithAggregationInput | MemberQualificationOrderByWithAggregationInput[]
    by: MemberQualificationScalarFieldEnum[] | MemberQualificationScalarFieldEnum
    having?: MemberQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberQualificationCountAggregateInputType | true
    _min?: MemberQualificationMinAggregateInputType
    _max?: MemberQualificationMaxAggregateInputType
  }

  export type MemberQualificationGroupByOutputType = {
    id: string
    memberId: string
    qualificationTypeId: string
    status: string
    grantedAt: Date
    grantedBy: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    revokedBy: string | null
    revokeReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MemberQualificationCountAggregateOutputType | null
    _min: MemberQualificationMinAggregateOutputType | null
    _max: MemberQualificationMaxAggregateOutputType | null
  }

  type GetMemberQualificationGroupByPayload<T extends MemberQualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], MemberQualificationGroupByOutputType[P]>
        }
      >
    >


  export type MemberQualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    qualificationTypeId?: boolean
    status?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokeReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["memberQualification"]>

  export type MemberQualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    qualificationTypeId?: boolean
    status?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokeReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["memberQualification"]>

  export type MemberQualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    qualificationTypeId?: boolean
    status?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokeReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["memberQualification"]>

  export type MemberQualificationSelectScalar = {
    id?: boolean
    memberId?: boolean
    qualificationTypeId?: boolean
    status?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokeReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberQualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "qualificationTypeId" | "status" | "grantedAt" | "grantedBy" | "expiresAt" | "revokedAt" | "revokedBy" | "revokeReason" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["memberQualification"]>
  export type MemberQualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }
  export type MemberQualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }
  export type MemberQualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    qualificationType?: boolean | QualificationTypeDefaultArgs<ExtArgs>
    grantedByAdmin?: boolean | MemberQualification$grantedByAdminArgs<ExtArgs>
    revokedByAdmin?: boolean | MemberQualification$revokedByAdminArgs<ExtArgs>
  }

  export type $MemberQualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberQualification"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      qualificationType: Prisma.$QualificationTypePayload<ExtArgs>
      grantedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      revokedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      qualificationTypeId: string
      status: string
      grantedAt: Date
      grantedBy: string | null
      expiresAt: Date | null
      revokedAt: Date | null
      revokedBy: string | null
      revokeReason: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["memberQualification"]>
    composites: {}
  }

  type MemberQualificationGetPayload<S extends boolean | null | undefined | MemberQualificationDefaultArgs> = $Result.GetResult<Prisma.$MemberQualificationPayload, S>

  type MemberQualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberQualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MemberQualificationCountAggregateInputType | true
    }

  export interface MemberQualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberQualification'], meta: { name: 'MemberQualification' } }
    /**
     * Find zero or one MemberQualification that matches the filter.
     * @param {MemberQualificationFindUniqueArgs} args - Arguments to find a MemberQualification
     * @example
     * // Get one MemberQualification
     * const memberQualification = await prisma.memberQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberQualificationFindUniqueArgs>(args: SelectSubset<T, MemberQualificationFindUniqueArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberQualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberQualificationFindUniqueOrThrowArgs} args - Arguments to find a MemberQualification
     * @example
     * // Get one MemberQualification
     * const memberQualification = await prisma.memberQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberQualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberQualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationFindFirstArgs} args - Arguments to find a MemberQualification
     * @example
     * // Get one MemberQualification
     * const memberQualification = await prisma.memberQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberQualificationFindFirstArgs>(args?: SelectSubset<T, MemberQualificationFindFirstArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberQualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationFindFirstOrThrowArgs} args - Arguments to find a MemberQualification
     * @example
     * // Get one MemberQualification
     * const memberQualification = await prisma.memberQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberQualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberQualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberQualifications
     * const memberQualifications = await prisma.memberQualification.findMany()
     * 
     * // Get first 10 MemberQualifications
     * const memberQualifications = await prisma.memberQualification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberQualificationWithIdOnly = await prisma.memberQualification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberQualificationFindManyArgs>(args?: SelectSubset<T, MemberQualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberQualification.
     * @param {MemberQualificationCreateArgs} args - Arguments to create a MemberQualification.
     * @example
     * // Create one MemberQualification
     * const MemberQualification = await prisma.memberQualification.create({
     *   data: {
     *     // ... data to create a MemberQualification
     *   }
     * })
     * 
     */
    create<T extends MemberQualificationCreateArgs>(args: SelectSubset<T, MemberQualificationCreateArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberQualifications.
     * @param {MemberQualificationCreateManyArgs} args - Arguments to create many MemberQualifications.
     * @example
     * // Create many MemberQualifications
     * const memberQualification = await prisma.memberQualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberQualificationCreateManyArgs>(args?: SelectSubset<T, MemberQualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberQualifications and returns the data saved in the database.
     * @param {MemberQualificationCreateManyAndReturnArgs} args - Arguments to create many MemberQualifications.
     * @example
     * // Create many MemberQualifications
     * const memberQualification = await prisma.memberQualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberQualifications and only return the `id`
     * const memberQualificationWithIdOnly = await prisma.memberQualification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberQualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberQualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberQualification.
     * @param {MemberQualificationDeleteArgs} args - Arguments to delete one MemberQualification.
     * @example
     * // Delete one MemberQualification
     * const MemberQualification = await prisma.memberQualification.delete({
     *   where: {
     *     // ... filter to delete one MemberQualification
     *   }
     * })
     * 
     */
    delete<T extends MemberQualificationDeleteArgs>(args: SelectSubset<T, MemberQualificationDeleteArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberQualification.
     * @param {MemberQualificationUpdateArgs} args - Arguments to update one MemberQualification.
     * @example
     * // Update one MemberQualification
     * const memberQualification = await prisma.memberQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberQualificationUpdateArgs>(args: SelectSubset<T, MemberQualificationUpdateArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberQualifications.
     * @param {MemberQualificationDeleteManyArgs} args - Arguments to filter MemberQualifications to delete.
     * @example
     * // Delete a few MemberQualifications
     * const { count } = await prisma.memberQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberQualificationDeleteManyArgs>(args?: SelectSubset<T, MemberQualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberQualifications
     * const memberQualification = await prisma.memberQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberQualificationUpdateManyArgs>(args: SelectSubset<T, MemberQualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberQualifications and returns the data updated in the database.
     * @param {MemberQualificationUpdateManyAndReturnArgs} args - Arguments to update many MemberQualifications.
     * @example
     * // Update many MemberQualifications
     * const memberQualification = await prisma.memberQualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberQualifications and only return the `id`
     * const memberQualificationWithIdOnly = await prisma.memberQualification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberQualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberQualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberQualification.
     * @param {MemberQualificationUpsertArgs} args - Arguments to update or create a MemberQualification.
     * @example
     * // Update or create a MemberQualification
     * const memberQualification = await prisma.memberQualification.upsert({
     *   create: {
     *     // ... data to create a MemberQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberQualification we want to update
     *   }
     * })
     */
    upsert<T extends MemberQualificationUpsertArgs>(args: SelectSubset<T, MemberQualificationUpsertArgs<ExtArgs>>): Prisma__MemberQualificationClient<$Result.GetResult<Prisma.$MemberQualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationCountArgs} args - Arguments to filter MemberQualifications to count.
     * @example
     * // Count the number of MemberQualifications
     * const count = await prisma.memberQualification.count({
     *   where: {
     *     // ... the filter for the MemberQualifications we want to count
     *   }
     * })
    **/
    count<T extends MemberQualificationCountArgs>(
      args?: Subset<T, MemberQualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberQualificationAggregateArgs>(args: Subset<T, MemberQualificationAggregateArgs>): Prisma.PrismaPromise<GetMemberQualificationAggregateType<T>>

    /**
     * Group by MemberQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberQualificationGroupByArgs['orderBy'] }
        : { orderBy?: MemberQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberQualification model
   */
  readonly fields: MemberQualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberQualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qualificationType<T extends QualificationTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualificationTypeDefaultArgs<ExtArgs>>): Prisma__QualificationTypeClient<$Result.GetResult<Prisma.$QualificationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grantedByAdmin<T extends MemberQualification$grantedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, MemberQualification$grantedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    revokedByAdmin<T extends MemberQualification$revokedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, MemberQualification$revokedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberQualification model
   */
  interface MemberQualificationFieldRefs {
    readonly id: FieldRef<"MemberQualification", 'String'>
    readonly memberId: FieldRef<"MemberQualification", 'String'>
    readonly qualificationTypeId: FieldRef<"MemberQualification", 'String'>
    readonly status: FieldRef<"MemberQualification", 'String'>
    readonly grantedAt: FieldRef<"MemberQualification", 'DateTime'>
    readonly grantedBy: FieldRef<"MemberQualification", 'String'>
    readonly expiresAt: FieldRef<"MemberQualification", 'DateTime'>
    readonly revokedAt: FieldRef<"MemberQualification", 'DateTime'>
    readonly revokedBy: FieldRef<"MemberQualification", 'String'>
    readonly revokeReason: FieldRef<"MemberQualification", 'String'>
    readonly notes: FieldRef<"MemberQualification", 'String'>
    readonly createdAt: FieldRef<"MemberQualification", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberQualification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberQualification findUnique
   */
  export type MemberQualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter, which MemberQualification to fetch.
     */
    where: MemberQualificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification findUniqueOrThrow
   */
  export type MemberQualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter, which MemberQualification to fetch.
     */
    where: MemberQualificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification findFirst
   */
  export type MemberQualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter, which MemberQualification to fetch.
     */
    where?: MemberQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberQualifications to fetch.
     */
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberQualifications.
     */
    cursor?: MemberQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberQualifications.
     */
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification findFirstOrThrow
   */
  export type MemberQualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter, which MemberQualification to fetch.
     */
    where?: MemberQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberQualifications to fetch.
     */
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberQualifications.
     */
    cursor?: MemberQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberQualifications.
     */
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification findMany
   */
  export type MemberQualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter, which MemberQualifications to fetch.
     */
    where?: MemberQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberQualifications to fetch.
     */
    orderBy?: MemberQualificationOrderByWithRelationInput | MemberQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberQualifications.
     */
    cursor?: MemberQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberQualifications.
     */
    skip?: number
    distinct?: MemberQualificationScalarFieldEnum | MemberQualificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification create
   */
  export type MemberQualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberQualification.
     */
    data: XOR<MemberQualificationCreateInput, MemberQualificationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification createMany
   */
  export type MemberQualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberQualifications.
     */
    data: MemberQualificationCreateManyInput | MemberQualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberQualification createManyAndReturn
   */
  export type MemberQualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * The data used to create many MemberQualifications.
     */
    data: MemberQualificationCreateManyInput | MemberQualificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberQualification update
   */
  export type MemberQualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberQualification.
     */
    data: XOR<MemberQualificationUpdateInput, MemberQualificationUncheckedUpdateInput>
    /**
     * Choose, which MemberQualification to update.
     */
    where: MemberQualificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification updateMany
   */
  export type MemberQualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberQualifications.
     */
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyInput>
    /**
     * Filter which MemberQualifications to update
     */
    where?: MemberQualificationWhereInput
    /**
     * Limit how many MemberQualifications to update.
     */
    limit?: number
  }

  /**
   * MemberQualification updateManyAndReturn
   */
  export type MemberQualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * The data used to update MemberQualifications.
     */
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyInput>
    /**
     * Filter which MemberQualifications to update
     */
    where?: MemberQualificationWhereInput
    /**
     * Limit how many MemberQualifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberQualification upsert
   */
  export type MemberQualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberQualification to update in case it exists.
     */
    where: MemberQualificationWhereUniqueInput
    /**
     * In case the MemberQualification found by the `where` argument doesn't exist, create a new MemberQualification with this data.
     */
    create: XOR<MemberQualificationCreateInput, MemberQualificationUncheckedCreateInput>
    /**
     * In case the MemberQualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberQualificationUpdateInput, MemberQualificationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification delete
   */
  export type MemberQualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
    /**
     * Filter which MemberQualification to delete.
     */
    where: MemberQualificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MemberQualification deleteMany
   */
  export type MemberQualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberQualifications to delete
     */
    where?: MemberQualificationWhereInput
    /**
     * Limit how many MemberQualifications to delete.
     */
    limit?: number
  }

  /**
   * MemberQualification.grantedByAdmin
   */
  export type MemberQualification$grantedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * MemberQualification.revokedByAdmin
   */
  export type MemberQualification$revokedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * MemberQualification without action
   */
  export type MemberQualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberQualification
     */
    select?: MemberQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberQualification
     */
    omit?: MemberQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberQualificationInclude<ExtArgs> | null
  }


  /**
   * Model DutyRole
   */

  export type AggregateDutyRole = {
    _count: DutyRoleCountAggregateOutputType | null
    _avg: DutyRoleAvgAggregateOutputType | null
    _sum: DutyRoleSumAggregateOutputType | null
    _min: DutyRoleMinAggregateOutputType | null
    _max: DutyRoleMaxAggregateOutputType | null
  }

  export type DutyRoleAvgAggregateOutputType = {
    activeDays: number | null
    displayOrder: number | null
  }

  export type DutyRoleSumAggregateOutputType = {
    activeDays: number[]
    displayOrder: number | null
  }

  export type DutyRoleMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    roleType: string | null
    scheduleType: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyRoleMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    roleType: string | null
    scheduleType: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyRoleCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    roleType: number
    scheduleType: number
    activeDays: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DutyRoleAvgAggregateInputType = {
    activeDays?: true
    displayOrder?: true
  }

  export type DutyRoleSumAggregateInputType = {
    activeDays?: true
    displayOrder?: true
  }

  export type DutyRoleMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    roleType?: true
    scheduleType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyRoleMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    roleType?: true
    scheduleType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyRoleCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    roleType?: true
    scheduleType?: true
    activeDays?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DutyRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyRole to aggregate.
     */
    where?: DutyRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRoles to fetch.
     */
    orderBy?: DutyRoleOrderByWithRelationInput | DutyRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DutyRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DutyRoles
    **/
    _count?: true | DutyRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DutyRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DutyRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DutyRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DutyRoleMaxAggregateInputType
  }

  export type GetDutyRoleAggregateType<T extends DutyRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateDutyRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDutyRole[P]>
      : GetScalarType<T[P], AggregateDutyRole[P]>
  }




  export type DutyRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyRoleWhereInput
    orderBy?: DutyRoleOrderByWithAggregationInput | DutyRoleOrderByWithAggregationInput[]
    by: DutyRoleScalarFieldEnum[] | DutyRoleScalarFieldEnum
    having?: DutyRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DutyRoleCountAggregateInputType | true
    _avg?: DutyRoleAvgAggregateInputType
    _sum?: DutyRoleSumAggregateInputType
    _min?: DutyRoleMinAggregateInputType
    _max?: DutyRoleMaxAggregateInputType
  }

  export type DutyRoleGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    roleType: string
    scheduleType: string
    activeDays: number[]
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: DutyRoleCountAggregateOutputType | null
    _avg: DutyRoleAvgAggregateOutputType | null
    _sum: DutyRoleSumAggregateOutputType | null
    _min: DutyRoleMinAggregateOutputType | null
    _max: DutyRoleMaxAggregateOutputType | null
  }

  type GetDutyRoleGroupByPayload<T extends DutyRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DutyRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DutyRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DutyRoleGroupByOutputType[P]>
            : GetScalarType<T[P], DutyRoleGroupByOutputType[P]>
        }
      >
    >


  export type DutyRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    roleType?: boolean
    scheduleType?: boolean
    activeDays?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    positions?: boolean | DutyRole$positionsArgs<ExtArgs>
    schedules?: boolean | DutyRole$schedulesArgs<ExtArgs>
    _count?: boolean | DutyRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyRole"]>

  export type DutyRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    roleType?: boolean
    scheduleType?: boolean
    activeDays?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dutyRole"]>

  export type DutyRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    roleType?: boolean
    scheduleType?: boolean
    activeDays?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dutyRole"]>

  export type DutyRoleSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    roleType?: boolean
    scheduleType?: boolean
    activeDays?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DutyRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "roleType" | "scheduleType" | "activeDays" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["dutyRole"]>
  export type DutyRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | DutyRole$positionsArgs<ExtArgs>
    schedules?: boolean | DutyRole$schedulesArgs<ExtArgs>
    _count?: boolean | DutyRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DutyRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DutyRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DutyRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DutyRole"
    objects: {
      positions: Prisma.$DutyPositionPayload<ExtArgs>[]
      schedules: Prisma.$WeeklySchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      roleType: string
      scheduleType: string
      activeDays: number[]
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dutyRole"]>
    composites: {}
  }

  type DutyRoleGetPayload<S extends boolean | null | undefined | DutyRoleDefaultArgs> = $Result.GetResult<Prisma.$DutyRolePayload, S>

  type DutyRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DutyRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DutyRoleCountAggregateInputType | true
    }

  export interface DutyRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DutyRole'], meta: { name: 'DutyRole' } }
    /**
     * Find zero or one DutyRole that matches the filter.
     * @param {DutyRoleFindUniqueArgs} args - Arguments to find a DutyRole
     * @example
     * // Get one DutyRole
     * const dutyRole = await prisma.dutyRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DutyRoleFindUniqueArgs>(args: SelectSubset<T, DutyRoleFindUniqueArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DutyRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DutyRoleFindUniqueOrThrowArgs} args - Arguments to find a DutyRole
     * @example
     * // Get one DutyRole
     * const dutyRole = await prisma.dutyRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DutyRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, DutyRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleFindFirstArgs} args - Arguments to find a DutyRole
     * @example
     * // Get one DutyRole
     * const dutyRole = await prisma.dutyRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DutyRoleFindFirstArgs>(args?: SelectSubset<T, DutyRoleFindFirstArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleFindFirstOrThrowArgs} args - Arguments to find a DutyRole
     * @example
     * // Get one DutyRole
     * const dutyRole = await prisma.dutyRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DutyRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, DutyRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DutyRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DutyRoles
     * const dutyRoles = await prisma.dutyRole.findMany()
     * 
     * // Get first 10 DutyRoles
     * const dutyRoles = await prisma.dutyRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dutyRoleWithIdOnly = await prisma.dutyRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DutyRoleFindManyArgs>(args?: SelectSubset<T, DutyRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DutyRole.
     * @param {DutyRoleCreateArgs} args - Arguments to create a DutyRole.
     * @example
     * // Create one DutyRole
     * const DutyRole = await prisma.dutyRole.create({
     *   data: {
     *     // ... data to create a DutyRole
     *   }
     * })
     * 
     */
    create<T extends DutyRoleCreateArgs>(args: SelectSubset<T, DutyRoleCreateArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DutyRoles.
     * @param {DutyRoleCreateManyArgs} args - Arguments to create many DutyRoles.
     * @example
     * // Create many DutyRoles
     * const dutyRole = await prisma.dutyRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DutyRoleCreateManyArgs>(args?: SelectSubset<T, DutyRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DutyRoles and returns the data saved in the database.
     * @param {DutyRoleCreateManyAndReturnArgs} args - Arguments to create many DutyRoles.
     * @example
     * // Create many DutyRoles
     * const dutyRole = await prisma.dutyRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DutyRoles and only return the `id`
     * const dutyRoleWithIdOnly = await prisma.dutyRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DutyRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, DutyRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DutyRole.
     * @param {DutyRoleDeleteArgs} args - Arguments to delete one DutyRole.
     * @example
     * // Delete one DutyRole
     * const DutyRole = await prisma.dutyRole.delete({
     *   where: {
     *     // ... filter to delete one DutyRole
     *   }
     * })
     * 
     */
    delete<T extends DutyRoleDeleteArgs>(args: SelectSubset<T, DutyRoleDeleteArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DutyRole.
     * @param {DutyRoleUpdateArgs} args - Arguments to update one DutyRole.
     * @example
     * // Update one DutyRole
     * const dutyRole = await prisma.dutyRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DutyRoleUpdateArgs>(args: SelectSubset<T, DutyRoleUpdateArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DutyRoles.
     * @param {DutyRoleDeleteManyArgs} args - Arguments to filter DutyRoles to delete.
     * @example
     * // Delete a few DutyRoles
     * const { count } = await prisma.dutyRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DutyRoleDeleteManyArgs>(args?: SelectSubset<T, DutyRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DutyRoles
     * const dutyRole = await prisma.dutyRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DutyRoleUpdateManyArgs>(args: SelectSubset<T, DutyRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyRoles and returns the data updated in the database.
     * @param {DutyRoleUpdateManyAndReturnArgs} args - Arguments to update many DutyRoles.
     * @example
     * // Update many DutyRoles
     * const dutyRole = await prisma.dutyRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DutyRoles and only return the `id`
     * const dutyRoleWithIdOnly = await prisma.dutyRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DutyRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, DutyRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DutyRole.
     * @param {DutyRoleUpsertArgs} args - Arguments to update or create a DutyRole.
     * @example
     * // Update or create a DutyRole
     * const dutyRole = await prisma.dutyRole.upsert({
     *   create: {
     *     // ... data to create a DutyRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DutyRole we want to update
     *   }
     * })
     */
    upsert<T extends DutyRoleUpsertArgs>(args: SelectSubset<T, DutyRoleUpsertArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DutyRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleCountArgs} args - Arguments to filter DutyRoles to count.
     * @example
     * // Count the number of DutyRoles
     * const count = await prisma.dutyRole.count({
     *   where: {
     *     // ... the filter for the DutyRoles we want to count
     *   }
     * })
    **/
    count<T extends DutyRoleCountArgs>(
      args?: Subset<T, DutyRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DutyRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DutyRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DutyRoleAggregateArgs>(args: Subset<T, DutyRoleAggregateArgs>): Prisma.PrismaPromise<GetDutyRoleAggregateType<T>>

    /**
     * Group by DutyRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DutyRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DutyRoleGroupByArgs['orderBy'] }
        : { orderBy?: DutyRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DutyRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDutyRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DutyRole model
   */
  readonly fields: DutyRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DutyRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DutyRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    positions<T extends DutyRole$positionsArgs<ExtArgs> = {}>(args?: Subset<T, DutyRole$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends DutyRole$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, DutyRole$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DutyRole model
   */
  interface DutyRoleFieldRefs {
    readonly id: FieldRef<"DutyRole", 'String'>
    readonly code: FieldRef<"DutyRole", 'String'>
    readonly name: FieldRef<"DutyRole", 'String'>
    readonly description: FieldRef<"DutyRole", 'String'>
    readonly roleType: FieldRef<"DutyRole", 'String'>
    readonly scheduleType: FieldRef<"DutyRole", 'String'>
    readonly activeDays: FieldRef<"DutyRole", 'Int[]'>
    readonly displayOrder: FieldRef<"DutyRole", 'Int'>
    readonly createdAt: FieldRef<"DutyRole", 'DateTime'>
    readonly updatedAt: FieldRef<"DutyRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DutyRole findUnique
   */
  export type DutyRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter, which DutyRole to fetch.
     */
    where: DutyRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole findUniqueOrThrow
   */
  export type DutyRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter, which DutyRole to fetch.
     */
    where: DutyRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole findFirst
   */
  export type DutyRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter, which DutyRole to fetch.
     */
    where?: DutyRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRoles to fetch.
     */
    orderBy?: DutyRoleOrderByWithRelationInput | DutyRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyRoles.
     */
    cursor?: DutyRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyRoles.
     */
    distinct?: DutyRoleScalarFieldEnum | DutyRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole findFirstOrThrow
   */
  export type DutyRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter, which DutyRole to fetch.
     */
    where?: DutyRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRoles to fetch.
     */
    orderBy?: DutyRoleOrderByWithRelationInput | DutyRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyRoles.
     */
    cursor?: DutyRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyRoles.
     */
    distinct?: DutyRoleScalarFieldEnum | DutyRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole findMany
   */
  export type DutyRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter, which DutyRoles to fetch.
     */
    where?: DutyRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRoles to fetch.
     */
    orderBy?: DutyRoleOrderByWithRelationInput | DutyRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DutyRoles.
     */
    cursor?: DutyRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRoles.
     */
    skip?: number
    distinct?: DutyRoleScalarFieldEnum | DutyRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole create
   */
  export type DutyRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a DutyRole.
     */
    data: XOR<DutyRoleCreateInput, DutyRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole createMany
   */
  export type DutyRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DutyRoles.
     */
    data: DutyRoleCreateManyInput | DutyRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DutyRole createManyAndReturn
   */
  export type DutyRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * The data used to create many DutyRoles.
     */
    data: DutyRoleCreateManyInput | DutyRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DutyRole update
   */
  export type DutyRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a DutyRole.
     */
    data: XOR<DutyRoleUpdateInput, DutyRoleUncheckedUpdateInput>
    /**
     * Choose, which DutyRole to update.
     */
    where: DutyRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole updateMany
   */
  export type DutyRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DutyRoles.
     */
    data: XOR<DutyRoleUpdateManyMutationInput, DutyRoleUncheckedUpdateManyInput>
    /**
     * Filter which DutyRoles to update
     */
    where?: DutyRoleWhereInput
    /**
     * Limit how many DutyRoles to update.
     */
    limit?: number
  }

  /**
   * DutyRole updateManyAndReturn
   */
  export type DutyRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * The data used to update DutyRoles.
     */
    data: XOR<DutyRoleUpdateManyMutationInput, DutyRoleUncheckedUpdateManyInput>
    /**
     * Filter which DutyRoles to update
     */
    where?: DutyRoleWhereInput
    /**
     * Limit how many DutyRoles to update.
     */
    limit?: number
  }

  /**
   * DutyRole upsert
   */
  export type DutyRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the DutyRole to update in case it exists.
     */
    where: DutyRoleWhereUniqueInput
    /**
     * In case the DutyRole found by the `where` argument doesn't exist, create a new DutyRole with this data.
     */
    create: XOR<DutyRoleCreateInput, DutyRoleUncheckedCreateInput>
    /**
     * In case the DutyRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DutyRoleUpdateInput, DutyRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole delete
   */
  export type DutyRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
    /**
     * Filter which DutyRole to delete.
     */
    where: DutyRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyRole deleteMany
   */
  export type DutyRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyRoles to delete
     */
    where?: DutyRoleWhereInput
    /**
     * Limit how many DutyRoles to delete.
     */
    limit?: number
  }

  /**
   * DutyRole.positions
   */
  export type DutyRole$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    where?: DutyPositionWhereInput
    orderBy?: DutyPositionOrderByWithRelationInput | DutyPositionOrderByWithRelationInput[]
    cursor?: DutyPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyPositionScalarFieldEnum | DutyPositionScalarFieldEnum[]
  }

  /**
   * DutyRole.schedules
   */
  export type DutyRole$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    where?: WeeklyScheduleWhereInput
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    cursor?: WeeklyScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
  }

  /**
   * DutyRole without action
   */
  export type DutyRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRole
     */
    select?: DutyRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRole
     */
    omit?: DutyRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRoleInclude<ExtArgs> | null
  }


  /**
   * Model DutyPosition
   */

  export type AggregateDutyPosition = {
    _count: DutyPositionCountAggregateOutputType | null
    _avg: DutyPositionAvgAggregateOutputType | null
    _sum: DutyPositionSumAggregateOutputType | null
    _min: DutyPositionMinAggregateOutputType | null
    _max: DutyPositionMaxAggregateOutputType | null
  }

  export type DutyPositionAvgAggregateOutputType = {
    maxSlots: number | null
    displayOrder: number | null
  }

  export type DutyPositionSumAggregateOutputType = {
    maxSlots: number | null
    displayOrder: number | null
  }

  export type DutyPositionMinAggregateOutputType = {
    id: string | null
    dutyRoleId: string | null
    code: string | null
    name: string | null
    description: string | null
    maxSlots: number | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyPositionMaxAggregateOutputType = {
    id: string | null
    dutyRoleId: string | null
    code: string | null
    name: string | null
    description: string | null
    maxSlots: number | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyPositionCountAggregateOutputType = {
    id: number
    dutyRoleId: number
    code: number
    name: number
    description: number
    maxSlots: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DutyPositionAvgAggregateInputType = {
    maxSlots?: true
    displayOrder?: true
  }

  export type DutyPositionSumAggregateInputType = {
    maxSlots?: true
    displayOrder?: true
  }

  export type DutyPositionMinAggregateInputType = {
    id?: true
    dutyRoleId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyPositionMaxAggregateInputType = {
    id?: true
    dutyRoleId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyPositionCountAggregateInputType = {
    id?: true
    dutyRoleId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DutyPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyPosition to aggregate.
     */
    where?: DutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyPositions to fetch.
     */
    orderBy?: DutyPositionOrderByWithRelationInput | DutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DutyPositions
    **/
    _count?: true | DutyPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DutyPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DutyPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DutyPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DutyPositionMaxAggregateInputType
  }

  export type GetDutyPositionAggregateType<T extends DutyPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateDutyPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDutyPosition[P]>
      : GetScalarType<T[P], AggregateDutyPosition[P]>
  }




  export type DutyPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyPositionWhereInput
    orderBy?: DutyPositionOrderByWithAggregationInput | DutyPositionOrderByWithAggregationInput[]
    by: DutyPositionScalarFieldEnum[] | DutyPositionScalarFieldEnum
    having?: DutyPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DutyPositionCountAggregateInputType | true
    _avg?: DutyPositionAvgAggregateInputType
    _sum?: DutyPositionSumAggregateInputType
    _min?: DutyPositionMinAggregateInputType
    _max?: DutyPositionMaxAggregateInputType
  }

  export type DutyPositionGroupByOutputType = {
    id: string
    dutyRoleId: string
    code: string
    name: string
    description: string | null
    maxSlots: number
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: DutyPositionCountAggregateOutputType | null
    _avg: DutyPositionAvgAggregateOutputType | null
    _sum: DutyPositionSumAggregateOutputType | null
    _min: DutyPositionMinAggregateOutputType | null
    _max: DutyPositionMaxAggregateOutputType | null
  }

  type GetDutyPositionGroupByPayload<T extends DutyPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DutyPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DutyPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DutyPositionGroupByOutputType[P]>
            : GetScalarType<T[P], DutyPositionGroupByOutputType[P]>
        }
      >
    >


  export type DutyPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    assignments?: boolean | DutyPosition$assignmentsArgs<ExtArgs>
    _count?: boolean | DutyPositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyPosition"]>

  export type DutyPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyPosition"]>

  export type DutyPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyPosition"]>

  export type DutyPositionSelectScalar = {
    id?: boolean
    dutyRoleId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DutyPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dutyRoleId" | "code" | "name" | "description" | "maxSlots" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["dutyPosition"]>
  export type DutyPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    assignments?: boolean | DutyPosition$assignmentsArgs<ExtArgs>
    _count?: boolean | DutyPositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DutyPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
  }
  export type DutyPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
  }

  export type $DutyPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DutyPosition"
    objects: {
      dutyRole: Prisma.$DutyRolePayload<ExtArgs>
      assignments: Prisma.$ScheduleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dutyRoleId: string
      code: string
      name: string
      description: string | null
      maxSlots: number
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dutyPosition"]>
    composites: {}
  }

  type DutyPositionGetPayload<S extends boolean | null | undefined | DutyPositionDefaultArgs> = $Result.GetResult<Prisma.$DutyPositionPayload, S>

  type DutyPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DutyPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DutyPositionCountAggregateInputType | true
    }

  export interface DutyPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DutyPosition'], meta: { name: 'DutyPosition' } }
    /**
     * Find zero or one DutyPosition that matches the filter.
     * @param {DutyPositionFindUniqueArgs} args - Arguments to find a DutyPosition
     * @example
     * // Get one DutyPosition
     * const dutyPosition = await prisma.dutyPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DutyPositionFindUniqueArgs>(args: SelectSubset<T, DutyPositionFindUniqueArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DutyPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DutyPositionFindUniqueOrThrowArgs} args - Arguments to find a DutyPosition
     * @example
     * // Get one DutyPosition
     * const dutyPosition = await prisma.dutyPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DutyPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, DutyPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionFindFirstArgs} args - Arguments to find a DutyPosition
     * @example
     * // Get one DutyPosition
     * const dutyPosition = await prisma.dutyPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DutyPositionFindFirstArgs>(args?: SelectSubset<T, DutyPositionFindFirstArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionFindFirstOrThrowArgs} args - Arguments to find a DutyPosition
     * @example
     * // Get one DutyPosition
     * const dutyPosition = await prisma.dutyPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DutyPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, DutyPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DutyPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DutyPositions
     * const dutyPositions = await prisma.dutyPosition.findMany()
     * 
     * // Get first 10 DutyPositions
     * const dutyPositions = await prisma.dutyPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dutyPositionWithIdOnly = await prisma.dutyPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DutyPositionFindManyArgs>(args?: SelectSubset<T, DutyPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DutyPosition.
     * @param {DutyPositionCreateArgs} args - Arguments to create a DutyPosition.
     * @example
     * // Create one DutyPosition
     * const DutyPosition = await prisma.dutyPosition.create({
     *   data: {
     *     // ... data to create a DutyPosition
     *   }
     * })
     * 
     */
    create<T extends DutyPositionCreateArgs>(args: SelectSubset<T, DutyPositionCreateArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DutyPositions.
     * @param {DutyPositionCreateManyArgs} args - Arguments to create many DutyPositions.
     * @example
     * // Create many DutyPositions
     * const dutyPosition = await prisma.dutyPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DutyPositionCreateManyArgs>(args?: SelectSubset<T, DutyPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DutyPositions and returns the data saved in the database.
     * @param {DutyPositionCreateManyAndReturnArgs} args - Arguments to create many DutyPositions.
     * @example
     * // Create many DutyPositions
     * const dutyPosition = await prisma.dutyPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DutyPositions and only return the `id`
     * const dutyPositionWithIdOnly = await prisma.dutyPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DutyPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, DutyPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DutyPosition.
     * @param {DutyPositionDeleteArgs} args - Arguments to delete one DutyPosition.
     * @example
     * // Delete one DutyPosition
     * const DutyPosition = await prisma.dutyPosition.delete({
     *   where: {
     *     // ... filter to delete one DutyPosition
     *   }
     * })
     * 
     */
    delete<T extends DutyPositionDeleteArgs>(args: SelectSubset<T, DutyPositionDeleteArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DutyPosition.
     * @param {DutyPositionUpdateArgs} args - Arguments to update one DutyPosition.
     * @example
     * // Update one DutyPosition
     * const dutyPosition = await prisma.dutyPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DutyPositionUpdateArgs>(args: SelectSubset<T, DutyPositionUpdateArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DutyPositions.
     * @param {DutyPositionDeleteManyArgs} args - Arguments to filter DutyPositions to delete.
     * @example
     * // Delete a few DutyPositions
     * const { count } = await prisma.dutyPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DutyPositionDeleteManyArgs>(args?: SelectSubset<T, DutyPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DutyPositions
     * const dutyPosition = await prisma.dutyPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DutyPositionUpdateManyArgs>(args: SelectSubset<T, DutyPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyPositions and returns the data updated in the database.
     * @param {DutyPositionUpdateManyAndReturnArgs} args - Arguments to update many DutyPositions.
     * @example
     * // Update many DutyPositions
     * const dutyPosition = await prisma.dutyPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DutyPositions and only return the `id`
     * const dutyPositionWithIdOnly = await prisma.dutyPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DutyPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, DutyPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DutyPosition.
     * @param {DutyPositionUpsertArgs} args - Arguments to update or create a DutyPosition.
     * @example
     * // Update or create a DutyPosition
     * const dutyPosition = await prisma.dutyPosition.upsert({
     *   create: {
     *     // ... data to create a DutyPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DutyPosition we want to update
     *   }
     * })
     */
    upsert<T extends DutyPositionUpsertArgs>(args: SelectSubset<T, DutyPositionUpsertArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DutyPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionCountArgs} args - Arguments to filter DutyPositions to count.
     * @example
     * // Count the number of DutyPositions
     * const count = await prisma.dutyPosition.count({
     *   where: {
     *     // ... the filter for the DutyPositions we want to count
     *   }
     * })
    **/
    count<T extends DutyPositionCountArgs>(
      args?: Subset<T, DutyPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DutyPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DutyPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DutyPositionAggregateArgs>(args: Subset<T, DutyPositionAggregateArgs>): Prisma.PrismaPromise<GetDutyPositionAggregateType<T>>

    /**
     * Group by DutyPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DutyPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DutyPositionGroupByArgs['orderBy'] }
        : { orderBy?: DutyPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DutyPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDutyPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DutyPosition model
   */
  readonly fields: DutyPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DutyPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DutyPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dutyRole<T extends DutyRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DutyRoleDefaultArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends DutyPosition$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, DutyPosition$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DutyPosition model
   */
  interface DutyPositionFieldRefs {
    readonly id: FieldRef<"DutyPosition", 'String'>
    readonly dutyRoleId: FieldRef<"DutyPosition", 'String'>
    readonly code: FieldRef<"DutyPosition", 'String'>
    readonly name: FieldRef<"DutyPosition", 'String'>
    readonly description: FieldRef<"DutyPosition", 'String'>
    readonly maxSlots: FieldRef<"DutyPosition", 'Int'>
    readonly displayOrder: FieldRef<"DutyPosition", 'Int'>
    readonly createdAt: FieldRef<"DutyPosition", 'DateTime'>
    readonly updatedAt: FieldRef<"DutyPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DutyPosition findUnique
   */
  export type DutyPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which DutyPosition to fetch.
     */
    where: DutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition findUniqueOrThrow
   */
  export type DutyPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which DutyPosition to fetch.
     */
    where: DutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition findFirst
   */
  export type DutyPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which DutyPosition to fetch.
     */
    where?: DutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyPositions to fetch.
     */
    orderBy?: DutyPositionOrderByWithRelationInput | DutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyPositions.
     */
    cursor?: DutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyPositions.
     */
    distinct?: DutyPositionScalarFieldEnum | DutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition findFirstOrThrow
   */
  export type DutyPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which DutyPosition to fetch.
     */
    where?: DutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyPositions to fetch.
     */
    orderBy?: DutyPositionOrderByWithRelationInput | DutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyPositions.
     */
    cursor?: DutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyPositions.
     */
    distinct?: DutyPositionScalarFieldEnum | DutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition findMany
   */
  export type DutyPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which DutyPositions to fetch.
     */
    where?: DutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyPositions to fetch.
     */
    orderBy?: DutyPositionOrderByWithRelationInput | DutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DutyPositions.
     */
    cursor?: DutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyPositions.
     */
    skip?: number
    distinct?: DutyPositionScalarFieldEnum | DutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition create
   */
  export type DutyPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a DutyPosition.
     */
    data: XOR<DutyPositionCreateInput, DutyPositionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition createMany
   */
  export type DutyPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DutyPositions.
     */
    data: DutyPositionCreateManyInput | DutyPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DutyPosition createManyAndReturn
   */
  export type DutyPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * The data used to create many DutyPositions.
     */
    data: DutyPositionCreateManyInput | DutyPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DutyPosition update
   */
  export type DutyPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a DutyPosition.
     */
    data: XOR<DutyPositionUpdateInput, DutyPositionUncheckedUpdateInput>
    /**
     * Choose, which DutyPosition to update.
     */
    where: DutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition updateMany
   */
  export type DutyPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DutyPositions.
     */
    data: XOR<DutyPositionUpdateManyMutationInput, DutyPositionUncheckedUpdateManyInput>
    /**
     * Filter which DutyPositions to update
     */
    where?: DutyPositionWhereInput
    /**
     * Limit how many DutyPositions to update.
     */
    limit?: number
  }

  /**
   * DutyPosition updateManyAndReturn
   */
  export type DutyPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * The data used to update DutyPositions.
     */
    data: XOR<DutyPositionUpdateManyMutationInput, DutyPositionUncheckedUpdateManyInput>
    /**
     * Filter which DutyPositions to update
     */
    where?: DutyPositionWhereInput
    /**
     * Limit how many DutyPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DutyPosition upsert
   */
  export type DutyPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the DutyPosition to update in case it exists.
     */
    where: DutyPositionWhereUniqueInput
    /**
     * In case the DutyPosition found by the `where` argument doesn't exist, create a new DutyPosition with this data.
     */
    create: XOR<DutyPositionCreateInput, DutyPositionUncheckedCreateInput>
    /**
     * In case the DutyPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DutyPositionUpdateInput, DutyPositionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition delete
   */
  export type DutyPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    /**
     * Filter which DutyPosition to delete.
     */
    where: DutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DutyPosition deleteMany
   */
  export type DutyPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyPositions to delete
     */
    where?: DutyPositionWhereInput
    /**
     * Limit how many DutyPositions to delete.
     */
    limit?: number
  }

  /**
   * DutyPosition.assignments
   */
  export type DutyPosition$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    where?: ScheduleAssignmentWhereInput
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    cursor?: ScheduleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
  }

  /**
   * DutyPosition without action
   */
  export type DutyPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
  }


  /**
   * Model WeeklySchedule
   */

  export type AggregateWeeklySchedule = {
    _count: WeeklyScheduleCountAggregateOutputType | null
    _min: WeeklyScheduleMinAggregateOutputType | null
    _max: WeeklyScheduleMaxAggregateOutputType | null
  }

  export type WeeklyScheduleMinAggregateOutputType = {
    id: string | null
    dutyRoleId: string | null
    weekStartDate: Date | null
    status: string | null
    createdBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyScheduleMaxAggregateOutputType = {
    id: string | null
    dutyRoleId: string | null
    weekStartDate: Date | null
    status: string | null
    createdBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyScheduleCountAggregateOutputType = {
    id: number
    dutyRoleId: number
    weekStartDate: number
    status: number
    createdBy: number
    publishedAt: number
    publishedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeeklyScheduleMinAggregateInputType = {
    id?: true
    dutyRoleId?: true
    weekStartDate?: true
    status?: true
    createdBy?: true
    publishedAt?: true
    publishedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyScheduleMaxAggregateInputType = {
    id?: true
    dutyRoleId?: true
    weekStartDate?: true
    status?: true
    createdBy?: true
    publishedAt?: true
    publishedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyScheduleCountAggregateInputType = {
    id?: true
    dutyRoleId?: true
    weekStartDate?: true
    status?: true
    createdBy?: true
    publishedAt?: true
    publishedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeeklyScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklySchedule to aggregate.
     */
    where?: WeeklyScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklySchedules to fetch.
     */
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklySchedules
    **/
    _count?: true | WeeklyScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyScheduleMaxAggregateInputType
  }

  export type GetWeeklyScheduleAggregateType<T extends WeeklyScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklySchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklySchedule[P]>
      : GetScalarType<T[P], AggregateWeeklySchedule[P]>
  }




  export type WeeklyScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyScheduleWhereInput
    orderBy?: WeeklyScheduleOrderByWithAggregationInput | WeeklyScheduleOrderByWithAggregationInput[]
    by: WeeklyScheduleScalarFieldEnum[] | WeeklyScheduleScalarFieldEnum
    having?: WeeklyScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyScheduleCountAggregateInputType | true
    _min?: WeeklyScheduleMinAggregateInputType
    _max?: WeeklyScheduleMaxAggregateInputType
  }

  export type WeeklyScheduleGroupByOutputType = {
    id: string
    dutyRoleId: string
    weekStartDate: Date
    status: string
    createdBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeeklyScheduleCountAggregateOutputType | null
    _min: WeeklyScheduleMinAggregateOutputType | null
    _max: WeeklyScheduleMaxAggregateOutputType | null
  }

  type GetWeeklyScheduleGroupByPayload<T extends WeeklyScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyScheduleGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    weekStartDate?: boolean
    status?: boolean
    createdBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
    assignments?: boolean | WeeklySchedule$assignmentsArgs<ExtArgs>
    _count?: boolean | WeeklyScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklySchedule"]>

  export type WeeklyScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    weekStartDate?: boolean
    status?: boolean
    createdBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["weeklySchedule"]>

  export type WeeklyScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyRoleId?: boolean
    weekStartDate?: boolean
    status?: boolean
    createdBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["weeklySchedule"]>

  export type WeeklyScheduleSelectScalar = {
    id?: boolean
    dutyRoleId?: boolean
    weekStartDate?: boolean
    status?: boolean
    createdBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeeklyScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dutyRoleId" | "weekStartDate" | "status" | "createdBy" | "publishedAt" | "publishedBy" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["weeklySchedule"]>
  export type WeeklyScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
    assignments?: boolean | WeeklySchedule$assignmentsArgs<ExtArgs>
    _count?: boolean | WeeklyScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeeklyScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
  }
  export type WeeklyScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyRole?: boolean | DutyRoleDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | WeeklySchedule$createdByAdminArgs<ExtArgs>
    publishedByAdmin?: boolean | WeeklySchedule$publishedByAdminArgs<ExtArgs>
  }

  export type $WeeklySchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklySchedule"
    objects: {
      dutyRole: Prisma.$DutyRolePayload<ExtArgs>
      createdByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      publishedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      assignments: Prisma.$ScheduleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dutyRoleId: string
      weekStartDate: Date
      status: string
      createdBy: string | null
      publishedAt: Date | null
      publishedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weeklySchedule"]>
    composites: {}
  }

  type WeeklyScheduleGetPayload<S extends boolean | null | undefined | WeeklyScheduleDefaultArgs> = $Result.GetResult<Prisma.$WeeklySchedulePayload, S>

  type WeeklyScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeeklyScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WeeklyScheduleCountAggregateInputType | true
    }

  export interface WeeklyScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklySchedule'], meta: { name: 'WeeklySchedule' } }
    /**
     * Find zero or one WeeklySchedule that matches the filter.
     * @param {WeeklyScheduleFindUniqueArgs} args - Arguments to find a WeeklySchedule
     * @example
     * // Get one WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyScheduleFindUniqueArgs>(args: SelectSubset<T, WeeklyScheduleFindUniqueArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeeklySchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeeklyScheduleFindUniqueOrThrowArgs} args - Arguments to find a WeeklySchedule
     * @example
     * // Get one WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklySchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleFindFirstArgs} args - Arguments to find a WeeklySchedule
     * @example
     * // Get one WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyScheduleFindFirstArgs>(args?: SelectSubset<T, WeeklyScheduleFindFirstArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklySchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleFindFirstOrThrowArgs} args - Arguments to find a WeeklySchedule
     * @example
     * // Get one WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeeklySchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklySchedules
     * const weeklySchedules = await prisma.weeklySchedule.findMany()
     * 
     * // Get first 10 WeeklySchedules
     * const weeklySchedules = await prisma.weeklySchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyScheduleWithIdOnly = await prisma.weeklySchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyScheduleFindManyArgs>(args?: SelectSubset<T, WeeklyScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeeklySchedule.
     * @param {WeeklyScheduleCreateArgs} args - Arguments to create a WeeklySchedule.
     * @example
     * // Create one WeeklySchedule
     * const WeeklySchedule = await prisma.weeklySchedule.create({
     *   data: {
     *     // ... data to create a WeeklySchedule
     *   }
     * })
     * 
     */
    create<T extends WeeklyScheduleCreateArgs>(args: SelectSubset<T, WeeklyScheduleCreateArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeeklySchedules.
     * @param {WeeklyScheduleCreateManyArgs} args - Arguments to create many WeeklySchedules.
     * @example
     * // Create many WeeklySchedules
     * const weeklySchedule = await prisma.weeklySchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyScheduleCreateManyArgs>(args?: SelectSubset<T, WeeklyScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklySchedules and returns the data saved in the database.
     * @param {WeeklyScheduleCreateManyAndReturnArgs} args - Arguments to create many WeeklySchedules.
     * @example
     * // Create many WeeklySchedules
     * const weeklySchedule = await prisma.weeklySchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklySchedules and only return the `id`
     * const weeklyScheduleWithIdOnly = await prisma.weeklySchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeeklySchedule.
     * @param {WeeklyScheduleDeleteArgs} args - Arguments to delete one WeeklySchedule.
     * @example
     * // Delete one WeeklySchedule
     * const WeeklySchedule = await prisma.weeklySchedule.delete({
     *   where: {
     *     // ... filter to delete one WeeklySchedule
     *   }
     * })
     * 
     */
    delete<T extends WeeklyScheduleDeleteArgs>(args: SelectSubset<T, WeeklyScheduleDeleteArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeeklySchedule.
     * @param {WeeklyScheduleUpdateArgs} args - Arguments to update one WeeklySchedule.
     * @example
     * // Update one WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyScheduleUpdateArgs>(args: SelectSubset<T, WeeklyScheduleUpdateArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeeklySchedules.
     * @param {WeeklyScheduleDeleteManyArgs} args - Arguments to filter WeeklySchedules to delete.
     * @example
     * // Delete a few WeeklySchedules
     * const { count } = await prisma.weeklySchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyScheduleDeleteManyArgs>(args?: SelectSubset<T, WeeklyScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklySchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklySchedules
     * const weeklySchedule = await prisma.weeklySchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyScheduleUpdateManyArgs>(args: SelectSubset<T, WeeklyScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklySchedules and returns the data updated in the database.
     * @param {WeeklyScheduleUpdateManyAndReturnArgs} args - Arguments to update many WeeklySchedules.
     * @example
     * // Update many WeeklySchedules
     * const weeklySchedule = await prisma.weeklySchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeeklySchedules and only return the `id`
     * const weeklyScheduleWithIdOnly = await prisma.weeklySchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeeklyScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, WeeklyScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeeklySchedule.
     * @param {WeeklyScheduleUpsertArgs} args - Arguments to update or create a WeeklySchedule.
     * @example
     * // Update or create a WeeklySchedule
     * const weeklySchedule = await prisma.weeklySchedule.upsert({
     *   create: {
     *     // ... data to create a WeeklySchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklySchedule we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyScheduleUpsertArgs>(args: SelectSubset<T, WeeklyScheduleUpsertArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeeklySchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleCountArgs} args - Arguments to filter WeeklySchedules to count.
     * @example
     * // Count the number of WeeklySchedules
     * const count = await prisma.weeklySchedule.count({
     *   where: {
     *     // ... the filter for the WeeklySchedules we want to count
     *   }
     * })
    **/
    count<T extends WeeklyScheduleCountArgs>(
      args?: Subset<T, WeeklyScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklySchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyScheduleAggregateArgs>(args: Subset<T, WeeklyScheduleAggregateArgs>): Prisma.PrismaPromise<GetWeeklyScheduleAggregateType<T>>

    /**
     * Group by WeeklySchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyScheduleGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklySchedule model
   */
  readonly fields: WeeklyScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklySchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dutyRole<T extends DutyRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DutyRoleDefaultArgs<ExtArgs>>): Prisma__DutyRoleClient<$Result.GetResult<Prisma.$DutyRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByAdmin<T extends WeeklySchedule$createdByAdminArgs<ExtArgs> = {}>(args?: Subset<T, WeeklySchedule$createdByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publishedByAdmin<T extends WeeklySchedule$publishedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, WeeklySchedule$publishedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignments<T extends WeeklySchedule$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, WeeklySchedule$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklySchedule model
   */
  interface WeeklyScheduleFieldRefs {
    readonly id: FieldRef<"WeeklySchedule", 'String'>
    readonly dutyRoleId: FieldRef<"WeeklySchedule", 'String'>
    readonly weekStartDate: FieldRef<"WeeklySchedule", 'DateTime'>
    readonly status: FieldRef<"WeeklySchedule", 'String'>
    readonly createdBy: FieldRef<"WeeklySchedule", 'String'>
    readonly publishedAt: FieldRef<"WeeklySchedule", 'DateTime'>
    readonly publishedBy: FieldRef<"WeeklySchedule", 'String'>
    readonly notes: FieldRef<"WeeklySchedule", 'String'>
    readonly createdAt: FieldRef<"WeeklySchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"WeeklySchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklySchedule findUnique
   */
  export type WeeklyScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WeeklySchedule to fetch.
     */
    where: WeeklyScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule findUniqueOrThrow
   */
  export type WeeklyScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WeeklySchedule to fetch.
     */
    where: WeeklyScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule findFirst
   */
  export type WeeklyScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WeeklySchedule to fetch.
     */
    where?: WeeklyScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklySchedules to fetch.
     */
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklySchedules.
     */
    cursor?: WeeklyScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklySchedules.
     */
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule findFirstOrThrow
   */
  export type WeeklyScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WeeklySchedule to fetch.
     */
    where?: WeeklyScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklySchedules to fetch.
     */
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklySchedules.
     */
    cursor?: WeeklyScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklySchedules.
     */
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule findMany
   */
  export type WeeklyScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WeeklySchedules to fetch.
     */
    where?: WeeklyScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklySchedules to fetch.
     */
    orderBy?: WeeklyScheduleOrderByWithRelationInput | WeeklyScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklySchedules.
     */
    cursor?: WeeklyScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklySchedules.
     */
    skip?: number
    distinct?: WeeklyScheduleScalarFieldEnum | WeeklyScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule create
   */
  export type WeeklyScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklySchedule.
     */
    data: XOR<WeeklyScheduleCreateInput, WeeklyScheduleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule createMany
   */
  export type WeeklyScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklySchedules.
     */
    data: WeeklyScheduleCreateManyInput | WeeklyScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklySchedule createManyAndReturn
   */
  export type WeeklyScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many WeeklySchedules.
     */
    data: WeeklyScheduleCreateManyInput | WeeklyScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklySchedule update
   */
  export type WeeklyScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklySchedule.
     */
    data: XOR<WeeklyScheduleUpdateInput, WeeklyScheduleUncheckedUpdateInput>
    /**
     * Choose, which WeeklySchedule to update.
     */
    where: WeeklyScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule updateMany
   */
  export type WeeklyScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklySchedules.
     */
    data: XOR<WeeklyScheduleUpdateManyMutationInput, WeeklyScheduleUncheckedUpdateManyInput>
    /**
     * Filter which WeeklySchedules to update
     */
    where?: WeeklyScheduleWhereInput
    /**
     * Limit how many WeeklySchedules to update.
     */
    limit?: number
  }

  /**
   * WeeklySchedule updateManyAndReturn
   */
  export type WeeklyScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * The data used to update WeeklySchedules.
     */
    data: XOR<WeeklyScheduleUpdateManyMutationInput, WeeklyScheduleUncheckedUpdateManyInput>
    /**
     * Filter which WeeklySchedules to update
     */
    where?: WeeklyScheduleWhereInput
    /**
     * Limit how many WeeklySchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklySchedule upsert
   */
  export type WeeklyScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklySchedule to update in case it exists.
     */
    where: WeeklyScheduleWhereUniqueInput
    /**
     * In case the WeeklySchedule found by the `where` argument doesn't exist, create a new WeeklySchedule with this data.
     */
    create: XOR<WeeklyScheduleCreateInput, WeeklyScheduleUncheckedCreateInput>
    /**
     * In case the WeeklySchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyScheduleUpdateInput, WeeklyScheduleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule delete
   */
  export type WeeklyScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
    /**
     * Filter which WeeklySchedule to delete.
     */
    where: WeeklyScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WeeklySchedule deleteMany
   */
  export type WeeklyScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklySchedules to delete
     */
    where?: WeeklyScheduleWhereInput
    /**
     * Limit how many WeeklySchedules to delete.
     */
    limit?: number
  }

  /**
   * WeeklySchedule.createdByAdmin
   */
  export type WeeklySchedule$createdByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * WeeklySchedule.publishedByAdmin
   */
  export type WeeklySchedule$publishedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * WeeklySchedule.assignments
   */
  export type WeeklySchedule$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    where?: ScheduleAssignmentWhereInput
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    cursor?: ScheduleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
  }

  /**
   * WeeklySchedule without action
   */
  export type WeeklyScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklySchedule
     */
    select?: WeeklyScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklySchedule
     */
    omit?: WeeklyScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleAssignment
   */

  export type AggregateScheduleAssignment = {
    _count: ScheduleAssignmentCountAggregateOutputType | null
    _min: ScheduleAssignmentMinAggregateOutputType | null
    _max: ScheduleAssignmentMaxAggregateOutputType | null
  }

  export type ScheduleAssignmentMinAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    dutyPositionId: string | null
    memberId: string | null
    status: string | null
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleAssignmentMaxAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    dutyPositionId: string | null
    memberId: string | null
    status: string | null
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleAssignmentCountAggregateOutputType = {
    id: number
    scheduleId: number
    dutyPositionId: number
    memberId: number
    status: number
    confirmedAt: number
    releasedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleAssignmentMinAggregateInputType = {
    id?: true
    scheduleId?: true
    dutyPositionId?: true
    memberId?: true
    status?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleAssignmentMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    dutyPositionId?: true
    memberId?: true
    status?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleAssignmentCountAggregateInputType = {
    id?: true
    scheduleId?: true
    dutyPositionId?: true
    memberId?: true
    status?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleAssignment to aggregate.
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAssignments to fetch.
     */
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleAssignments
    **/
    _count?: true | ScheduleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleAssignmentMaxAggregateInputType
  }

  export type GetScheduleAssignmentAggregateType<T extends ScheduleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleAssignment[P]>
      : GetScalarType<T[P], AggregateScheduleAssignment[P]>
  }




  export type ScheduleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAssignmentWhereInput
    orderBy?: ScheduleAssignmentOrderByWithAggregationInput | ScheduleAssignmentOrderByWithAggregationInput[]
    by: ScheduleAssignmentScalarFieldEnum[] | ScheduleAssignmentScalarFieldEnum
    having?: ScheduleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleAssignmentCountAggregateInputType | true
    _min?: ScheduleAssignmentMinAggregateInputType
    _max?: ScheduleAssignmentMaxAggregateInputType
  }

  export type ScheduleAssignmentGroupByOutputType = {
    id: string
    scheduleId: string
    dutyPositionId: string | null
    memberId: string
    status: string
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleAssignmentCountAggregateOutputType | null
    _min: ScheduleAssignmentMinAggregateOutputType | null
    _max: ScheduleAssignmentMaxAggregateOutputType | null
  }

  type GetScheduleAssignmentGroupByPayload<T extends ScheduleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    dutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAssignment"]>

  export type ScheduleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    dutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAssignment"]>

  export type ScheduleAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    dutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAssignment"]>

  export type ScheduleAssignmentSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    dutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduleId" | "dutyPositionId" | "memberId" | "status" | "confirmedAt" | "releasedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduleAssignment"]>
  export type ScheduleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ScheduleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ScheduleAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | WeeklyScheduleDefaultArgs<ExtArgs>
    dutyPosition?: boolean | ScheduleAssignment$dutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $ScheduleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleAssignment"
    objects: {
      schedule: Prisma.$WeeklySchedulePayload<ExtArgs>
      dutyPosition: Prisma.$DutyPositionPayload<ExtArgs> | null
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduleId: string
      dutyPositionId: string | null
      memberId: string
      status: string
      confirmedAt: Date | null
      releasedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduleAssignment"]>
    composites: {}
  }

  type ScheduleAssignmentGetPayload<S extends boolean | null | undefined | ScheduleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ScheduleAssignmentPayload, S>

  type ScheduleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ScheduleAssignmentCountAggregateInputType | true
    }

  export interface ScheduleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleAssignment'], meta: { name: 'ScheduleAssignment' } }
    /**
     * Find zero or one ScheduleAssignment that matches the filter.
     * @param {ScheduleAssignmentFindUniqueArgs} args - Arguments to find a ScheduleAssignment
     * @example
     * // Get one ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleAssignmentFindUniqueArgs>(args: SelectSubset<T, ScheduleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ScheduleAssignment
     * @example
     * // Get one ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentFindFirstArgs} args - Arguments to find a ScheduleAssignment
     * @example
     * // Get one ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleAssignmentFindFirstArgs>(args?: SelectSubset<T, ScheduleAssignmentFindFirstArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentFindFirstOrThrowArgs} args - Arguments to find a ScheduleAssignment
     * @example
     * // Get one ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleAssignments
     * const scheduleAssignments = await prisma.scheduleAssignment.findMany()
     * 
     * // Get first 10 ScheduleAssignments
     * const scheduleAssignments = await prisma.scheduleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleAssignmentWithIdOnly = await prisma.scheduleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleAssignmentFindManyArgs>(args?: SelectSubset<T, ScheduleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleAssignment.
     * @param {ScheduleAssignmentCreateArgs} args - Arguments to create a ScheduleAssignment.
     * @example
     * // Create one ScheduleAssignment
     * const ScheduleAssignment = await prisma.scheduleAssignment.create({
     *   data: {
     *     // ... data to create a ScheduleAssignment
     *   }
     * })
     * 
     */
    create<T extends ScheduleAssignmentCreateArgs>(args: SelectSubset<T, ScheduleAssignmentCreateArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleAssignments.
     * @param {ScheduleAssignmentCreateManyArgs} args - Arguments to create many ScheduleAssignments.
     * @example
     * // Create many ScheduleAssignments
     * const scheduleAssignment = await prisma.scheduleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleAssignmentCreateManyArgs>(args?: SelectSubset<T, ScheduleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleAssignments and returns the data saved in the database.
     * @param {ScheduleAssignmentCreateManyAndReturnArgs} args - Arguments to create many ScheduleAssignments.
     * @example
     * // Create many ScheduleAssignments
     * const scheduleAssignment = await prisma.scheduleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleAssignments and only return the `id`
     * const scheduleAssignmentWithIdOnly = await prisma.scheduleAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleAssignment.
     * @param {ScheduleAssignmentDeleteArgs} args - Arguments to delete one ScheduleAssignment.
     * @example
     * // Delete one ScheduleAssignment
     * const ScheduleAssignment = await prisma.scheduleAssignment.delete({
     *   where: {
     *     // ... filter to delete one ScheduleAssignment
     *   }
     * })
     * 
     */
    delete<T extends ScheduleAssignmentDeleteArgs>(args: SelectSubset<T, ScheduleAssignmentDeleteArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleAssignment.
     * @param {ScheduleAssignmentUpdateArgs} args - Arguments to update one ScheduleAssignment.
     * @example
     * // Update one ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleAssignmentUpdateArgs>(args: SelectSubset<T, ScheduleAssignmentUpdateArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleAssignments.
     * @param {ScheduleAssignmentDeleteManyArgs} args - Arguments to filter ScheduleAssignments to delete.
     * @example
     * // Delete a few ScheduleAssignments
     * const { count } = await prisma.scheduleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleAssignmentDeleteManyArgs>(args?: SelectSubset<T, ScheduleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleAssignments
     * const scheduleAssignment = await prisma.scheduleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleAssignmentUpdateManyArgs>(args: SelectSubset<T, ScheduleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleAssignments and returns the data updated in the database.
     * @param {ScheduleAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ScheduleAssignments.
     * @example
     * // Update many ScheduleAssignments
     * const scheduleAssignment = await prisma.scheduleAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleAssignments and only return the `id`
     * const scheduleAssignmentWithIdOnly = await prisma.scheduleAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleAssignment.
     * @param {ScheduleAssignmentUpsertArgs} args - Arguments to update or create a ScheduleAssignment.
     * @example
     * // Update or create a ScheduleAssignment
     * const scheduleAssignment = await prisma.scheduleAssignment.upsert({
     *   create: {
     *     // ... data to create a ScheduleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleAssignmentUpsertArgs>(args: SelectSubset<T, ScheduleAssignmentUpsertArgs<ExtArgs>>): Prisma__ScheduleAssignmentClient<$Result.GetResult<Prisma.$ScheduleAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentCountArgs} args - Arguments to filter ScheduleAssignments to count.
     * @example
     * // Count the number of ScheduleAssignments
     * const count = await prisma.scheduleAssignment.count({
     *   where: {
     *     // ... the filter for the ScheduleAssignments we want to count
     *   }
     * })
    **/
    count<T extends ScheduleAssignmentCountArgs>(
      args?: Subset<T, ScheduleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAssignmentAggregateArgs>(args: Subset<T, ScheduleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetScheduleAssignmentAggregateType<T>>

    /**
     * Group by ScheduleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleAssignment model
   */
  readonly fields: ScheduleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends WeeklyScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyScheduleDefaultArgs<ExtArgs>>): Prisma__WeeklyScheduleClient<$Result.GetResult<Prisma.$WeeklySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dutyPosition<T extends ScheduleAssignment$dutyPositionArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleAssignment$dutyPositionArgs<ExtArgs>>): Prisma__DutyPositionClient<$Result.GetResult<Prisma.$DutyPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleAssignment model
   */
  interface ScheduleAssignmentFieldRefs {
    readonly id: FieldRef<"ScheduleAssignment", 'String'>
    readonly scheduleId: FieldRef<"ScheduleAssignment", 'String'>
    readonly dutyPositionId: FieldRef<"ScheduleAssignment", 'String'>
    readonly memberId: FieldRef<"ScheduleAssignment", 'String'>
    readonly status: FieldRef<"ScheduleAssignment", 'String'>
    readonly confirmedAt: FieldRef<"ScheduleAssignment", 'DateTime'>
    readonly releasedAt: FieldRef<"ScheduleAssignment", 'DateTime'>
    readonly notes: FieldRef<"ScheduleAssignment", 'String'>
    readonly createdAt: FieldRef<"ScheduleAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleAssignment findUnique
   */
  export type ScheduleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAssignment to fetch.
     */
    where: ScheduleAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment findUniqueOrThrow
   */
  export type ScheduleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAssignment to fetch.
     */
    where: ScheduleAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment findFirst
   */
  export type ScheduleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAssignment to fetch.
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAssignments to fetch.
     */
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleAssignments.
     */
    cursor?: ScheduleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleAssignments.
     */
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment findFirstOrThrow
   */
  export type ScheduleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAssignment to fetch.
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAssignments to fetch.
     */
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleAssignments.
     */
    cursor?: ScheduleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleAssignments.
     */
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment findMany
   */
  export type ScheduleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAssignments to fetch.
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAssignments to fetch.
     */
    orderBy?: ScheduleAssignmentOrderByWithRelationInput | ScheduleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleAssignments.
     */
    cursor?: ScheduleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAssignments.
     */
    skip?: number
    distinct?: ScheduleAssignmentScalarFieldEnum | ScheduleAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment create
   */
  export type ScheduleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleAssignment.
     */
    data: XOR<ScheduleAssignmentCreateInput, ScheduleAssignmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment createMany
   */
  export type ScheduleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleAssignments.
     */
    data: ScheduleAssignmentCreateManyInput | ScheduleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleAssignment createManyAndReturn
   */
  export type ScheduleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleAssignments.
     */
    data: ScheduleAssignmentCreateManyInput | ScheduleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleAssignment update
   */
  export type ScheduleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleAssignment.
     */
    data: XOR<ScheduleAssignmentUpdateInput, ScheduleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ScheduleAssignment to update.
     */
    where: ScheduleAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment updateMany
   */
  export type ScheduleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleAssignments.
     */
    data: XOR<ScheduleAssignmentUpdateManyMutationInput, ScheduleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleAssignments to update
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * Limit how many ScheduleAssignments to update.
     */
    limit?: number
  }

  /**
   * ScheduleAssignment updateManyAndReturn
   */
  export type ScheduleAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleAssignments.
     */
    data: XOR<ScheduleAssignmentUpdateManyMutationInput, ScheduleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleAssignments to update
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * Limit how many ScheduleAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleAssignment upsert
   */
  export type ScheduleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleAssignment to update in case it exists.
     */
    where: ScheduleAssignmentWhereUniqueInput
    /**
     * In case the ScheduleAssignment found by the `where` argument doesn't exist, create a new ScheduleAssignment with this data.
     */
    create: XOR<ScheduleAssignmentCreateInput, ScheduleAssignmentUncheckedCreateInput>
    /**
     * In case the ScheduleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleAssignmentUpdateInput, ScheduleAssignmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment delete
   */
  export type ScheduleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ScheduleAssignment to delete.
     */
    where: ScheduleAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ScheduleAssignment deleteMany
   */
  export type ScheduleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleAssignments to delete
     */
    where?: ScheduleAssignmentWhereInput
    /**
     * Limit how many ScheduleAssignments to delete.
     */
    limit?: number
  }

  /**
   * ScheduleAssignment.dutyPosition
   */
  export type ScheduleAssignment$dutyPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyPosition
     */
    select?: DutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyPosition
     */
    omit?: DutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyPositionInclude<ExtArgs> | null
    where?: DutyPositionWhereInput
  }

  /**
   * ScheduleAssignment without action
   */
  export type ScheduleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAssignment
     */
    select?: ScheduleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAssignment
     */
    omit?: ScheduleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model LockupStatus
   */

  export type AggregateLockupStatus = {
    _count: LockupStatusCountAggregateOutputType | null
    _min: LockupStatusMinAggregateOutputType | null
    _max: LockupStatusMaxAggregateOutputType | null
  }

  export type LockupStatusMinAggregateOutputType = {
    id: string | null
    date: Date | null
    currentHolderId: string | null
    acquiredAt: Date | null
    buildingStatus: string | null
    securedAt: Date | null
    securedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LockupStatusMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    currentHolderId: string | null
    acquiredAt: Date | null
    buildingStatus: string | null
    securedAt: Date | null
    securedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LockupStatusCountAggregateOutputType = {
    id: number
    date: number
    currentHolderId: number
    acquiredAt: number
    buildingStatus: number
    securedAt: number
    securedBy: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LockupStatusMinAggregateInputType = {
    id?: true
    date?: true
    currentHolderId?: true
    acquiredAt?: true
    buildingStatus?: true
    securedAt?: true
    securedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LockupStatusMaxAggregateInputType = {
    id?: true
    date?: true
    currentHolderId?: true
    acquiredAt?: true
    buildingStatus?: true
    securedAt?: true
    securedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LockupStatusCountAggregateInputType = {
    id?: true
    date?: true
    currentHolderId?: true
    acquiredAt?: true
    buildingStatus?: true
    securedAt?: true
    securedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LockupStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupStatus to aggregate.
     */
    where?: LockupStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupStatuses to fetch.
     */
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LockupStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LockupStatuses
    **/
    _count?: true | LockupStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LockupStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LockupStatusMaxAggregateInputType
  }

  export type GetLockupStatusAggregateType<T extends LockupStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateLockupStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLockupStatus[P]>
      : GetScalarType<T[P], AggregateLockupStatus[P]>
  }




  export type LockupStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupStatusWhereInput
    orderBy?: LockupStatusOrderByWithAggregationInput | LockupStatusOrderByWithAggregationInput[]
    by: LockupStatusScalarFieldEnum[] | LockupStatusScalarFieldEnum
    having?: LockupStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LockupStatusCountAggregateInputType | true
    _min?: LockupStatusMinAggregateInputType
    _max?: LockupStatusMaxAggregateInputType
  }

  export type LockupStatusGroupByOutputType = {
    id: string
    date: Date
    currentHolderId: string | null
    acquiredAt: Date | null
    buildingStatus: string
    securedAt: Date | null
    securedBy: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LockupStatusCountAggregateOutputType | null
    _min: LockupStatusMinAggregateOutputType | null
    _max: LockupStatusMaxAggregateOutputType | null
  }

  type GetLockupStatusGroupByPayload<T extends LockupStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LockupStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LockupStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LockupStatusGroupByOutputType[P]>
            : GetScalarType<T[P], LockupStatusGroupByOutputType[P]>
        }
      >
    >


  export type LockupStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentHolderId?: boolean
    acquiredAt?: boolean
    buildingStatus?: boolean
    securedAt?: boolean
    securedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
    transfers?: boolean | LockupStatus$transfersArgs<ExtArgs>
    execution?: boolean | LockupStatus$executionArgs<ExtArgs>
    _count?: boolean | LockupStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupStatus"]>

  export type LockupStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentHolderId?: boolean
    acquiredAt?: boolean
    buildingStatus?: boolean
    securedAt?: boolean
    securedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
  }, ExtArgs["result"]["lockupStatus"]>

  export type LockupStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentHolderId?: boolean
    acquiredAt?: boolean
    buildingStatus?: boolean
    securedAt?: boolean
    securedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
  }, ExtArgs["result"]["lockupStatus"]>

  export type LockupStatusSelectScalar = {
    id?: boolean
    date?: boolean
    currentHolderId?: boolean
    acquiredAt?: boolean
    buildingStatus?: boolean
    securedAt?: boolean
    securedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LockupStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "currentHolderId" | "acquiredAt" | "buildingStatus" | "securedAt" | "securedBy" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["lockupStatus"]>
  export type LockupStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
    transfers?: boolean | LockupStatus$transfersArgs<ExtArgs>
    execution?: boolean | LockupStatus$executionArgs<ExtArgs>
    _count?: boolean | LockupStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LockupStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
  }
  export type LockupStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHolder?: boolean | LockupStatus$currentHolderArgs<ExtArgs>
    securedByMember?: boolean | LockupStatus$securedByMemberArgs<ExtArgs>
  }

  export type $LockupStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LockupStatus"
    objects: {
      currentHolder: Prisma.$MemberPayload<ExtArgs> | null
      securedByMember: Prisma.$MemberPayload<ExtArgs> | null
      transfers: Prisma.$LockupTransferPayload<ExtArgs>[]
      execution: Prisma.$LockupExecutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      currentHolderId: string | null
      acquiredAt: Date | null
      buildingStatus: string
      securedAt: Date | null
      securedBy: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lockupStatus"]>
    composites: {}
  }

  type LockupStatusGetPayload<S extends boolean | null | undefined | LockupStatusDefaultArgs> = $Result.GetResult<Prisma.$LockupStatusPayload, S>

  type LockupStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LockupStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LockupStatusCountAggregateInputType | true
    }

  export interface LockupStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LockupStatus'], meta: { name: 'LockupStatus' } }
    /**
     * Find zero or one LockupStatus that matches the filter.
     * @param {LockupStatusFindUniqueArgs} args - Arguments to find a LockupStatus
     * @example
     * // Get one LockupStatus
     * const lockupStatus = await prisma.lockupStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LockupStatusFindUniqueArgs>(args: SelectSubset<T, LockupStatusFindUniqueArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LockupStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LockupStatusFindUniqueOrThrowArgs} args - Arguments to find a LockupStatus
     * @example
     * // Get one LockupStatus
     * const lockupStatus = await prisma.lockupStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LockupStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, LockupStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusFindFirstArgs} args - Arguments to find a LockupStatus
     * @example
     * // Get one LockupStatus
     * const lockupStatus = await prisma.lockupStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LockupStatusFindFirstArgs>(args?: SelectSubset<T, LockupStatusFindFirstArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusFindFirstOrThrowArgs} args - Arguments to find a LockupStatus
     * @example
     * // Get one LockupStatus
     * const lockupStatus = await prisma.lockupStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LockupStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, LockupStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LockupStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LockupStatuses
     * const lockupStatuses = await prisma.lockupStatus.findMany()
     * 
     * // Get first 10 LockupStatuses
     * const lockupStatuses = await prisma.lockupStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lockupStatusWithIdOnly = await prisma.lockupStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LockupStatusFindManyArgs>(args?: SelectSubset<T, LockupStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LockupStatus.
     * @param {LockupStatusCreateArgs} args - Arguments to create a LockupStatus.
     * @example
     * // Create one LockupStatus
     * const LockupStatus = await prisma.lockupStatus.create({
     *   data: {
     *     // ... data to create a LockupStatus
     *   }
     * })
     * 
     */
    create<T extends LockupStatusCreateArgs>(args: SelectSubset<T, LockupStatusCreateArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LockupStatuses.
     * @param {LockupStatusCreateManyArgs} args - Arguments to create many LockupStatuses.
     * @example
     * // Create many LockupStatuses
     * const lockupStatus = await prisma.lockupStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LockupStatusCreateManyArgs>(args?: SelectSubset<T, LockupStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LockupStatuses and returns the data saved in the database.
     * @param {LockupStatusCreateManyAndReturnArgs} args - Arguments to create many LockupStatuses.
     * @example
     * // Create many LockupStatuses
     * const lockupStatus = await prisma.lockupStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LockupStatuses and only return the `id`
     * const lockupStatusWithIdOnly = await prisma.lockupStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LockupStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, LockupStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LockupStatus.
     * @param {LockupStatusDeleteArgs} args - Arguments to delete one LockupStatus.
     * @example
     * // Delete one LockupStatus
     * const LockupStatus = await prisma.lockupStatus.delete({
     *   where: {
     *     // ... filter to delete one LockupStatus
     *   }
     * })
     * 
     */
    delete<T extends LockupStatusDeleteArgs>(args: SelectSubset<T, LockupStatusDeleteArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LockupStatus.
     * @param {LockupStatusUpdateArgs} args - Arguments to update one LockupStatus.
     * @example
     * // Update one LockupStatus
     * const lockupStatus = await prisma.lockupStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LockupStatusUpdateArgs>(args: SelectSubset<T, LockupStatusUpdateArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LockupStatuses.
     * @param {LockupStatusDeleteManyArgs} args - Arguments to filter LockupStatuses to delete.
     * @example
     * // Delete a few LockupStatuses
     * const { count } = await prisma.lockupStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LockupStatusDeleteManyArgs>(args?: SelectSubset<T, LockupStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LockupStatuses
     * const lockupStatus = await prisma.lockupStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LockupStatusUpdateManyArgs>(args: SelectSubset<T, LockupStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupStatuses and returns the data updated in the database.
     * @param {LockupStatusUpdateManyAndReturnArgs} args - Arguments to update many LockupStatuses.
     * @example
     * // Update many LockupStatuses
     * const lockupStatus = await prisma.lockupStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LockupStatuses and only return the `id`
     * const lockupStatusWithIdOnly = await prisma.lockupStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LockupStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, LockupStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LockupStatus.
     * @param {LockupStatusUpsertArgs} args - Arguments to update or create a LockupStatus.
     * @example
     * // Update or create a LockupStatus
     * const lockupStatus = await prisma.lockupStatus.upsert({
     *   create: {
     *     // ... data to create a LockupStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LockupStatus we want to update
     *   }
     * })
     */
    upsert<T extends LockupStatusUpsertArgs>(args: SelectSubset<T, LockupStatusUpsertArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LockupStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusCountArgs} args - Arguments to filter LockupStatuses to count.
     * @example
     * // Count the number of LockupStatuses
     * const count = await prisma.lockupStatus.count({
     *   where: {
     *     // ... the filter for the LockupStatuses we want to count
     *   }
     * })
    **/
    count<T extends LockupStatusCountArgs>(
      args?: Subset<T, LockupStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LockupStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LockupStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LockupStatusAggregateArgs>(args: Subset<T, LockupStatusAggregateArgs>): Prisma.PrismaPromise<GetLockupStatusAggregateType<T>>

    /**
     * Group by LockupStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LockupStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LockupStatusGroupByArgs['orderBy'] }
        : { orderBy?: LockupStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LockupStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLockupStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LockupStatus model
   */
  readonly fields: LockupStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LockupStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LockupStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentHolder<T extends LockupStatus$currentHolderArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatus$currentHolderArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    securedByMember<T extends LockupStatus$securedByMemberArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatus$securedByMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transfers<T extends LockupStatus$transfersArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatus$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    execution<T extends LockupStatus$executionArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatus$executionArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LockupStatus model
   */
  interface LockupStatusFieldRefs {
    readonly id: FieldRef<"LockupStatus", 'String'>
    readonly date: FieldRef<"LockupStatus", 'DateTime'>
    readonly currentHolderId: FieldRef<"LockupStatus", 'String'>
    readonly acquiredAt: FieldRef<"LockupStatus", 'DateTime'>
    readonly buildingStatus: FieldRef<"LockupStatus", 'String'>
    readonly securedAt: FieldRef<"LockupStatus", 'DateTime'>
    readonly securedBy: FieldRef<"LockupStatus", 'String'>
    readonly isActive: FieldRef<"LockupStatus", 'Boolean'>
    readonly createdAt: FieldRef<"LockupStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"LockupStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LockupStatus findUnique
   */
  export type LockupStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter, which LockupStatus to fetch.
     */
    where: LockupStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus findUniqueOrThrow
   */
  export type LockupStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter, which LockupStatus to fetch.
     */
    where: LockupStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus findFirst
   */
  export type LockupStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter, which LockupStatus to fetch.
     */
    where?: LockupStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupStatuses to fetch.
     */
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupStatuses.
     */
    cursor?: LockupStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupStatuses.
     */
    distinct?: LockupStatusScalarFieldEnum | LockupStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus findFirstOrThrow
   */
  export type LockupStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter, which LockupStatus to fetch.
     */
    where?: LockupStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupStatuses to fetch.
     */
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupStatuses.
     */
    cursor?: LockupStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupStatuses.
     */
    distinct?: LockupStatusScalarFieldEnum | LockupStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus findMany
   */
  export type LockupStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter, which LockupStatuses to fetch.
     */
    where?: LockupStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupStatuses to fetch.
     */
    orderBy?: LockupStatusOrderByWithRelationInput | LockupStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LockupStatuses.
     */
    cursor?: LockupStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupStatuses.
     */
    skip?: number
    distinct?: LockupStatusScalarFieldEnum | LockupStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus create
   */
  export type LockupStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a LockupStatus.
     */
    data: XOR<LockupStatusCreateInput, LockupStatusUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus createMany
   */
  export type LockupStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LockupStatuses.
     */
    data: LockupStatusCreateManyInput | LockupStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LockupStatus createManyAndReturn
   */
  export type LockupStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * The data used to create many LockupStatuses.
     */
    data: LockupStatusCreateManyInput | LockupStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupStatus update
   */
  export type LockupStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a LockupStatus.
     */
    data: XOR<LockupStatusUpdateInput, LockupStatusUncheckedUpdateInput>
    /**
     * Choose, which LockupStatus to update.
     */
    where: LockupStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus updateMany
   */
  export type LockupStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LockupStatuses.
     */
    data: XOR<LockupStatusUpdateManyMutationInput, LockupStatusUncheckedUpdateManyInput>
    /**
     * Filter which LockupStatuses to update
     */
    where?: LockupStatusWhereInput
    /**
     * Limit how many LockupStatuses to update.
     */
    limit?: number
  }

  /**
   * LockupStatus updateManyAndReturn
   */
  export type LockupStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * The data used to update LockupStatuses.
     */
    data: XOR<LockupStatusUpdateManyMutationInput, LockupStatusUncheckedUpdateManyInput>
    /**
     * Filter which LockupStatuses to update
     */
    where?: LockupStatusWhereInput
    /**
     * Limit how many LockupStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupStatus upsert
   */
  export type LockupStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the LockupStatus to update in case it exists.
     */
    where: LockupStatusWhereUniqueInput
    /**
     * In case the LockupStatus found by the `where` argument doesn't exist, create a new LockupStatus with this data.
     */
    create: XOR<LockupStatusCreateInput, LockupStatusUncheckedCreateInput>
    /**
     * In case the LockupStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LockupStatusUpdateInput, LockupStatusUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus delete
   */
  export type LockupStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
    /**
     * Filter which LockupStatus to delete.
     */
    where: LockupStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupStatus deleteMany
   */
  export type LockupStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupStatuses to delete
     */
    where?: LockupStatusWhereInput
    /**
     * Limit how many LockupStatuses to delete.
     */
    limit?: number
  }

  /**
   * LockupStatus.currentHolder
   */
  export type LockupStatus$currentHolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * LockupStatus.securedByMember
   */
  export type LockupStatus$securedByMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * LockupStatus.transfers
   */
  export type LockupStatus$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    where?: LockupTransferWhereInput
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    cursor?: LockupTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
  }

  /**
   * LockupStatus.execution
   */
  export type LockupStatus$executionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    where?: LockupExecutionWhereInput
  }

  /**
   * LockupStatus without action
   */
  export type LockupStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupStatus
     */
    select?: LockupStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupStatus
     */
    omit?: LockupStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupStatusInclude<ExtArgs> | null
  }


  /**
   * Model LockupTransfer
   */

  export type AggregateLockupTransfer = {
    _count: LockupTransferCountAggregateOutputType | null
    _min: LockupTransferMinAggregateOutputType | null
    _max: LockupTransferMaxAggregateOutputType | null
  }

  export type LockupTransferMinAggregateOutputType = {
    id: string | null
    lockupStatusId: string | null
    fromMemberId: string | null
    toMemberId: string | null
    transferredAt: Date | null
    reason: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type LockupTransferMaxAggregateOutputType = {
    id: string | null
    lockupStatusId: string | null
    fromMemberId: string | null
    toMemberId: string | null
    transferredAt: Date | null
    reason: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type LockupTransferCountAggregateOutputType = {
    id: number
    lockupStatusId: number
    fromMemberId: number
    toMemberId: number
    transferredAt: number
    reason: number
    notes: number
    createdAt: number
    _all: number
  }


  export type LockupTransferMinAggregateInputType = {
    id?: true
    lockupStatusId?: true
    fromMemberId?: true
    toMemberId?: true
    transferredAt?: true
    reason?: true
    notes?: true
    createdAt?: true
  }

  export type LockupTransferMaxAggregateInputType = {
    id?: true
    lockupStatusId?: true
    fromMemberId?: true
    toMemberId?: true
    transferredAt?: true
    reason?: true
    notes?: true
    createdAt?: true
  }

  export type LockupTransferCountAggregateInputType = {
    id?: true
    lockupStatusId?: true
    fromMemberId?: true
    toMemberId?: true
    transferredAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type LockupTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupTransfer to aggregate.
     */
    where?: LockupTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupTransfers to fetch.
     */
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LockupTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LockupTransfers
    **/
    _count?: true | LockupTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LockupTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LockupTransferMaxAggregateInputType
  }

  export type GetLockupTransferAggregateType<T extends LockupTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateLockupTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLockupTransfer[P]>
      : GetScalarType<T[P], AggregateLockupTransfer[P]>
  }




  export type LockupTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupTransferWhereInput
    orderBy?: LockupTransferOrderByWithAggregationInput | LockupTransferOrderByWithAggregationInput[]
    by: LockupTransferScalarFieldEnum[] | LockupTransferScalarFieldEnum
    having?: LockupTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LockupTransferCountAggregateInputType | true
    _min?: LockupTransferMinAggregateInputType
    _max?: LockupTransferMaxAggregateInputType
  }

  export type LockupTransferGroupByOutputType = {
    id: string
    lockupStatusId: string
    fromMemberId: string
    toMemberId: string
    transferredAt: Date
    reason: string
    notes: string | null
    createdAt: Date
    _count: LockupTransferCountAggregateOutputType | null
    _min: LockupTransferMinAggregateOutputType | null
    _max: LockupTransferMaxAggregateOutputType | null
  }

  type GetLockupTransferGroupByPayload<T extends LockupTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LockupTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LockupTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LockupTransferGroupByOutputType[P]>
            : GetScalarType<T[P], LockupTransferGroupByOutputType[P]>
        }
      >
    >


  export type LockupTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    transferredAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupTransfer"]>

  export type LockupTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    transferredAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupTransfer"]>

  export type LockupTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    transferredAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupTransfer"]>

  export type LockupTransferSelectScalar = {
    id?: boolean
    lockupStatusId?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    transferredAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type LockupTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lockupStatusId" | "fromMemberId" | "toMemberId" | "transferredAt" | "reason" | "notes" | "createdAt", ExtArgs["result"]["lockupTransfer"]>
  export type LockupTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LockupTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LockupTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    fromMember?: boolean | MemberDefaultArgs<ExtArgs>
    toMember?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $LockupTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LockupTransfer"
    objects: {
      lockupStatus: Prisma.$LockupStatusPayload<ExtArgs>
      fromMember: Prisma.$MemberPayload<ExtArgs>
      toMember: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lockupStatusId: string
      fromMemberId: string
      toMemberId: string
      transferredAt: Date
      reason: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["lockupTransfer"]>
    composites: {}
  }

  type LockupTransferGetPayload<S extends boolean | null | undefined | LockupTransferDefaultArgs> = $Result.GetResult<Prisma.$LockupTransferPayload, S>

  type LockupTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LockupTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LockupTransferCountAggregateInputType | true
    }

  export interface LockupTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LockupTransfer'], meta: { name: 'LockupTransfer' } }
    /**
     * Find zero or one LockupTransfer that matches the filter.
     * @param {LockupTransferFindUniqueArgs} args - Arguments to find a LockupTransfer
     * @example
     * // Get one LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LockupTransferFindUniqueArgs>(args: SelectSubset<T, LockupTransferFindUniqueArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LockupTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LockupTransferFindUniqueOrThrowArgs} args - Arguments to find a LockupTransfer
     * @example
     * // Get one LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LockupTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, LockupTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferFindFirstArgs} args - Arguments to find a LockupTransfer
     * @example
     * // Get one LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LockupTransferFindFirstArgs>(args?: SelectSubset<T, LockupTransferFindFirstArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferFindFirstOrThrowArgs} args - Arguments to find a LockupTransfer
     * @example
     * // Get one LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LockupTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, LockupTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LockupTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LockupTransfers
     * const lockupTransfers = await prisma.lockupTransfer.findMany()
     * 
     * // Get first 10 LockupTransfers
     * const lockupTransfers = await prisma.lockupTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lockupTransferWithIdOnly = await prisma.lockupTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LockupTransferFindManyArgs>(args?: SelectSubset<T, LockupTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LockupTransfer.
     * @param {LockupTransferCreateArgs} args - Arguments to create a LockupTransfer.
     * @example
     * // Create one LockupTransfer
     * const LockupTransfer = await prisma.lockupTransfer.create({
     *   data: {
     *     // ... data to create a LockupTransfer
     *   }
     * })
     * 
     */
    create<T extends LockupTransferCreateArgs>(args: SelectSubset<T, LockupTransferCreateArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LockupTransfers.
     * @param {LockupTransferCreateManyArgs} args - Arguments to create many LockupTransfers.
     * @example
     * // Create many LockupTransfers
     * const lockupTransfer = await prisma.lockupTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LockupTransferCreateManyArgs>(args?: SelectSubset<T, LockupTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LockupTransfers and returns the data saved in the database.
     * @param {LockupTransferCreateManyAndReturnArgs} args - Arguments to create many LockupTransfers.
     * @example
     * // Create many LockupTransfers
     * const lockupTransfer = await prisma.lockupTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LockupTransfers and only return the `id`
     * const lockupTransferWithIdOnly = await prisma.lockupTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LockupTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, LockupTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LockupTransfer.
     * @param {LockupTransferDeleteArgs} args - Arguments to delete one LockupTransfer.
     * @example
     * // Delete one LockupTransfer
     * const LockupTransfer = await prisma.lockupTransfer.delete({
     *   where: {
     *     // ... filter to delete one LockupTransfer
     *   }
     * })
     * 
     */
    delete<T extends LockupTransferDeleteArgs>(args: SelectSubset<T, LockupTransferDeleteArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LockupTransfer.
     * @param {LockupTransferUpdateArgs} args - Arguments to update one LockupTransfer.
     * @example
     * // Update one LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LockupTransferUpdateArgs>(args: SelectSubset<T, LockupTransferUpdateArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LockupTransfers.
     * @param {LockupTransferDeleteManyArgs} args - Arguments to filter LockupTransfers to delete.
     * @example
     * // Delete a few LockupTransfers
     * const { count } = await prisma.lockupTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LockupTransferDeleteManyArgs>(args?: SelectSubset<T, LockupTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LockupTransfers
     * const lockupTransfer = await prisma.lockupTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LockupTransferUpdateManyArgs>(args: SelectSubset<T, LockupTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupTransfers and returns the data updated in the database.
     * @param {LockupTransferUpdateManyAndReturnArgs} args - Arguments to update many LockupTransfers.
     * @example
     * // Update many LockupTransfers
     * const lockupTransfer = await prisma.lockupTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LockupTransfers and only return the `id`
     * const lockupTransferWithIdOnly = await prisma.lockupTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LockupTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, LockupTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LockupTransfer.
     * @param {LockupTransferUpsertArgs} args - Arguments to update or create a LockupTransfer.
     * @example
     * // Update or create a LockupTransfer
     * const lockupTransfer = await prisma.lockupTransfer.upsert({
     *   create: {
     *     // ... data to create a LockupTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LockupTransfer we want to update
     *   }
     * })
     */
    upsert<T extends LockupTransferUpsertArgs>(args: SelectSubset<T, LockupTransferUpsertArgs<ExtArgs>>): Prisma__LockupTransferClient<$Result.GetResult<Prisma.$LockupTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LockupTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferCountArgs} args - Arguments to filter LockupTransfers to count.
     * @example
     * // Count the number of LockupTransfers
     * const count = await prisma.lockupTransfer.count({
     *   where: {
     *     // ... the filter for the LockupTransfers we want to count
     *   }
     * })
    **/
    count<T extends LockupTransferCountArgs>(
      args?: Subset<T, LockupTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LockupTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LockupTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LockupTransferAggregateArgs>(args: Subset<T, LockupTransferAggregateArgs>): Prisma.PrismaPromise<GetLockupTransferAggregateType<T>>

    /**
     * Group by LockupTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LockupTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LockupTransferGroupByArgs['orderBy'] }
        : { orderBy?: LockupTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LockupTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLockupTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LockupTransfer model
   */
  readonly fields: LockupTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LockupTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LockupTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lockupStatus<T extends LockupStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatusDefaultArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromMember<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toMember<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LockupTransfer model
   */
  interface LockupTransferFieldRefs {
    readonly id: FieldRef<"LockupTransfer", 'String'>
    readonly lockupStatusId: FieldRef<"LockupTransfer", 'String'>
    readonly fromMemberId: FieldRef<"LockupTransfer", 'String'>
    readonly toMemberId: FieldRef<"LockupTransfer", 'String'>
    readonly transferredAt: FieldRef<"LockupTransfer", 'DateTime'>
    readonly reason: FieldRef<"LockupTransfer", 'String'>
    readonly notes: FieldRef<"LockupTransfer", 'String'>
    readonly createdAt: FieldRef<"LockupTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LockupTransfer findUnique
   */
  export type LockupTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter, which LockupTransfer to fetch.
     */
    where: LockupTransferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer findUniqueOrThrow
   */
  export type LockupTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter, which LockupTransfer to fetch.
     */
    where: LockupTransferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer findFirst
   */
  export type LockupTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter, which LockupTransfer to fetch.
     */
    where?: LockupTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupTransfers to fetch.
     */
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupTransfers.
     */
    cursor?: LockupTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupTransfers.
     */
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer findFirstOrThrow
   */
  export type LockupTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter, which LockupTransfer to fetch.
     */
    where?: LockupTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupTransfers to fetch.
     */
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupTransfers.
     */
    cursor?: LockupTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupTransfers.
     */
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer findMany
   */
  export type LockupTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter, which LockupTransfers to fetch.
     */
    where?: LockupTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupTransfers to fetch.
     */
    orderBy?: LockupTransferOrderByWithRelationInput | LockupTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LockupTransfers.
     */
    cursor?: LockupTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupTransfers.
     */
    skip?: number
    distinct?: LockupTransferScalarFieldEnum | LockupTransferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer create
   */
  export type LockupTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a LockupTransfer.
     */
    data: XOR<LockupTransferCreateInput, LockupTransferUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer createMany
   */
  export type LockupTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LockupTransfers.
     */
    data: LockupTransferCreateManyInput | LockupTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LockupTransfer createManyAndReturn
   */
  export type LockupTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * The data used to create many LockupTransfers.
     */
    data: LockupTransferCreateManyInput | LockupTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupTransfer update
   */
  export type LockupTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a LockupTransfer.
     */
    data: XOR<LockupTransferUpdateInput, LockupTransferUncheckedUpdateInput>
    /**
     * Choose, which LockupTransfer to update.
     */
    where: LockupTransferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer updateMany
   */
  export type LockupTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LockupTransfers.
     */
    data: XOR<LockupTransferUpdateManyMutationInput, LockupTransferUncheckedUpdateManyInput>
    /**
     * Filter which LockupTransfers to update
     */
    where?: LockupTransferWhereInput
    /**
     * Limit how many LockupTransfers to update.
     */
    limit?: number
  }

  /**
   * LockupTransfer updateManyAndReturn
   */
  export type LockupTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * The data used to update LockupTransfers.
     */
    data: XOR<LockupTransferUpdateManyMutationInput, LockupTransferUncheckedUpdateManyInput>
    /**
     * Filter which LockupTransfers to update
     */
    where?: LockupTransferWhereInput
    /**
     * Limit how many LockupTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupTransfer upsert
   */
  export type LockupTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the LockupTransfer to update in case it exists.
     */
    where: LockupTransferWhereUniqueInput
    /**
     * In case the LockupTransfer found by the `where` argument doesn't exist, create a new LockupTransfer with this data.
     */
    create: XOR<LockupTransferCreateInput, LockupTransferUncheckedCreateInput>
    /**
     * In case the LockupTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LockupTransferUpdateInput, LockupTransferUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer delete
   */
  export type LockupTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
    /**
     * Filter which LockupTransfer to delete.
     */
    where: LockupTransferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupTransfer deleteMany
   */
  export type LockupTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupTransfers to delete
     */
    where?: LockupTransferWhereInput
    /**
     * Limit how many LockupTransfers to delete.
     */
    limit?: number
  }

  /**
   * LockupTransfer without action
   */
  export type LockupTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupTransfer
     */
    select?: LockupTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupTransfer
     */
    omit?: LockupTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupTransferInclude<ExtArgs> | null
  }


  /**
   * Model LockupExecution
   */

  export type AggregateLockupExecution = {
    _count: LockupExecutionCountAggregateOutputType | null
    _avg: LockupExecutionAvgAggregateOutputType | null
    _sum: LockupExecutionSumAggregateOutputType | null
    _min: LockupExecutionMinAggregateOutputType | null
    _max: LockupExecutionMaxAggregateOutputType | null
  }

  export type LockupExecutionAvgAggregateOutputType = {
    totalCheckedOut: number | null
  }

  export type LockupExecutionSumAggregateOutputType = {
    totalCheckedOut: number | null
  }

  export type LockupExecutionMinAggregateOutputType = {
    id: string | null
    lockupStatusId: string | null
    executedBy: string | null
    executedAt: Date | null
    totalCheckedOut: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LockupExecutionMaxAggregateOutputType = {
    id: string | null
    lockupStatusId: string | null
    executedBy: string | null
    executedAt: Date | null
    totalCheckedOut: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LockupExecutionCountAggregateOutputType = {
    id: number
    lockupStatusId: number
    executedBy: number
    executedAt: number
    membersCheckedOut: number
    visitorsCheckedOut: number
    totalCheckedOut: number
    notes: number
    createdAt: number
    _all: number
  }


  export type LockupExecutionAvgAggregateInputType = {
    totalCheckedOut?: true
  }

  export type LockupExecutionSumAggregateInputType = {
    totalCheckedOut?: true
  }

  export type LockupExecutionMinAggregateInputType = {
    id?: true
    lockupStatusId?: true
    executedBy?: true
    executedAt?: true
    totalCheckedOut?: true
    notes?: true
    createdAt?: true
  }

  export type LockupExecutionMaxAggregateInputType = {
    id?: true
    lockupStatusId?: true
    executedBy?: true
    executedAt?: true
    totalCheckedOut?: true
    notes?: true
    createdAt?: true
  }

  export type LockupExecutionCountAggregateInputType = {
    id?: true
    lockupStatusId?: true
    executedBy?: true
    executedAt?: true
    membersCheckedOut?: true
    visitorsCheckedOut?: true
    totalCheckedOut?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type LockupExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupExecution to aggregate.
     */
    where?: LockupExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupExecutions to fetch.
     */
    orderBy?: LockupExecutionOrderByWithRelationInput | LockupExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LockupExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LockupExecutions
    **/
    _count?: true | LockupExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LockupExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LockupExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LockupExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LockupExecutionMaxAggregateInputType
  }

  export type GetLockupExecutionAggregateType<T extends LockupExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateLockupExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLockupExecution[P]>
      : GetScalarType<T[P], AggregateLockupExecution[P]>
  }




  export type LockupExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockupExecutionWhereInput
    orderBy?: LockupExecutionOrderByWithAggregationInput | LockupExecutionOrderByWithAggregationInput[]
    by: LockupExecutionScalarFieldEnum[] | LockupExecutionScalarFieldEnum
    having?: LockupExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LockupExecutionCountAggregateInputType | true
    _avg?: LockupExecutionAvgAggregateInputType
    _sum?: LockupExecutionSumAggregateInputType
    _min?: LockupExecutionMinAggregateInputType
    _max?: LockupExecutionMaxAggregateInputType
  }

  export type LockupExecutionGroupByOutputType = {
    id: string
    lockupStatusId: string
    executedBy: string
    executedAt: Date
    membersCheckedOut: JsonValue
    visitorsCheckedOut: JsonValue
    totalCheckedOut: number
    notes: string | null
    createdAt: Date
    _count: LockupExecutionCountAggregateOutputType | null
    _avg: LockupExecutionAvgAggregateOutputType | null
    _sum: LockupExecutionSumAggregateOutputType | null
    _min: LockupExecutionMinAggregateOutputType | null
    _max: LockupExecutionMaxAggregateOutputType | null
  }

  type GetLockupExecutionGroupByPayload<T extends LockupExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LockupExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LockupExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LockupExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], LockupExecutionGroupByOutputType[P]>
        }
      >
    >


  export type LockupExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    executedBy?: boolean
    executedAt?: boolean
    membersCheckedOut?: boolean
    visitorsCheckedOut?: boolean
    totalCheckedOut?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupExecution"]>

  export type LockupExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    executedBy?: boolean
    executedAt?: boolean
    membersCheckedOut?: boolean
    visitorsCheckedOut?: boolean
    totalCheckedOut?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupExecution"]>

  export type LockupExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockupStatusId?: boolean
    executedBy?: boolean
    executedAt?: boolean
    membersCheckedOut?: boolean
    visitorsCheckedOut?: boolean
    totalCheckedOut?: boolean
    notes?: boolean
    createdAt?: boolean
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockupExecution"]>

  export type LockupExecutionSelectScalar = {
    id?: boolean
    lockupStatusId?: boolean
    executedBy?: boolean
    executedAt?: boolean
    membersCheckedOut?: boolean
    visitorsCheckedOut?: boolean
    totalCheckedOut?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type LockupExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lockupStatusId" | "executedBy" | "executedAt" | "membersCheckedOut" | "visitorsCheckedOut" | "totalCheckedOut" | "notes" | "createdAt", ExtArgs["result"]["lockupExecution"]>
  export type LockupExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LockupExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LockupExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lockupStatus?: boolean | LockupStatusDefaultArgs<ExtArgs>
    executedByMember?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $LockupExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LockupExecution"
    objects: {
      lockupStatus: Prisma.$LockupStatusPayload<ExtArgs>
      executedByMember: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lockupStatusId: string
      executedBy: string
      executedAt: Date
      membersCheckedOut: Prisma.JsonValue
      visitorsCheckedOut: Prisma.JsonValue
      totalCheckedOut: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["lockupExecution"]>
    composites: {}
  }

  type LockupExecutionGetPayload<S extends boolean | null | undefined | LockupExecutionDefaultArgs> = $Result.GetResult<Prisma.$LockupExecutionPayload, S>

  type LockupExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LockupExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LockupExecutionCountAggregateInputType | true
    }

  export interface LockupExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LockupExecution'], meta: { name: 'LockupExecution' } }
    /**
     * Find zero or one LockupExecution that matches the filter.
     * @param {LockupExecutionFindUniqueArgs} args - Arguments to find a LockupExecution
     * @example
     * // Get one LockupExecution
     * const lockupExecution = await prisma.lockupExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LockupExecutionFindUniqueArgs>(args: SelectSubset<T, LockupExecutionFindUniqueArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LockupExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LockupExecutionFindUniqueOrThrowArgs} args - Arguments to find a LockupExecution
     * @example
     * // Get one LockupExecution
     * const lockupExecution = await prisma.lockupExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LockupExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, LockupExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionFindFirstArgs} args - Arguments to find a LockupExecution
     * @example
     * // Get one LockupExecution
     * const lockupExecution = await prisma.lockupExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LockupExecutionFindFirstArgs>(args?: SelectSubset<T, LockupExecutionFindFirstArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LockupExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionFindFirstOrThrowArgs} args - Arguments to find a LockupExecution
     * @example
     * // Get one LockupExecution
     * const lockupExecution = await prisma.lockupExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LockupExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, LockupExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LockupExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LockupExecutions
     * const lockupExecutions = await prisma.lockupExecution.findMany()
     * 
     * // Get first 10 LockupExecutions
     * const lockupExecutions = await prisma.lockupExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lockupExecutionWithIdOnly = await prisma.lockupExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LockupExecutionFindManyArgs>(args?: SelectSubset<T, LockupExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LockupExecution.
     * @param {LockupExecutionCreateArgs} args - Arguments to create a LockupExecution.
     * @example
     * // Create one LockupExecution
     * const LockupExecution = await prisma.lockupExecution.create({
     *   data: {
     *     // ... data to create a LockupExecution
     *   }
     * })
     * 
     */
    create<T extends LockupExecutionCreateArgs>(args: SelectSubset<T, LockupExecutionCreateArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LockupExecutions.
     * @param {LockupExecutionCreateManyArgs} args - Arguments to create many LockupExecutions.
     * @example
     * // Create many LockupExecutions
     * const lockupExecution = await prisma.lockupExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LockupExecutionCreateManyArgs>(args?: SelectSubset<T, LockupExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LockupExecutions and returns the data saved in the database.
     * @param {LockupExecutionCreateManyAndReturnArgs} args - Arguments to create many LockupExecutions.
     * @example
     * // Create many LockupExecutions
     * const lockupExecution = await prisma.lockupExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LockupExecutions and only return the `id`
     * const lockupExecutionWithIdOnly = await prisma.lockupExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LockupExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, LockupExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LockupExecution.
     * @param {LockupExecutionDeleteArgs} args - Arguments to delete one LockupExecution.
     * @example
     * // Delete one LockupExecution
     * const LockupExecution = await prisma.lockupExecution.delete({
     *   where: {
     *     // ... filter to delete one LockupExecution
     *   }
     * })
     * 
     */
    delete<T extends LockupExecutionDeleteArgs>(args: SelectSubset<T, LockupExecutionDeleteArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LockupExecution.
     * @param {LockupExecutionUpdateArgs} args - Arguments to update one LockupExecution.
     * @example
     * // Update one LockupExecution
     * const lockupExecution = await prisma.lockupExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LockupExecutionUpdateArgs>(args: SelectSubset<T, LockupExecutionUpdateArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LockupExecutions.
     * @param {LockupExecutionDeleteManyArgs} args - Arguments to filter LockupExecutions to delete.
     * @example
     * // Delete a few LockupExecutions
     * const { count } = await prisma.lockupExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LockupExecutionDeleteManyArgs>(args?: SelectSubset<T, LockupExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LockupExecutions
     * const lockupExecution = await prisma.lockupExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LockupExecutionUpdateManyArgs>(args: SelectSubset<T, LockupExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockupExecutions and returns the data updated in the database.
     * @param {LockupExecutionUpdateManyAndReturnArgs} args - Arguments to update many LockupExecutions.
     * @example
     * // Update many LockupExecutions
     * const lockupExecution = await prisma.lockupExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LockupExecutions and only return the `id`
     * const lockupExecutionWithIdOnly = await prisma.lockupExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LockupExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, LockupExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LockupExecution.
     * @param {LockupExecutionUpsertArgs} args - Arguments to update or create a LockupExecution.
     * @example
     * // Update or create a LockupExecution
     * const lockupExecution = await prisma.lockupExecution.upsert({
     *   create: {
     *     // ... data to create a LockupExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LockupExecution we want to update
     *   }
     * })
     */
    upsert<T extends LockupExecutionUpsertArgs>(args: SelectSubset<T, LockupExecutionUpsertArgs<ExtArgs>>): Prisma__LockupExecutionClient<$Result.GetResult<Prisma.$LockupExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LockupExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionCountArgs} args - Arguments to filter LockupExecutions to count.
     * @example
     * // Count the number of LockupExecutions
     * const count = await prisma.lockupExecution.count({
     *   where: {
     *     // ... the filter for the LockupExecutions we want to count
     *   }
     * })
    **/
    count<T extends LockupExecutionCountArgs>(
      args?: Subset<T, LockupExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LockupExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LockupExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LockupExecutionAggregateArgs>(args: Subset<T, LockupExecutionAggregateArgs>): Prisma.PrismaPromise<GetLockupExecutionAggregateType<T>>

    /**
     * Group by LockupExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockupExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LockupExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LockupExecutionGroupByArgs['orderBy'] }
        : { orderBy?: LockupExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LockupExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLockupExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LockupExecution model
   */
  readonly fields: LockupExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LockupExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LockupExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lockupStatus<T extends LockupStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LockupStatusDefaultArgs<ExtArgs>>): Prisma__LockupStatusClient<$Result.GetResult<Prisma.$LockupStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executedByMember<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LockupExecution model
   */
  interface LockupExecutionFieldRefs {
    readonly id: FieldRef<"LockupExecution", 'String'>
    readonly lockupStatusId: FieldRef<"LockupExecution", 'String'>
    readonly executedBy: FieldRef<"LockupExecution", 'String'>
    readonly executedAt: FieldRef<"LockupExecution", 'DateTime'>
    readonly membersCheckedOut: FieldRef<"LockupExecution", 'Json'>
    readonly visitorsCheckedOut: FieldRef<"LockupExecution", 'Json'>
    readonly totalCheckedOut: FieldRef<"LockupExecution", 'Int'>
    readonly notes: FieldRef<"LockupExecution", 'String'>
    readonly createdAt: FieldRef<"LockupExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LockupExecution findUnique
   */
  export type LockupExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter, which LockupExecution to fetch.
     */
    where: LockupExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution findUniqueOrThrow
   */
  export type LockupExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter, which LockupExecution to fetch.
     */
    where: LockupExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution findFirst
   */
  export type LockupExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter, which LockupExecution to fetch.
     */
    where?: LockupExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupExecutions to fetch.
     */
    orderBy?: LockupExecutionOrderByWithRelationInput | LockupExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupExecutions.
     */
    cursor?: LockupExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupExecutions.
     */
    distinct?: LockupExecutionScalarFieldEnum | LockupExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution findFirstOrThrow
   */
  export type LockupExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter, which LockupExecution to fetch.
     */
    where?: LockupExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupExecutions to fetch.
     */
    orderBy?: LockupExecutionOrderByWithRelationInput | LockupExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockupExecutions.
     */
    cursor?: LockupExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockupExecutions.
     */
    distinct?: LockupExecutionScalarFieldEnum | LockupExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution findMany
   */
  export type LockupExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter, which LockupExecutions to fetch.
     */
    where?: LockupExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockupExecutions to fetch.
     */
    orderBy?: LockupExecutionOrderByWithRelationInput | LockupExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LockupExecutions.
     */
    cursor?: LockupExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockupExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockupExecutions.
     */
    skip?: number
    distinct?: LockupExecutionScalarFieldEnum | LockupExecutionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution create
   */
  export type LockupExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a LockupExecution.
     */
    data: XOR<LockupExecutionCreateInput, LockupExecutionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution createMany
   */
  export type LockupExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LockupExecutions.
     */
    data: LockupExecutionCreateManyInput | LockupExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LockupExecution createManyAndReturn
   */
  export type LockupExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many LockupExecutions.
     */
    data: LockupExecutionCreateManyInput | LockupExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupExecution update
   */
  export type LockupExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a LockupExecution.
     */
    data: XOR<LockupExecutionUpdateInput, LockupExecutionUncheckedUpdateInput>
    /**
     * Choose, which LockupExecution to update.
     */
    where: LockupExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution updateMany
   */
  export type LockupExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LockupExecutions.
     */
    data: XOR<LockupExecutionUpdateManyMutationInput, LockupExecutionUncheckedUpdateManyInput>
    /**
     * Filter which LockupExecutions to update
     */
    where?: LockupExecutionWhereInput
    /**
     * Limit how many LockupExecutions to update.
     */
    limit?: number
  }

  /**
   * LockupExecution updateManyAndReturn
   */
  export type LockupExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * The data used to update LockupExecutions.
     */
    data: XOR<LockupExecutionUpdateManyMutationInput, LockupExecutionUncheckedUpdateManyInput>
    /**
     * Filter which LockupExecutions to update
     */
    where?: LockupExecutionWhereInput
    /**
     * Limit how many LockupExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockupExecution upsert
   */
  export type LockupExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the LockupExecution to update in case it exists.
     */
    where: LockupExecutionWhereUniqueInput
    /**
     * In case the LockupExecution found by the `where` argument doesn't exist, create a new LockupExecution with this data.
     */
    create: XOR<LockupExecutionCreateInput, LockupExecutionUncheckedCreateInput>
    /**
     * In case the LockupExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LockupExecutionUpdateInput, LockupExecutionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution delete
   */
  export type LockupExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
    /**
     * Filter which LockupExecution to delete.
     */
    where: LockupExecutionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * LockupExecution deleteMany
   */
  export type LockupExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockupExecutions to delete
     */
    where?: LockupExecutionWhereInput
    /**
     * Limit how many LockupExecutions to delete.
     */
    limit?: number
  }

  /**
   * LockupExecution without action
   */
  export type LockupExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockupExecution
     */
    select?: LockupExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LockupExecution
     */
    omit?: LockupExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockupExecutionInclude<ExtArgs> | null
  }


  /**
   * Model MissedCheckout
   */

  export type AggregateMissedCheckout = {
    _count: MissedCheckoutCountAggregateOutputType | null
    _min: MissedCheckoutMinAggregateOutputType | null
    _max: MissedCheckoutMaxAggregateOutputType | null
  }

  export type MissedCheckoutMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    date: Date | null
    originalCheckinAt: Date | null
    forcedCheckoutAt: Date | null
    resolvedBy: string | null
    resolvedByAdminId: string | null
    lockupExecutionId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type MissedCheckoutMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    date: Date | null
    originalCheckinAt: Date | null
    forcedCheckoutAt: Date | null
    resolvedBy: string | null
    resolvedByAdminId: string | null
    lockupExecutionId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type MissedCheckoutCountAggregateOutputType = {
    id: number
    memberId: number
    date: number
    originalCheckinAt: number
    forcedCheckoutAt: number
    resolvedBy: number
    resolvedByAdminId: number
    lockupExecutionId: number
    notes: number
    createdAt: number
    _all: number
  }


  export type MissedCheckoutMinAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    originalCheckinAt?: true
    forcedCheckoutAt?: true
    resolvedBy?: true
    resolvedByAdminId?: true
    lockupExecutionId?: true
    notes?: true
    createdAt?: true
  }

  export type MissedCheckoutMaxAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    originalCheckinAt?: true
    forcedCheckoutAt?: true
    resolvedBy?: true
    resolvedByAdminId?: true
    lockupExecutionId?: true
    notes?: true
    createdAt?: true
  }

  export type MissedCheckoutCountAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    originalCheckinAt?: true
    forcedCheckoutAt?: true
    resolvedBy?: true
    resolvedByAdminId?: true
    lockupExecutionId?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type MissedCheckoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissedCheckout to aggregate.
     */
    where?: MissedCheckoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissedCheckouts to fetch.
     */
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissedCheckoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissedCheckouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissedCheckouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissedCheckouts
    **/
    _count?: true | MissedCheckoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissedCheckoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissedCheckoutMaxAggregateInputType
  }

  export type GetMissedCheckoutAggregateType<T extends MissedCheckoutAggregateArgs> = {
        [P in keyof T & keyof AggregateMissedCheckout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissedCheckout[P]>
      : GetScalarType<T[P], AggregateMissedCheckout[P]>
  }




  export type MissedCheckoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissedCheckoutWhereInput
    orderBy?: MissedCheckoutOrderByWithAggregationInput | MissedCheckoutOrderByWithAggregationInput[]
    by: MissedCheckoutScalarFieldEnum[] | MissedCheckoutScalarFieldEnum
    having?: MissedCheckoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissedCheckoutCountAggregateInputType | true
    _min?: MissedCheckoutMinAggregateInputType
    _max?: MissedCheckoutMaxAggregateInputType
  }

  export type MissedCheckoutGroupByOutputType = {
    id: string
    memberId: string
    date: Date
    originalCheckinAt: Date
    forcedCheckoutAt: Date
    resolvedBy: string
    resolvedByAdminId: string | null
    lockupExecutionId: string | null
    notes: string | null
    createdAt: Date
    _count: MissedCheckoutCountAggregateOutputType | null
    _min: MissedCheckoutMinAggregateOutputType | null
    _max: MissedCheckoutMaxAggregateOutputType | null
  }

  type GetMissedCheckoutGroupByPayload<T extends MissedCheckoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissedCheckoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissedCheckoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissedCheckoutGroupByOutputType[P]>
            : GetScalarType<T[P], MissedCheckoutGroupByOutputType[P]>
        }
      >
    >


  export type MissedCheckoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    originalCheckinAt?: boolean
    forcedCheckoutAt?: boolean
    resolvedBy?: boolean
    resolvedByAdminId?: boolean
    lockupExecutionId?: boolean
    notes?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["missedCheckout"]>

  export type MissedCheckoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    originalCheckinAt?: boolean
    forcedCheckoutAt?: boolean
    resolvedBy?: boolean
    resolvedByAdminId?: boolean
    lockupExecutionId?: boolean
    notes?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["missedCheckout"]>

  export type MissedCheckoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    originalCheckinAt?: boolean
    forcedCheckoutAt?: boolean
    resolvedBy?: boolean
    resolvedByAdminId?: boolean
    lockupExecutionId?: boolean
    notes?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["missedCheckout"]>

  export type MissedCheckoutSelectScalar = {
    id?: boolean
    memberId?: boolean
    date?: boolean
    originalCheckinAt?: boolean
    forcedCheckoutAt?: boolean
    resolvedBy?: boolean
    resolvedByAdminId?: boolean
    lockupExecutionId?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type MissedCheckoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "date" | "originalCheckinAt" | "forcedCheckoutAt" | "resolvedBy" | "resolvedByAdminId" | "lockupExecutionId" | "notes" | "createdAt", ExtArgs["result"]["missedCheckout"]>
  export type MissedCheckoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }
  export type MissedCheckoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }
  export type MissedCheckoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    resolvedByAdmin?: boolean | MissedCheckout$resolvedByAdminArgs<ExtArgs>
  }

  export type $MissedCheckoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissedCheckout"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      resolvedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      date: Date
      originalCheckinAt: Date
      forcedCheckoutAt: Date
      resolvedBy: string
      resolvedByAdminId: string | null
      lockupExecutionId: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["missedCheckout"]>
    composites: {}
  }

  type MissedCheckoutGetPayload<S extends boolean | null | undefined | MissedCheckoutDefaultArgs> = $Result.GetResult<Prisma.$MissedCheckoutPayload, S>

  type MissedCheckoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MissedCheckoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MissedCheckoutCountAggregateInputType | true
    }

  export interface MissedCheckoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissedCheckout'], meta: { name: 'MissedCheckout' } }
    /**
     * Find zero or one MissedCheckout that matches the filter.
     * @param {MissedCheckoutFindUniqueArgs} args - Arguments to find a MissedCheckout
     * @example
     * // Get one MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissedCheckoutFindUniqueArgs>(args: SelectSubset<T, MissedCheckoutFindUniqueArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MissedCheckout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MissedCheckoutFindUniqueOrThrowArgs} args - Arguments to find a MissedCheckout
     * @example
     * // Get one MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissedCheckoutFindUniqueOrThrowArgs>(args: SelectSubset<T, MissedCheckoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MissedCheckout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutFindFirstArgs} args - Arguments to find a MissedCheckout
     * @example
     * // Get one MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissedCheckoutFindFirstArgs>(args?: SelectSubset<T, MissedCheckoutFindFirstArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MissedCheckout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutFindFirstOrThrowArgs} args - Arguments to find a MissedCheckout
     * @example
     * // Get one MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissedCheckoutFindFirstOrThrowArgs>(args?: SelectSubset<T, MissedCheckoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MissedCheckouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissedCheckouts
     * const missedCheckouts = await prisma.missedCheckout.findMany()
     * 
     * // Get first 10 MissedCheckouts
     * const missedCheckouts = await prisma.missedCheckout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missedCheckoutWithIdOnly = await prisma.missedCheckout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissedCheckoutFindManyArgs>(args?: SelectSubset<T, MissedCheckoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MissedCheckout.
     * @param {MissedCheckoutCreateArgs} args - Arguments to create a MissedCheckout.
     * @example
     * // Create one MissedCheckout
     * const MissedCheckout = await prisma.missedCheckout.create({
     *   data: {
     *     // ... data to create a MissedCheckout
     *   }
     * })
     * 
     */
    create<T extends MissedCheckoutCreateArgs>(args: SelectSubset<T, MissedCheckoutCreateArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MissedCheckouts.
     * @param {MissedCheckoutCreateManyArgs} args - Arguments to create many MissedCheckouts.
     * @example
     * // Create many MissedCheckouts
     * const missedCheckout = await prisma.missedCheckout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissedCheckoutCreateManyArgs>(args?: SelectSubset<T, MissedCheckoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MissedCheckouts and returns the data saved in the database.
     * @param {MissedCheckoutCreateManyAndReturnArgs} args - Arguments to create many MissedCheckouts.
     * @example
     * // Create many MissedCheckouts
     * const missedCheckout = await prisma.missedCheckout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MissedCheckouts and only return the `id`
     * const missedCheckoutWithIdOnly = await prisma.missedCheckout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissedCheckoutCreateManyAndReturnArgs>(args?: SelectSubset<T, MissedCheckoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MissedCheckout.
     * @param {MissedCheckoutDeleteArgs} args - Arguments to delete one MissedCheckout.
     * @example
     * // Delete one MissedCheckout
     * const MissedCheckout = await prisma.missedCheckout.delete({
     *   where: {
     *     // ... filter to delete one MissedCheckout
     *   }
     * })
     * 
     */
    delete<T extends MissedCheckoutDeleteArgs>(args: SelectSubset<T, MissedCheckoutDeleteArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MissedCheckout.
     * @param {MissedCheckoutUpdateArgs} args - Arguments to update one MissedCheckout.
     * @example
     * // Update one MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissedCheckoutUpdateArgs>(args: SelectSubset<T, MissedCheckoutUpdateArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MissedCheckouts.
     * @param {MissedCheckoutDeleteManyArgs} args - Arguments to filter MissedCheckouts to delete.
     * @example
     * // Delete a few MissedCheckouts
     * const { count } = await prisma.missedCheckout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissedCheckoutDeleteManyArgs>(args?: SelectSubset<T, MissedCheckoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissedCheckouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissedCheckouts
     * const missedCheckout = await prisma.missedCheckout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissedCheckoutUpdateManyArgs>(args: SelectSubset<T, MissedCheckoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissedCheckouts and returns the data updated in the database.
     * @param {MissedCheckoutUpdateManyAndReturnArgs} args - Arguments to update many MissedCheckouts.
     * @example
     * // Update many MissedCheckouts
     * const missedCheckout = await prisma.missedCheckout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MissedCheckouts and only return the `id`
     * const missedCheckoutWithIdOnly = await prisma.missedCheckout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MissedCheckoutUpdateManyAndReturnArgs>(args: SelectSubset<T, MissedCheckoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MissedCheckout.
     * @param {MissedCheckoutUpsertArgs} args - Arguments to update or create a MissedCheckout.
     * @example
     * // Update or create a MissedCheckout
     * const missedCheckout = await prisma.missedCheckout.upsert({
     *   create: {
     *     // ... data to create a MissedCheckout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissedCheckout we want to update
     *   }
     * })
     */
    upsert<T extends MissedCheckoutUpsertArgs>(args: SelectSubset<T, MissedCheckoutUpsertArgs<ExtArgs>>): Prisma__MissedCheckoutClient<$Result.GetResult<Prisma.$MissedCheckoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MissedCheckouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutCountArgs} args - Arguments to filter MissedCheckouts to count.
     * @example
     * // Count the number of MissedCheckouts
     * const count = await prisma.missedCheckout.count({
     *   where: {
     *     // ... the filter for the MissedCheckouts we want to count
     *   }
     * })
    **/
    count<T extends MissedCheckoutCountArgs>(
      args?: Subset<T, MissedCheckoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissedCheckoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissedCheckout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissedCheckoutAggregateArgs>(args: Subset<T, MissedCheckoutAggregateArgs>): Prisma.PrismaPromise<GetMissedCheckoutAggregateType<T>>

    /**
     * Group by MissedCheckout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissedCheckoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissedCheckoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissedCheckoutGroupByArgs['orderBy'] }
        : { orderBy?: MissedCheckoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissedCheckoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissedCheckoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissedCheckout model
   */
  readonly fields: MissedCheckoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissedCheckout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissedCheckoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedByAdmin<T extends MissedCheckout$resolvedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, MissedCheckout$resolvedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissedCheckout model
   */
  interface MissedCheckoutFieldRefs {
    readonly id: FieldRef<"MissedCheckout", 'String'>
    readonly memberId: FieldRef<"MissedCheckout", 'String'>
    readonly date: FieldRef<"MissedCheckout", 'DateTime'>
    readonly originalCheckinAt: FieldRef<"MissedCheckout", 'DateTime'>
    readonly forcedCheckoutAt: FieldRef<"MissedCheckout", 'DateTime'>
    readonly resolvedBy: FieldRef<"MissedCheckout", 'String'>
    readonly resolvedByAdminId: FieldRef<"MissedCheckout", 'String'>
    readonly lockupExecutionId: FieldRef<"MissedCheckout", 'String'>
    readonly notes: FieldRef<"MissedCheckout", 'String'>
    readonly createdAt: FieldRef<"MissedCheckout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissedCheckout findUnique
   */
  export type MissedCheckoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter, which MissedCheckout to fetch.
     */
    where: MissedCheckoutWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout findUniqueOrThrow
   */
  export type MissedCheckoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter, which MissedCheckout to fetch.
     */
    where: MissedCheckoutWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout findFirst
   */
  export type MissedCheckoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter, which MissedCheckout to fetch.
     */
    where?: MissedCheckoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissedCheckouts to fetch.
     */
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissedCheckouts.
     */
    cursor?: MissedCheckoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissedCheckouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissedCheckouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissedCheckouts.
     */
    distinct?: MissedCheckoutScalarFieldEnum | MissedCheckoutScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout findFirstOrThrow
   */
  export type MissedCheckoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter, which MissedCheckout to fetch.
     */
    where?: MissedCheckoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissedCheckouts to fetch.
     */
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissedCheckouts.
     */
    cursor?: MissedCheckoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissedCheckouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissedCheckouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissedCheckouts.
     */
    distinct?: MissedCheckoutScalarFieldEnum | MissedCheckoutScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout findMany
   */
  export type MissedCheckoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter, which MissedCheckouts to fetch.
     */
    where?: MissedCheckoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissedCheckouts to fetch.
     */
    orderBy?: MissedCheckoutOrderByWithRelationInput | MissedCheckoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissedCheckouts.
     */
    cursor?: MissedCheckoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissedCheckouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissedCheckouts.
     */
    skip?: number
    distinct?: MissedCheckoutScalarFieldEnum | MissedCheckoutScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout create
   */
  export type MissedCheckoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * The data needed to create a MissedCheckout.
     */
    data: XOR<MissedCheckoutCreateInput, MissedCheckoutUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout createMany
   */
  export type MissedCheckoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissedCheckouts.
     */
    data: MissedCheckoutCreateManyInput | MissedCheckoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissedCheckout createManyAndReturn
   */
  export type MissedCheckoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * The data used to create many MissedCheckouts.
     */
    data: MissedCheckoutCreateManyInput | MissedCheckoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MissedCheckout update
   */
  export type MissedCheckoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * The data needed to update a MissedCheckout.
     */
    data: XOR<MissedCheckoutUpdateInput, MissedCheckoutUncheckedUpdateInput>
    /**
     * Choose, which MissedCheckout to update.
     */
    where: MissedCheckoutWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout updateMany
   */
  export type MissedCheckoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissedCheckouts.
     */
    data: XOR<MissedCheckoutUpdateManyMutationInput, MissedCheckoutUncheckedUpdateManyInput>
    /**
     * Filter which MissedCheckouts to update
     */
    where?: MissedCheckoutWhereInput
    /**
     * Limit how many MissedCheckouts to update.
     */
    limit?: number
  }

  /**
   * MissedCheckout updateManyAndReturn
   */
  export type MissedCheckoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * The data used to update MissedCheckouts.
     */
    data: XOR<MissedCheckoutUpdateManyMutationInput, MissedCheckoutUncheckedUpdateManyInput>
    /**
     * Filter which MissedCheckouts to update
     */
    where?: MissedCheckoutWhereInput
    /**
     * Limit how many MissedCheckouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MissedCheckout upsert
   */
  export type MissedCheckoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * The filter to search for the MissedCheckout to update in case it exists.
     */
    where: MissedCheckoutWhereUniqueInput
    /**
     * In case the MissedCheckout found by the `where` argument doesn't exist, create a new MissedCheckout with this data.
     */
    create: XOR<MissedCheckoutCreateInput, MissedCheckoutUncheckedCreateInput>
    /**
     * In case the MissedCheckout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissedCheckoutUpdateInput, MissedCheckoutUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout delete
   */
  export type MissedCheckoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
    /**
     * Filter which MissedCheckout to delete.
     */
    where: MissedCheckoutWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MissedCheckout deleteMany
   */
  export type MissedCheckoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissedCheckouts to delete
     */
    where?: MissedCheckoutWhereInput
    /**
     * Limit how many MissedCheckouts to delete.
     */
    limit?: number
  }

  /**
   * MissedCheckout.resolvedByAdmin
   */
  export type MissedCheckout$resolvedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * MissedCheckout without action
   */
  export type MissedCheckoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissedCheckout
     */
    select?: MissedCheckoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissedCheckout
     */
    omit?: MissedCheckoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissedCheckoutInclude<ExtArgs> | null
  }


  /**
   * Model UnitEventType
   */

  export type AggregateUnitEventType = {
    _count: UnitEventTypeCountAggregateOutputType | null
    _avg: UnitEventTypeAvgAggregateOutputType | null
    _sum: UnitEventTypeSumAggregateOutputType | null
    _min: UnitEventTypeMinAggregateOutputType | null
    _max: UnitEventTypeMaxAggregateOutputType | null
  }

  export type UnitEventTypeAvgAggregateOutputType = {
    defaultDurationMinutes: number | null
    displayOrder: number | null
  }

  export type UnitEventTypeSumAggregateOutputType = {
    defaultDurationMinutes: number | null
    displayOrder: number | null
  }

  export type UnitEventTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    defaultDurationMinutes: number | null
    requiresDutyWatch: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    defaultDurationMinutes: number | null
    requiresDutyWatch: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventTypeCountAggregateOutputType = {
    id: number
    name: number
    category: number
    defaultDurationMinutes: number
    requiresDutyWatch: number
    defaultMetadata: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitEventTypeAvgAggregateInputType = {
    defaultDurationMinutes?: true
    displayOrder?: true
  }

  export type UnitEventTypeSumAggregateInputType = {
    defaultDurationMinutes?: true
    displayOrder?: true
  }

  export type UnitEventTypeMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultDurationMinutes?: true
    requiresDutyWatch?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventTypeMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultDurationMinutes?: true
    requiresDutyWatch?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventTypeCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultDurationMinutes?: true
    requiresDutyWatch?: true
    defaultMetadata?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitEventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventType to aggregate.
     */
    where?: UnitEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventTypes to fetch.
     */
    orderBy?: UnitEventTypeOrderByWithRelationInput | UnitEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitEventTypes
    **/
    _count?: true | UnitEventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitEventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitEventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitEventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitEventTypeMaxAggregateInputType
  }

  export type GetUnitEventTypeAggregateType<T extends UnitEventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitEventType[P]>
      : GetScalarType<T[P], AggregateUnitEventType[P]>
  }




  export type UnitEventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventTypeWhereInput
    orderBy?: UnitEventTypeOrderByWithAggregationInput | UnitEventTypeOrderByWithAggregationInput[]
    by: UnitEventTypeScalarFieldEnum[] | UnitEventTypeScalarFieldEnum
    having?: UnitEventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitEventTypeCountAggregateInputType | true
    _avg?: UnitEventTypeAvgAggregateInputType
    _sum?: UnitEventTypeSumAggregateInputType
    _min?: UnitEventTypeMinAggregateInputType
    _max?: UnitEventTypeMaxAggregateInputType
  }

  export type UnitEventTypeGroupByOutputType = {
    id: string
    name: string
    category: string
    defaultDurationMinutes: number
    requiresDutyWatch: boolean
    defaultMetadata: JsonValue | null
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: UnitEventTypeCountAggregateOutputType | null
    _avg: UnitEventTypeAvgAggregateOutputType | null
    _sum: UnitEventTypeSumAggregateOutputType | null
    _min: UnitEventTypeMinAggregateOutputType | null
    _max: UnitEventTypeMaxAggregateOutputType | null
  }

  type GetUnitEventTypeGroupByPayload<T extends UnitEventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitEventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitEventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitEventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], UnitEventTypeGroupByOutputType[P]>
        }
      >
    >


  export type UnitEventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultDurationMinutes?: boolean
    requiresDutyWatch?: boolean
    defaultMetadata?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unitEvents?: boolean | UnitEventType$unitEventsArgs<ExtArgs>
    _count?: boolean | UnitEventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventType"]>

  export type UnitEventTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultDurationMinutes?: boolean
    requiresDutyWatch?: boolean
    defaultMetadata?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitEventType"]>

  export type UnitEventTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultDurationMinutes?: boolean
    requiresDutyWatch?: boolean
    defaultMetadata?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitEventType"]>

  export type UnitEventTypeSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    defaultDurationMinutes?: boolean
    requiresDutyWatch?: boolean
    defaultMetadata?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitEventTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "defaultDurationMinutes" | "requiresDutyWatch" | "defaultMetadata" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["unitEventType"]>
  export type UnitEventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitEvents?: boolean | UnitEventType$unitEventsArgs<ExtArgs>
    _count?: boolean | UnitEventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitEventTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitEventTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitEventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitEventType"
    objects: {
      unitEvents: Prisma.$UnitEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      defaultDurationMinutes: number
      requiresDutyWatch: boolean
      defaultMetadata: Prisma.JsonValue | null
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitEventType"]>
    composites: {}
  }

  type UnitEventTypeGetPayload<S extends boolean | null | undefined | UnitEventTypeDefaultArgs> = $Result.GetResult<Prisma.$UnitEventTypePayload, S>

  type UnitEventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitEventTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UnitEventTypeCountAggregateInputType | true
    }

  export interface UnitEventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitEventType'], meta: { name: 'UnitEventType' } }
    /**
     * Find zero or one UnitEventType that matches the filter.
     * @param {UnitEventTypeFindUniqueArgs} args - Arguments to find a UnitEventType
     * @example
     * // Get one UnitEventType
     * const unitEventType = await prisma.unitEventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitEventTypeFindUniqueArgs>(args: SelectSubset<T, UnitEventTypeFindUniqueArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitEventType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitEventTypeFindUniqueOrThrowArgs} args - Arguments to find a UnitEventType
     * @example
     * // Get one UnitEventType
     * const unitEventType = await prisma.unitEventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitEventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitEventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeFindFirstArgs} args - Arguments to find a UnitEventType
     * @example
     * // Get one UnitEventType
     * const unitEventType = await prisma.unitEventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitEventTypeFindFirstArgs>(args?: SelectSubset<T, UnitEventTypeFindFirstArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeFindFirstOrThrowArgs} args - Arguments to find a UnitEventType
     * @example
     * // Get one UnitEventType
     * const unitEventType = await prisma.unitEventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitEventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitEventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitEventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitEventTypes
     * const unitEventTypes = await prisma.unitEventType.findMany()
     * 
     * // Get first 10 UnitEventTypes
     * const unitEventTypes = await prisma.unitEventType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitEventTypeWithIdOnly = await prisma.unitEventType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitEventTypeFindManyArgs>(args?: SelectSubset<T, UnitEventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitEventType.
     * @param {UnitEventTypeCreateArgs} args - Arguments to create a UnitEventType.
     * @example
     * // Create one UnitEventType
     * const UnitEventType = await prisma.unitEventType.create({
     *   data: {
     *     // ... data to create a UnitEventType
     *   }
     * })
     * 
     */
    create<T extends UnitEventTypeCreateArgs>(args: SelectSubset<T, UnitEventTypeCreateArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitEventTypes.
     * @param {UnitEventTypeCreateManyArgs} args - Arguments to create many UnitEventTypes.
     * @example
     * // Create many UnitEventTypes
     * const unitEventType = await prisma.unitEventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitEventTypeCreateManyArgs>(args?: SelectSubset<T, UnitEventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitEventTypes and returns the data saved in the database.
     * @param {UnitEventTypeCreateManyAndReturnArgs} args - Arguments to create many UnitEventTypes.
     * @example
     * // Create many UnitEventTypes
     * const unitEventType = await prisma.unitEventType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitEventTypes and only return the `id`
     * const unitEventTypeWithIdOnly = await prisma.unitEventType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitEventTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitEventTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitEventType.
     * @param {UnitEventTypeDeleteArgs} args - Arguments to delete one UnitEventType.
     * @example
     * // Delete one UnitEventType
     * const UnitEventType = await prisma.unitEventType.delete({
     *   where: {
     *     // ... filter to delete one UnitEventType
     *   }
     * })
     * 
     */
    delete<T extends UnitEventTypeDeleteArgs>(args: SelectSubset<T, UnitEventTypeDeleteArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitEventType.
     * @param {UnitEventTypeUpdateArgs} args - Arguments to update one UnitEventType.
     * @example
     * // Update one UnitEventType
     * const unitEventType = await prisma.unitEventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitEventTypeUpdateArgs>(args: SelectSubset<T, UnitEventTypeUpdateArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitEventTypes.
     * @param {UnitEventTypeDeleteManyArgs} args - Arguments to filter UnitEventTypes to delete.
     * @example
     * // Delete a few UnitEventTypes
     * const { count } = await prisma.unitEventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitEventTypeDeleteManyArgs>(args?: SelectSubset<T, UnitEventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitEventTypes
     * const unitEventType = await prisma.unitEventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitEventTypeUpdateManyArgs>(args: SelectSubset<T, UnitEventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventTypes and returns the data updated in the database.
     * @param {UnitEventTypeUpdateManyAndReturnArgs} args - Arguments to update many UnitEventTypes.
     * @example
     * // Update many UnitEventTypes
     * const unitEventType = await prisma.unitEventType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitEventTypes and only return the `id`
     * const unitEventTypeWithIdOnly = await prisma.unitEventType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitEventTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitEventTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitEventType.
     * @param {UnitEventTypeUpsertArgs} args - Arguments to update or create a UnitEventType.
     * @example
     * // Update or create a UnitEventType
     * const unitEventType = await prisma.unitEventType.upsert({
     *   create: {
     *     // ... data to create a UnitEventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitEventType we want to update
     *   }
     * })
     */
    upsert<T extends UnitEventTypeUpsertArgs>(args: SelectSubset<T, UnitEventTypeUpsertArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeCountArgs} args - Arguments to filter UnitEventTypes to count.
     * @example
     * // Count the number of UnitEventTypes
     * const count = await prisma.unitEventType.count({
     *   where: {
     *     // ... the filter for the UnitEventTypes we want to count
     *   }
     * })
    **/
    count<T extends UnitEventTypeCountArgs>(
      args?: Subset<T, UnitEventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitEventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitEventTypeAggregateArgs>(args: Subset<T, UnitEventTypeAggregateArgs>): Prisma.PrismaPromise<GetUnitEventTypeAggregateType<T>>

    /**
     * Group by UnitEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitEventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitEventTypeGroupByArgs['orderBy'] }
        : { orderBy?: UnitEventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitEventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitEventType model
   */
  readonly fields: UnitEventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitEventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitEventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitEvents<T extends UnitEventType$unitEventsArgs<ExtArgs> = {}>(args?: Subset<T, UnitEventType$unitEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitEventType model
   */
  interface UnitEventTypeFieldRefs {
    readonly id: FieldRef<"UnitEventType", 'String'>
    readonly name: FieldRef<"UnitEventType", 'String'>
    readonly category: FieldRef<"UnitEventType", 'String'>
    readonly defaultDurationMinutes: FieldRef<"UnitEventType", 'Int'>
    readonly requiresDutyWatch: FieldRef<"UnitEventType", 'Boolean'>
    readonly defaultMetadata: FieldRef<"UnitEventType", 'Json'>
    readonly displayOrder: FieldRef<"UnitEventType", 'Int'>
    readonly createdAt: FieldRef<"UnitEventType", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitEventType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitEventType findUnique
   */
  export type UnitEventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventType to fetch.
     */
    where: UnitEventTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType findUniqueOrThrow
   */
  export type UnitEventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventType to fetch.
     */
    where: UnitEventTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType findFirst
   */
  export type UnitEventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventType to fetch.
     */
    where?: UnitEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventTypes to fetch.
     */
    orderBy?: UnitEventTypeOrderByWithRelationInput | UnitEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventTypes.
     */
    cursor?: UnitEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventTypes.
     */
    distinct?: UnitEventTypeScalarFieldEnum | UnitEventTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType findFirstOrThrow
   */
  export type UnitEventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventType to fetch.
     */
    where?: UnitEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventTypes to fetch.
     */
    orderBy?: UnitEventTypeOrderByWithRelationInput | UnitEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventTypes.
     */
    cursor?: UnitEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventTypes.
     */
    distinct?: UnitEventTypeScalarFieldEnum | UnitEventTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType findMany
   */
  export type UnitEventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventTypes to fetch.
     */
    where?: UnitEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventTypes to fetch.
     */
    orderBy?: UnitEventTypeOrderByWithRelationInput | UnitEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitEventTypes.
     */
    cursor?: UnitEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventTypes.
     */
    skip?: number
    distinct?: UnitEventTypeScalarFieldEnum | UnitEventTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType create
   */
  export type UnitEventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitEventType.
     */
    data: XOR<UnitEventTypeCreateInput, UnitEventTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType createMany
   */
  export type UnitEventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitEventTypes.
     */
    data: UnitEventTypeCreateManyInput | UnitEventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitEventType createManyAndReturn
   */
  export type UnitEventTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * The data used to create many UnitEventTypes.
     */
    data: UnitEventTypeCreateManyInput | UnitEventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitEventType update
   */
  export type UnitEventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitEventType.
     */
    data: XOR<UnitEventTypeUpdateInput, UnitEventTypeUncheckedUpdateInput>
    /**
     * Choose, which UnitEventType to update.
     */
    where: UnitEventTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType updateMany
   */
  export type UnitEventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitEventTypes.
     */
    data: XOR<UnitEventTypeUpdateManyMutationInput, UnitEventTypeUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventTypes to update
     */
    where?: UnitEventTypeWhereInput
    /**
     * Limit how many UnitEventTypes to update.
     */
    limit?: number
  }

  /**
   * UnitEventType updateManyAndReturn
   */
  export type UnitEventTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * The data used to update UnitEventTypes.
     */
    data: XOR<UnitEventTypeUpdateManyMutationInput, UnitEventTypeUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventTypes to update
     */
    where?: UnitEventTypeWhereInput
    /**
     * Limit how many UnitEventTypes to update.
     */
    limit?: number
  }

  /**
   * UnitEventType upsert
   */
  export type UnitEventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitEventType to update in case it exists.
     */
    where: UnitEventTypeWhereUniqueInput
    /**
     * In case the UnitEventType found by the `where` argument doesn't exist, create a new UnitEventType with this data.
     */
    create: XOR<UnitEventTypeCreateInput, UnitEventTypeUncheckedCreateInput>
    /**
     * In case the UnitEventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitEventTypeUpdateInput, UnitEventTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType delete
   */
  export type UnitEventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    /**
     * Filter which UnitEventType to delete.
     */
    where: UnitEventTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventType deleteMany
   */
  export type UnitEventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventTypes to delete
     */
    where?: UnitEventTypeWhereInput
    /**
     * Limit how many UnitEventTypes to delete.
     */
    limit?: number
  }

  /**
   * UnitEventType.unitEvents
   */
  export type UnitEventType$unitEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    where?: UnitEventWhereInput
    orderBy?: UnitEventOrderByWithRelationInput | UnitEventOrderByWithRelationInput[]
    cursor?: UnitEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitEventScalarFieldEnum | UnitEventScalarFieldEnum[]
  }

  /**
   * UnitEventType without action
   */
  export type UnitEventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
  }


  /**
   * Model UnitEvent
   */

  export type AggregateUnitEvent = {
    _count: UnitEventCountAggregateOutputType | null
    _min: UnitEventMinAggregateOutputType | null
    _max: UnitEventMaxAggregateOutputType | null
  }

  export type UnitEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    eventTypeId: string | null
    eventDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    description: string | null
    organizer: string | null
    requiresDutyWatch: boolean | null
    status: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    eventTypeId: string | null
    eventDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    description: string | null
    organizer: string | null
    requiresDutyWatch: boolean | null
    status: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventCountAggregateOutputType = {
    id: number
    title: number
    eventTypeId: number
    eventDate: number
    startTime: number
    endTime: number
    location: number
    description: number
    organizer: number
    requiresDutyWatch: number
    status: number
    metadata: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitEventMinAggregateInputType = {
    id?: true
    title?: true
    eventTypeId?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    description?: true
    organizer?: true
    requiresDutyWatch?: true
    status?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventMaxAggregateInputType = {
    id?: true
    title?: true
    eventTypeId?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    description?: true
    organizer?: true
    requiresDutyWatch?: true
    status?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventCountAggregateInputType = {
    id?: true
    title?: true
    eventTypeId?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    description?: true
    organizer?: true
    requiresDutyWatch?: true
    status?: true
    metadata?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEvent to aggregate.
     */
    where?: UnitEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEvents to fetch.
     */
    orderBy?: UnitEventOrderByWithRelationInput | UnitEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitEvents
    **/
    _count?: true | UnitEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitEventMaxAggregateInputType
  }

  export type GetUnitEventAggregateType<T extends UnitEventAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitEvent[P]>
      : GetScalarType<T[P], AggregateUnitEvent[P]>
  }




  export type UnitEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventWhereInput
    orderBy?: UnitEventOrderByWithAggregationInput | UnitEventOrderByWithAggregationInput[]
    by: UnitEventScalarFieldEnum[] | UnitEventScalarFieldEnum
    having?: UnitEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitEventCountAggregateInputType | true
    _min?: UnitEventMinAggregateInputType
    _max?: UnitEventMaxAggregateInputType
  }

  export type UnitEventGroupByOutputType = {
    id: string
    title: string
    eventTypeId: string | null
    eventDate: Date
    startTime: Date | null
    endTime: Date | null
    location: string | null
    description: string | null
    organizer: string | null
    requiresDutyWatch: boolean
    status: string
    metadata: JsonValue | null
    notes: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitEventCountAggregateOutputType | null
    _min: UnitEventMinAggregateOutputType | null
    _max: UnitEventMaxAggregateOutputType | null
  }

  type GetUnitEventGroupByPayload<T extends UnitEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitEventGroupByOutputType[P]>
            : GetScalarType<T[P], UnitEventGroupByOutputType[P]>
        }
      >
    >


  export type UnitEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    eventTypeId?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    description?: boolean
    organizer?: boolean
    requiresDutyWatch?: boolean
    status?: boolean
    metadata?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
    dutyPositions?: boolean | UnitEvent$dutyPositionsArgs<ExtArgs>
    dutyAssignments?: boolean | UnitEvent$dutyAssignmentsArgs<ExtArgs>
    _count?: boolean | UnitEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEvent"]>

  export type UnitEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    eventTypeId?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    description?: boolean
    organizer?: boolean
    requiresDutyWatch?: boolean
    status?: boolean
    metadata?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
  }, ExtArgs["result"]["unitEvent"]>

  export type UnitEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    eventTypeId?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    description?: boolean
    organizer?: boolean
    requiresDutyWatch?: boolean
    status?: boolean
    metadata?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
  }, ExtArgs["result"]["unitEvent"]>

  export type UnitEventSelectScalar = {
    id?: boolean
    title?: boolean
    eventTypeId?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    description?: boolean
    organizer?: boolean
    requiresDutyWatch?: boolean
    status?: boolean
    metadata?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "eventTypeId" | "eventDate" | "startTime" | "endTime" | "location" | "description" | "organizer" | "requiresDutyWatch" | "status" | "metadata" | "notes" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["unitEvent"]>
  export type UnitEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
    dutyPositions?: boolean | UnitEvent$dutyPositionsArgs<ExtArgs>
    dutyAssignments?: boolean | UnitEvent$dutyAssignmentsArgs<ExtArgs>
    _count?: boolean | UnitEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
  }
  export type UnitEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventType?: boolean | UnitEvent$eventTypeArgs<ExtArgs>
  }

  export type $UnitEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitEvent"
    objects: {
      eventType: Prisma.$UnitEventTypePayload<ExtArgs> | null
      dutyPositions: Prisma.$UnitEventDutyPositionPayload<ExtArgs>[]
      dutyAssignments: Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      eventTypeId: string | null
      eventDate: Date
      startTime: Date | null
      endTime: Date | null
      location: string | null
      description: string | null
      organizer: string | null
      requiresDutyWatch: boolean
      status: string
      metadata: Prisma.JsonValue | null
      notes: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitEvent"]>
    composites: {}
  }

  type UnitEventGetPayload<S extends boolean | null | undefined | UnitEventDefaultArgs> = $Result.GetResult<Prisma.$UnitEventPayload, S>

  type UnitEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UnitEventCountAggregateInputType | true
    }

  export interface UnitEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitEvent'], meta: { name: 'UnitEvent' } }
    /**
     * Find zero or one UnitEvent that matches the filter.
     * @param {UnitEventFindUniqueArgs} args - Arguments to find a UnitEvent
     * @example
     * // Get one UnitEvent
     * const unitEvent = await prisma.unitEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitEventFindUniqueArgs>(args: SelectSubset<T, UnitEventFindUniqueArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitEventFindUniqueOrThrowArgs} args - Arguments to find a UnitEvent
     * @example
     * // Get one UnitEvent
     * const unitEvent = await prisma.unitEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitEventFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventFindFirstArgs} args - Arguments to find a UnitEvent
     * @example
     * // Get one UnitEvent
     * const unitEvent = await prisma.unitEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitEventFindFirstArgs>(args?: SelectSubset<T, UnitEventFindFirstArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventFindFirstOrThrowArgs} args - Arguments to find a UnitEvent
     * @example
     * // Get one UnitEvent
     * const unitEvent = await prisma.unitEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitEventFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitEvents
     * const unitEvents = await prisma.unitEvent.findMany()
     * 
     * // Get first 10 UnitEvents
     * const unitEvents = await prisma.unitEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitEventWithIdOnly = await prisma.unitEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitEventFindManyArgs>(args?: SelectSubset<T, UnitEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitEvent.
     * @param {UnitEventCreateArgs} args - Arguments to create a UnitEvent.
     * @example
     * // Create one UnitEvent
     * const UnitEvent = await prisma.unitEvent.create({
     *   data: {
     *     // ... data to create a UnitEvent
     *   }
     * })
     * 
     */
    create<T extends UnitEventCreateArgs>(args: SelectSubset<T, UnitEventCreateArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitEvents.
     * @param {UnitEventCreateManyArgs} args - Arguments to create many UnitEvents.
     * @example
     * // Create many UnitEvents
     * const unitEvent = await prisma.unitEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitEventCreateManyArgs>(args?: SelectSubset<T, UnitEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitEvents and returns the data saved in the database.
     * @param {UnitEventCreateManyAndReturnArgs} args - Arguments to create many UnitEvents.
     * @example
     * // Create many UnitEvents
     * const unitEvent = await prisma.unitEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitEvents and only return the `id`
     * const unitEventWithIdOnly = await prisma.unitEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitEventCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitEvent.
     * @param {UnitEventDeleteArgs} args - Arguments to delete one UnitEvent.
     * @example
     * // Delete one UnitEvent
     * const UnitEvent = await prisma.unitEvent.delete({
     *   where: {
     *     // ... filter to delete one UnitEvent
     *   }
     * })
     * 
     */
    delete<T extends UnitEventDeleteArgs>(args: SelectSubset<T, UnitEventDeleteArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitEvent.
     * @param {UnitEventUpdateArgs} args - Arguments to update one UnitEvent.
     * @example
     * // Update one UnitEvent
     * const unitEvent = await prisma.unitEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitEventUpdateArgs>(args: SelectSubset<T, UnitEventUpdateArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitEvents.
     * @param {UnitEventDeleteManyArgs} args - Arguments to filter UnitEvents to delete.
     * @example
     * // Delete a few UnitEvents
     * const { count } = await prisma.unitEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitEventDeleteManyArgs>(args?: SelectSubset<T, UnitEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitEvents
     * const unitEvent = await prisma.unitEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitEventUpdateManyArgs>(args: SelectSubset<T, UnitEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEvents and returns the data updated in the database.
     * @param {UnitEventUpdateManyAndReturnArgs} args - Arguments to update many UnitEvents.
     * @example
     * // Update many UnitEvents
     * const unitEvent = await prisma.unitEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitEvents and only return the `id`
     * const unitEventWithIdOnly = await prisma.unitEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitEventUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitEvent.
     * @param {UnitEventUpsertArgs} args - Arguments to update or create a UnitEvent.
     * @example
     * // Update or create a UnitEvent
     * const unitEvent = await prisma.unitEvent.upsert({
     *   create: {
     *     // ... data to create a UnitEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitEvent we want to update
     *   }
     * })
     */
    upsert<T extends UnitEventUpsertArgs>(args: SelectSubset<T, UnitEventUpsertArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventCountArgs} args - Arguments to filter UnitEvents to count.
     * @example
     * // Count the number of UnitEvents
     * const count = await prisma.unitEvent.count({
     *   where: {
     *     // ... the filter for the UnitEvents we want to count
     *   }
     * })
    **/
    count<T extends UnitEventCountArgs>(
      args?: Subset<T, UnitEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitEventAggregateArgs>(args: Subset<T, UnitEventAggregateArgs>): Prisma.PrismaPromise<GetUnitEventAggregateType<T>>

    /**
     * Group by UnitEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitEventGroupByArgs['orderBy'] }
        : { orderBy?: UnitEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitEvent model
   */
  readonly fields: UnitEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventType<T extends UnitEvent$eventTypeArgs<ExtArgs> = {}>(args?: Subset<T, UnitEvent$eventTypeArgs<ExtArgs>>): Prisma__UnitEventTypeClient<$Result.GetResult<Prisma.$UnitEventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dutyPositions<T extends UnitEvent$dutyPositionsArgs<ExtArgs> = {}>(args?: Subset<T, UnitEvent$dutyPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dutyAssignments<T extends UnitEvent$dutyAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, UnitEvent$dutyAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitEvent model
   */
  interface UnitEventFieldRefs {
    readonly id: FieldRef<"UnitEvent", 'String'>
    readonly title: FieldRef<"UnitEvent", 'String'>
    readonly eventTypeId: FieldRef<"UnitEvent", 'String'>
    readonly eventDate: FieldRef<"UnitEvent", 'DateTime'>
    readonly startTime: FieldRef<"UnitEvent", 'DateTime'>
    readonly endTime: FieldRef<"UnitEvent", 'DateTime'>
    readonly location: FieldRef<"UnitEvent", 'String'>
    readonly description: FieldRef<"UnitEvent", 'String'>
    readonly organizer: FieldRef<"UnitEvent", 'String'>
    readonly requiresDutyWatch: FieldRef<"UnitEvent", 'Boolean'>
    readonly status: FieldRef<"UnitEvent", 'String'>
    readonly metadata: FieldRef<"UnitEvent", 'Json'>
    readonly notes: FieldRef<"UnitEvent", 'String'>
    readonly createdBy: FieldRef<"UnitEvent", 'String'>
    readonly createdAt: FieldRef<"UnitEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitEvent findUnique
   */
  export type UnitEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter, which UnitEvent to fetch.
     */
    where: UnitEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent findUniqueOrThrow
   */
  export type UnitEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter, which UnitEvent to fetch.
     */
    where: UnitEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent findFirst
   */
  export type UnitEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter, which UnitEvent to fetch.
     */
    where?: UnitEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEvents to fetch.
     */
    orderBy?: UnitEventOrderByWithRelationInput | UnitEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEvents.
     */
    cursor?: UnitEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEvents.
     */
    distinct?: UnitEventScalarFieldEnum | UnitEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent findFirstOrThrow
   */
  export type UnitEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter, which UnitEvent to fetch.
     */
    where?: UnitEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEvents to fetch.
     */
    orderBy?: UnitEventOrderByWithRelationInput | UnitEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEvents.
     */
    cursor?: UnitEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEvents.
     */
    distinct?: UnitEventScalarFieldEnum | UnitEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent findMany
   */
  export type UnitEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter, which UnitEvents to fetch.
     */
    where?: UnitEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEvents to fetch.
     */
    orderBy?: UnitEventOrderByWithRelationInput | UnitEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitEvents.
     */
    cursor?: UnitEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEvents.
     */
    skip?: number
    distinct?: UnitEventScalarFieldEnum | UnitEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent create
   */
  export type UnitEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitEvent.
     */
    data: XOR<UnitEventCreateInput, UnitEventUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent createMany
   */
  export type UnitEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitEvents.
     */
    data: UnitEventCreateManyInput | UnitEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitEvent createManyAndReturn
   */
  export type UnitEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * The data used to create many UnitEvents.
     */
    data: UnitEventCreateManyInput | UnitEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEvent update
   */
  export type UnitEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitEvent.
     */
    data: XOR<UnitEventUpdateInput, UnitEventUncheckedUpdateInput>
    /**
     * Choose, which UnitEvent to update.
     */
    where: UnitEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent updateMany
   */
  export type UnitEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitEvents.
     */
    data: XOR<UnitEventUpdateManyMutationInput, UnitEventUncheckedUpdateManyInput>
    /**
     * Filter which UnitEvents to update
     */
    where?: UnitEventWhereInput
    /**
     * Limit how many UnitEvents to update.
     */
    limit?: number
  }

  /**
   * UnitEvent updateManyAndReturn
   */
  export type UnitEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * The data used to update UnitEvents.
     */
    data: XOR<UnitEventUpdateManyMutationInput, UnitEventUncheckedUpdateManyInput>
    /**
     * Filter which UnitEvents to update
     */
    where?: UnitEventWhereInput
    /**
     * Limit how many UnitEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEvent upsert
   */
  export type UnitEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitEvent to update in case it exists.
     */
    where: UnitEventWhereUniqueInput
    /**
     * In case the UnitEvent found by the `where` argument doesn't exist, create a new UnitEvent with this data.
     */
    create: XOR<UnitEventCreateInput, UnitEventUncheckedCreateInput>
    /**
     * In case the UnitEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitEventUpdateInput, UnitEventUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent delete
   */
  export type UnitEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
    /**
     * Filter which UnitEvent to delete.
     */
    where: UnitEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEvent deleteMany
   */
  export type UnitEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEvents to delete
     */
    where?: UnitEventWhereInput
    /**
     * Limit how many UnitEvents to delete.
     */
    limit?: number
  }

  /**
   * UnitEvent.eventType
   */
  export type UnitEvent$eventTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventType
     */
    select?: UnitEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventType
     */
    omit?: UnitEventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventTypeInclude<ExtArgs> | null
    where?: UnitEventTypeWhereInput
  }

  /**
   * UnitEvent.dutyPositions
   */
  export type UnitEvent$dutyPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    where?: UnitEventDutyPositionWhereInput
    orderBy?: UnitEventDutyPositionOrderByWithRelationInput | UnitEventDutyPositionOrderByWithRelationInput[]
    cursor?: UnitEventDutyPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitEventDutyPositionScalarFieldEnum | UnitEventDutyPositionScalarFieldEnum[]
  }

  /**
   * UnitEvent.dutyAssignments
   */
  export type UnitEvent$dutyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    where?: UnitEventDutyAssignmentWhereInput
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
  }

  /**
   * UnitEvent without action
   */
  export type UnitEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEvent
     */
    select?: UnitEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEvent
     */
    omit?: UnitEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventInclude<ExtArgs> | null
  }


  /**
   * Model UnitEventDutyPosition
   */

  export type AggregateUnitEventDutyPosition = {
    _count: UnitEventDutyPositionCountAggregateOutputType | null
    _avg: UnitEventDutyPositionAvgAggregateOutputType | null
    _sum: UnitEventDutyPositionSumAggregateOutputType | null
    _min: UnitEventDutyPositionMinAggregateOutputType | null
    _max: UnitEventDutyPositionMaxAggregateOutputType | null
  }

  export type UnitEventDutyPositionAvgAggregateOutputType = {
    maxSlots: number | null
    displayOrder: number | null
  }

  export type UnitEventDutyPositionSumAggregateOutputType = {
    maxSlots: number | null
    displayOrder: number | null
  }

  export type UnitEventDutyPositionMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    code: string | null
    name: string | null
    description: string | null
    maxSlots: number | null
    isStandard: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventDutyPositionMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    code: string | null
    name: string | null
    description: string | null
    maxSlots: number | null
    isStandard: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventDutyPositionCountAggregateOutputType = {
    id: number
    eventId: number
    code: number
    name: number
    description: number
    maxSlots: number
    isStandard: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitEventDutyPositionAvgAggregateInputType = {
    maxSlots?: true
    displayOrder?: true
  }

  export type UnitEventDutyPositionSumAggregateInputType = {
    maxSlots?: true
    displayOrder?: true
  }

  export type UnitEventDutyPositionMinAggregateInputType = {
    id?: true
    eventId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    isStandard?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventDutyPositionMaxAggregateInputType = {
    id?: true
    eventId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    isStandard?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventDutyPositionCountAggregateInputType = {
    id?: true
    eventId?: true
    code?: true
    name?: true
    description?: true
    maxSlots?: true
    isStandard?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitEventDutyPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventDutyPosition to aggregate.
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyPositions to fetch.
     */
    orderBy?: UnitEventDutyPositionOrderByWithRelationInput | UnitEventDutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitEventDutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitEventDutyPositions
    **/
    _count?: true | UnitEventDutyPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitEventDutyPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitEventDutyPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitEventDutyPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitEventDutyPositionMaxAggregateInputType
  }

  export type GetUnitEventDutyPositionAggregateType<T extends UnitEventDutyPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitEventDutyPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitEventDutyPosition[P]>
      : GetScalarType<T[P], AggregateUnitEventDutyPosition[P]>
  }




  export type UnitEventDutyPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyPositionWhereInput
    orderBy?: UnitEventDutyPositionOrderByWithAggregationInput | UnitEventDutyPositionOrderByWithAggregationInput[]
    by: UnitEventDutyPositionScalarFieldEnum[] | UnitEventDutyPositionScalarFieldEnum
    having?: UnitEventDutyPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitEventDutyPositionCountAggregateInputType | true
    _avg?: UnitEventDutyPositionAvgAggregateInputType
    _sum?: UnitEventDutyPositionSumAggregateInputType
    _min?: UnitEventDutyPositionMinAggregateInputType
    _max?: UnitEventDutyPositionMaxAggregateInputType
  }

  export type UnitEventDutyPositionGroupByOutputType = {
    id: string
    eventId: string
    code: string
    name: string
    description: string | null
    maxSlots: number
    isStandard: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: UnitEventDutyPositionCountAggregateOutputType | null
    _avg: UnitEventDutyPositionAvgAggregateOutputType | null
    _sum: UnitEventDutyPositionSumAggregateOutputType | null
    _min: UnitEventDutyPositionMinAggregateOutputType | null
    _max: UnitEventDutyPositionMaxAggregateOutputType | null
  }

  type GetUnitEventDutyPositionGroupByPayload<T extends UnitEventDutyPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitEventDutyPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitEventDutyPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitEventDutyPositionGroupByOutputType[P]>
            : GetScalarType<T[P], UnitEventDutyPositionGroupByOutputType[P]>
        }
      >
    >


  export type UnitEventDutyPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    isStandard?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    assignments?: boolean | UnitEventDutyPosition$assignmentsArgs<ExtArgs>
    _count?: boolean | UnitEventDutyPositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyPosition"]>

  export type UnitEventDutyPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    isStandard?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyPosition"]>

  export type UnitEventDutyPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    isStandard?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyPosition"]>

  export type UnitEventDutyPositionSelectScalar = {
    id?: boolean
    eventId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    maxSlots?: boolean
    isStandard?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitEventDutyPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "code" | "name" | "description" | "maxSlots" | "isStandard" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["unitEventDutyPosition"]>
  export type UnitEventDutyPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    assignments?: boolean | UnitEventDutyPosition$assignmentsArgs<ExtArgs>
    _count?: boolean | UnitEventDutyPositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitEventDutyPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
  }
  export type UnitEventDutyPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
  }

  export type $UnitEventDutyPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitEventDutyPosition"
    objects: {
      event: Prisma.$UnitEventPayload<ExtArgs>
      assignments: Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      code: string
      name: string
      description: string | null
      maxSlots: number
      isStandard: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitEventDutyPosition"]>
    composites: {}
  }

  type UnitEventDutyPositionGetPayload<S extends boolean | null | undefined | UnitEventDutyPositionDefaultArgs> = $Result.GetResult<Prisma.$UnitEventDutyPositionPayload, S>

  type UnitEventDutyPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitEventDutyPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UnitEventDutyPositionCountAggregateInputType | true
    }

  export interface UnitEventDutyPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitEventDutyPosition'], meta: { name: 'UnitEventDutyPosition' } }
    /**
     * Find zero or one UnitEventDutyPosition that matches the filter.
     * @param {UnitEventDutyPositionFindUniqueArgs} args - Arguments to find a UnitEventDutyPosition
     * @example
     * // Get one UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitEventDutyPositionFindUniqueArgs>(args: SelectSubset<T, UnitEventDutyPositionFindUniqueArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitEventDutyPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitEventDutyPositionFindUniqueOrThrowArgs} args - Arguments to find a UnitEventDutyPosition
     * @example
     * // Get one UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitEventDutyPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitEventDutyPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventDutyPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionFindFirstArgs} args - Arguments to find a UnitEventDutyPosition
     * @example
     * // Get one UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitEventDutyPositionFindFirstArgs>(args?: SelectSubset<T, UnitEventDutyPositionFindFirstArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventDutyPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionFindFirstOrThrowArgs} args - Arguments to find a UnitEventDutyPosition
     * @example
     * // Get one UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitEventDutyPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitEventDutyPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitEventDutyPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitEventDutyPositions
     * const unitEventDutyPositions = await prisma.unitEventDutyPosition.findMany()
     * 
     * // Get first 10 UnitEventDutyPositions
     * const unitEventDutyPositions = await prisma.unitEventDutyPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitEventDutyPositionWithIdOnly = await prisma.unitEventDutyPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitEventDutyPositionFindManyArgs>(args?: SelectSubset<T, UnitEventDutyPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitEventDutyPosition.
     * @param {UnitEventDutyPositionCreateArgs} args - Arguments to create a UnitEventDutyPosition.
     * @example
     * // Create one UnitEventDutyPosition
     * const UnitEventDutyPosition = await prisma.unitEventDutyPosition.create({
     *   data: {
     *     // ... data to create a UnitEventDutyPosition
     *   }
     * })
     * 
     */
    create<T extends UnitEventDutyPositionCreateArgs>(args: SelectSubset<T, UnitEventDutyPositionCreateArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitEventDutyPositions.
     * @param {UnitEventDutyPositionCreateManyArgs} args - Arguments to create many UnitEventDutyPositions.
     * @example
     * // Create many UnitEventDutyPositions
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitEventDutyPositionCreateManyArgs>(args?: SelectSubset<T, UnitEventDutyPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitEventDutyPositions and returns the data saved in the database.
     * @param {UnitEventDutyPositionCreateManyAndReturnArgs} args - Arguments to create many UnitEventDutyPositions.
     * @example
     * // Create many UnitEventDutyPositions
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitEventDutyPositions and only return the `id`
     * const unitEventDutyPositionWithIdOnly = await prisma.unitEventDutyPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitEventDutyPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitEventDutyPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitEventDutyPosition.
     * @param {UnitEventDutyPositionDeleteArgs} args - Arguments to delete one UnitEventDutyPosition.
     * @example
     * // Delete one UnitEventDutyPosition
     * const UnitEventDutyPosition = await prisma.unitEventDutyPosition.delete({
     *   where: {
     *     // ... filter to delete one UnitEventDutyPosition
     *   }
     * })
     * 
     */
    delete<T extends UnitEventDutyPositionDeleteArgs>(args: SelectSubset<T, UnitEventDutyPositionDeleteArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitEventDutyPosition.
     * @param {UnitEventDutyPositionUpdateArgs} args - Arguments to update one UnitEventDutyPosition.
     * @example
     * // Update one UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitEventDutyPositionUpdateArgs>(args: SelectSubset<T, UnitEventDutyPositionUpdateArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitEventDutyPositions.
     * @param {UnitEventDutyPositionDeleteManyArgs} args - Arguments to filter UnitEventDutyPositions to delete.
     * @example
     * // Delete a few UnitEventDutyPositions
     * const { count } = await prisma.unitEventDutyPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitEventDutyPositionDeleteManyArgs>(args?: SelectSubset<T, UnitEventDutyPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventDutyPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitEventDutyPositions
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitEventDutyPositionUpdateManyArgs>(args: SelectSubset<T, UnitEventDutyPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventDutyPositions and returns the data updated in the database.
     * @param {UnitEventDutyPositionUpdateManyAndReturnArgs} args - Arguments to update many UnitEventDutyPositions.
     * @example
     * // Update many UnitEventDutyPositions
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitEventDutyPositions and only return the `id`
     * const unitEventDutyPositionWithIdOnly = await prisma.unitEventDutyPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitEventDutyPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitEventDutyPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitEventDutyPosition.
     * @param {UnitEventDutyPositionUpsertArgs} args - Arguments to update or create a UnitEventDutyPosition.
     * @example
     * // Update or create a UnitEventDutyPosition
     * const unitEventDutyPosition = await prisma.unitEventDutyPosition.upsert({
     *   create: {
     *     // ... data to create a UnitEventDutyPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitEventDutyPosition we want to update
     *   }
     * })
     */
    upsert<T extends UnitEventDutyPositionUpsertArgs>(args: SelectSubset<T, UnitEventDutyPositionUpsertArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitEventDutyPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionCountArgs} args - Arguments to filter UnitEventDutyPositions to count.
     * @example
     * // Count the number of UnitEventDutyPositions
     * const count = await prisma.unitEventDutyPosition.count({
     *   where: {
     *     // ... the filter for the UnitEventDutyPositions we want to count
     *   }
     * })
    **/
    count<T extends UnitEventDutyPositionCountArgs>(
      args?: Subset<T, UnitEventDutyPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitEventDutyPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitEventDutyPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitEventDutyPositionAggregateArgs>(args: Subset<T, UnitEventDutyPositionAggregateArgs>): Prisma.PrismaPromise<GetUnitEventDutyPositionAggregateType<T>>

    /**
     * Group by UnitEventDutyPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitEventDutyPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitEventDutyPositionGroupByArgs['orderBy'] }
        : { orderBy?: UnitEventDutyPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitEventDutyPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitEventDutyPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitEventDutyPosition model
   */
  readonly fields: UnitEventDutyPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitEventDutyPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitEventDutyPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends UnitEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitEventDefaultArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends UnitEventDutyPosition$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, UnitEventDutyPosition$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitEventDutyPosition model
   */
  interface UnitEventDutyPositionFieldRefs {
    readonly id: FieldRef<"UnitEventDutyPosition", 'String'>
    readonly eventId: FieldRef<"UnitEventDutyPosition", 'String'>
    readonly code: FieldRef<"UnitEventDutyPosition", 'String'>
    readonly name: FieldRef<"UnitEventDutyPosition", 'String'>
    readonly description: FieldRef<"UnitEventDutyPosition", 'String'>
    readonly maxSlots: FieldRef<"UnitEventDutyPosition", 'Int'>
    readonly isStandard: FieldRef<"UnitEventDutyPosition", 'Boolean'>
    readonly displayOrder: FieldRef<"UnitEventDutyPosition", 'Int'>
    readonly createdAt: FieldRef<"UnitEventDutyPosition", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitEventDutyPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitEventDutyPosition findUnique
   */
  export type UnitEventDutyPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyPosition to fetch.
     */
    where: UnitEventDutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition findUniqueOrThrow
   */
  export type UnitEventDutyPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyPosition to fetch.
     */
    where: UnitEventDutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition findFirst
   */
  export type UnitEventDutyPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyPosition to fetch.
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyPositions to fetch.
     */
    orderBy?: UnitEventDutyPositionOrderByWithRelationInput | UnitEventDutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventDutyPositions.
     */
    cursor?: UnitEventDutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventDutyPositions.
     */
    distinct?: UnitEventDutyPositionScalarFieldEnum | UnitEventDutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition findFirstOrThrow
   */
  export type UnitEventDutyPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyPosition to fetch.
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyPositions to fetch.
     */
    orderBy?: UnitEventDutyPositionOrderByWithRelationInput | UnitEventDutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventDutyPositions.
     */
    cursor?: UnitEventDutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventDutyPositions.
     */
    distinct?: UnitEventDutyPositionScalarFieldEnum | UnitEventDutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition findMany
   */
  export type UnitEventDutyPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyPositions to fetch.
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyPositions to fetch.
     */
    orderBy?: UnitEventDutyPositionOrderByWithRelationInput | UnitEventDutyPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitEventDutyPositions.
     */
    cursor?: UnitEventDutyPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyPositions.
     */
    skip?: number
    distinct?: UnitEventDutyPositionScalarFieldEnum | UnitEventDutyPositionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition create
   */
  export type UnitEventDutyPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitEventDutyPosition.
     */
    data: XOR<UnitEventDutyPositionCreateInput, UnitEventDutyPositionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition createMany
   */
  export type UnitEventDutyPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitEventDutyPositions.
     */
    data: UnitEventDutyPositionCreateManyInput | UnitEventDutyPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitEventDutyPosition createManyAndReturn
   */
  export type UnitEventDutyPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * The data used to create many UnitEventDutyPositions.
     */
    data: UnitEventDutyPositionCreateManyInput | UnitEventDutyPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEventDutyPosition update
   */
  export type UnitEventDutyPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitEventDutyPosition.
     */
    data: XOR<UnitEventDutyPositionUpdateInput, UnitEventDutyPositionUncheckedUpdateInput>
    /**
     * Choose, which UnitEventDutyPosition to update.
     */
    where: UnitEventDutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition updateMany
   */
  export type UnitEventDutyPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitEventDutyPositions.
     */
    data: XOR<UnitEventDutyPositionUpdateManyMutationInput, UnitEventDutyPositionUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventDutyPositions to update
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * Limit how many UnitEventDutyPositions to update.
     */
    limit?: number
  }

  /**
   * UnitEventDutyPosition updateManyAndReturn
   */
  export type UnitEventDutyPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * The data used to update UnitEventDutyPositions.
     */
    data: XOR<UnitEventDutyPositionUpdateManyMutationInput, UnitEventDutyPositionUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventDutyPositions to update
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * Limit how many UnitEventDutyPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEventDutyPosition upsert
   */
  export type UnitEventDutyPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitEventDutyPosition to update in case it exists.
     */
    where: UnitEventDutyPositionWhereUniqueInput
    /**
     * In case the UnitEventDutyPosition found by the `where` argument doesn't exist, create a new UnitEventDutyPosition with this data.
     */
    create: XOR<UnitEventDutyPositionCreateInput, UnitEventDutyPositionUncheckedCreateInput>
    /**
     * In case the UnitEventDutyPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitEventDutyPositionUpdateInput, UnitEventDutyPositionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition delete
   */
  export type UnitEventDutyPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    /**
     * Filter which UnitEventDutyPosition to delete.
     */
    where: UnitEventDutyPositionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyPosition deleteMany
   */
  export type UnitEventDutyPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventDutyPositions to delete
     */
    where?: UnitEventDutyPositionWhereInput
    /**
     * Limit how many UnitEventDutyPositions to delete.
     */
    limit?: number
  }

  /**
   * UnitEventDutyPosition.assignments
   */
  export type UnitEventDutyPosition$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    where?: UnitEventDutyAssignmentWhereInput
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
  }

  /**
   * UnitEventDutyPosition without action
   */
  export type UnitEventDutyPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
  }


  /**
   * Model UnitEventDutyAssignment
   */

  export type AggregateUnitEventDutyAssignment = {
    _count: UnitEventDutyAssignmentCountAggregateOutputType | null
    _min: UnitEventDutyAssignmentMinAggregateOutputType | null
    _max: UnitEventDutyAssignmentMaxAggregateOutputType | null
  }

  export type UnitEventDutyAssignmentMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventDutyPositionId: string | null
    memberId: string | null
    status: string | null
    isVolunteer: boolean | null
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventDutyAssignmentMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventDutyPositionId: string | null
    memberId: string | null
    status: string | null
    isVolunteer: boolean | null
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitEventDutyAssignmentCountAggregateOutputType = {
    id: number
    eventId: number
    eventDutyPositionId: number
    memberId: number
    status: number
    isVolunteer: number
    confirmedAt: number
    releasedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitEventDutyAssignmentMinAggregateInputType = {
    id?: true
    eventId?: true
    eventDutyPositionId?: true
    memberId?: true
    status?: true
    isVolunteer?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventDutyAssignmentMaxAggregateInputType = {
    id?: true
    eventId?: true
    eventDutyPositionId?: true
    memberId?: true
    status?: true
    isVolunteer?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitEventDutyAssignmentCountAggregateInputType = {
    id?: true
    eventId?: true
    eventDutyPositionId?: true
    memberId?: true
    status?: true
    isVolunteer?: true
    confirmedAt?: true
    releasedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitEventDutyAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventDutyAssignment to aggregate.
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyAssignments to fetch.
     */
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitEventDutyAssignments
    **/
    _count?: true | UnitEventDutyAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitEventDutyAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitEventDutyAssignmentMaxAggregateInputType
  }

  export type GetUnitEventDutyAssignmentAggregateType<T extends UnitEventDutyAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitEventDutyAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitEventDutyAssignment[P]>
      : GetScalarType<T[P], AggregateUnitEventDutyAssignment[P]>
  }




  export type UnitEventDutyAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitEventDutyAssignmentWhereInput
    orderBy?: UnitEventDutyAssignmentOrderByWithAggregationInput | UnitEventDutyAssignmentOrderByWithAggregationInput[]
    by: UnitEventDutyAssignmentScalarFieldEnum[] | UnitEventDutyAssignmentScalarFieldEnum
    having?: UnitEventDutyAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitEventDutyAssignmentCountAggregateInputType | true
    _min?: UnitEventDutyAssignmentMinAggregateInputType
    _max?: UnitEventDutyAssignmentMaxAggregateInputType
  }

  export type UnitEventDutyAssignmentGroupByOutputType = {
    id: string
    eventId: string
    eventDutyPositionId: string | null
    memberId: string
    status: string
    isVolunteer: boolean
    confirmedAt: Date | null
    releasedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitEventDutyAssignmentCountAggregateOutputType | null
    _min: UnitEventDutyAssignmentMinAggregateOutputType | null
    _max: UnitEventDutyAssignmentMaxAggregateOutputType | null
  }

  type GetUnitEventDutyAssignmentGroupByPayload<T extends UnitEventDutyAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitEventDutyAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitEventDutyAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitEventDutyAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], UnitEventDutyAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type UnitEventDutyAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventDutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    isVolunteer?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyAssignment"]>

  export type UnitEventDutyAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventDutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    isVolunteer?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyAssignment"]>

  export type UnitEventDutyAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventDutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    isVolunteer?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitEventDutyAssignment"]>

  export type UnitEventDutyAssignmentSelectScalar = {
    id?: boolean
    eventId?: boolean
    eventDutyPositionId?: boolean
    memberId?: boolean
    status?: boolean
    isVolunteer?: boolean
    confirmedAt?: boolean
    releasedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitEventDutyAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "eventDutyPositionId" | "memberId" | "status" | "isVolunteer" | "confirmedAt" | "releasedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["unitEventDutyAssignment"]>
  export type UnitEventDutyAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UnitEventDutyAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UnitEventDutyAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | UnitEventDefaultArgs<ExtArgs>
    eventDutyPosition?: boolean | UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $UnitEventDutyAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitEventDutyAssignment"
    objects: {
      event: Prisma.$UnitEventPayload<ExtArgs>
      eventDutyPosition: Prisma.$UnitEventDutyPositionPayload<ExtArgs> | null
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      eventDutyPositionId: string | null
      memberId: string
      status: string
      isVolunteer: boolean
      confirmedAt: Date | null
      releasedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitEventDutyAssignment"]>
    composites: {}
  }

  type UnitEventDutyAssignmentGetPayload<S extends boolean | null | undefined | UnitEventDutyAssignmentDefaultArgs> = $Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload, S>

  type UnitEventDutyAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitEventDutyAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UnitEventDutyAssignmentCountAggregateInputType | true
    }

  export interface UnitEventDutyAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitEventDutyAssignment'], meta: { name: 'UnitEventDutyAssignment' } }
    /**
     * Find zero or one UnitEventDutyAssignment that matches the filter.
     * @param {UnitEventDutyAssignmentFindUniqueArgs} args - Arguments to find a UnitEventDutyAssignment
     * @example
     * // Get one UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitEventDutyAssignmentFindUniqueArgs>(args: SelectSubset<T, UnitEventDutyAssignmentFindUniqueArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitEventDutyAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitEventDutyAssignmentFindUniqueOrThrowArgs} args - Arguments to find a UnitEventDutyAssignment
     * @example
     * // Get one UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitEventDutyAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitEventDutyAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventDutyAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentFindFirstArgs} args - Arguments to find a UnitEventDutyAssignment
     * @example
     * // Get one UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitEventDutyAssignmentFindFirstArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentFindFirstArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitEventDutyAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentFindFirstOrThrowArgs} args - Arguments to find a UnitEventDutyAssignment
     * @example
     * // Get one UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitEventDutyAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitEventDutyAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitEventDutyAssignments
     * const unitEventDutyAssignments = await prisma.unitEventDutyAssignment.findMany()
     * 
     * // Get first 10 UnitEventDutyAssignments
     * const unitEventDutyAssignments = await prisma.unitEventDutyAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitEventDutyAssignmentWithIdOnly = await prisma.unitEventDutyAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitEventDutyAssignmentFindManyArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitEventDutyAssignment.
     * @param {UnitEventDutyAssignmentCreateArgs} args - Arguments to create a UnitEventDutyAssignment.
     * @example
     * // Create one UnitEventDutyAssignment
     * const UnitEventDutyAssignment = await prisma.unitEventDutyAssignment.create({
     *   data: {
     *     // ... data to create a UnitEventDutyAssignment
     *   }
     * })
     * 
     */
    create<T extends UnitEventDutyAssignmentCreateArgs>(args: SelectSubset<T, UnitEventDutyAssignmentCreateArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitEventDutyAssignments.
     * @param {UnitEventDutyAssignmentCreateManyArgs} args - Arguments to create many UnitEventDutyAssignments.
     * @example
     * // Create many UnitEventDutyAssignments
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitEventDutyAssignmentCreateManyArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitEventDutyAssignments and returns the data saved in the database.
     * @param {UnitEventDutyAssignmentCreateManyAndReturnArgs} args - Arguments to create many UnitEventDutyAssignments.
     * @example
     * // Create many UnitEventDutyAssignments
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitEventDutyAssignments and only return the `id`
     * const unitEventDutyAssignmentWithIdOnly = await prisma.unitEventDutyAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitEventDutyAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitEventDutyAssignment.
     * @param {UnitEventDutyAssignmentDeleteArgs} args - Arguments to delete one UnitEventDutyAssignment.
     * @example
     * // Delete one UnitEventDutyAssignment
     * const UnitEventDutyAssignment = await prisma.unitEventDutyAssignment.delete({
     *   where: {
     *     // ... filter to delete one UnitEventDutyAssignment
     *   }
     * })
     * 
     */
    delete<T extends UnitEventDutyAssignmentDeleteArgs>(args: SelectSubset<T, UnitEventDutyAssignmentDeleteArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitEventDutyAssignment.
     * @param {UnitEventDutyAssignmentUpdateArgs} args - Arguments to update one UnitEventDutyAssignment.
     * @example
     * // Update one UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitEventDutyAssignmentUpdateArgs>(args: SelectSubset<T, UnitEventDutyAssignmentUpdateArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitEventDutyAssignments.
     * @param {UnitEventDutyAssignmentDeleteManyArgs} args - Arguments to filter UnitEventDutyAssignments to delete.
     * @example
     * // Delete a few UnitEventDutyAssignments
     * const { count } = await prisma.unitEventDutyAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitEventDutyAssignmentDeleteManyArgs>(args?: SelectSubset<T, UnitEventDutyAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventDutyAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitEventDutyAssignments
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitEventDutyAssignmentUpdateManyArgs>(args: SelectSubset<T, UnitEventDutyAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitEventDutyAssignments and returns the data updated in the database.
     * @param {UnitEventDutyAssignmentUpdateManyAndReturnArgs} args - Arguments to update many UnitEventDutyAssignments.
     * @example
     * // Update many UnitEventDutyAssignments
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitEventDutyAssignments and only return the `id`
     * const unitEventDutyAssignmentWithIdOnly = await prisma.unitEventDutyAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitEventDutyAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitEventDutyAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitEventDutyAssignment.
     * @param {UnitEventDutyAssignmentUpsertArgs} args - Arguments to update or create a UnitEventDutyAssignment.
     * @example
     * // Update or create a UnitEventDutyAssignment
     * const unitEventDutyAssignment = await prisma.unitEventDutyAssignment.upsert({
     *   create: {
     *     // ... data to create a UnitEventDutyAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitEventDutyAssignment we want to update
     *   }
     * })
     */
    upsert<T extends UnitEventDutyAssignmentUpsertArgs>(args: SelectSubset<T, UnitEventDutyAssignmentUpsertArgs<ExtArgs>>): Prisma__UnitEventDutyAssignmentClient<$Result.GetResult<Prisma.$UnitEventDutyAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitEventDutyAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentCountArgs} args - Arguments to filter UnitEventDutyAssignments to count.
     * @example
     * // Count the number of UnitEventDutyAssignments
     * const count = await prisma.unitEventDutyAssignment.count({
     *   where: {
     *     // ... the filter for the UnitEventDutyAssignments we want to count
     *   }
     * })
    **/
    count<T extends UnitEventDutyAssignmentCountArgs>(
      args?: Subset<T, UnitEventDutyAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitEventDutyAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitEventDutyAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitEventDutyAssignmentAggregateArgs>(args: Subset<T, UnitEventDutyAssignmentAggregateArgs>): Prisma.PrismaPromise<GetUnitEventDutyAssignmentAggregateType<T>>

    /**
     * Group by UnitEventDutyAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitEventDutyAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitEventDutyAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitEventDutyAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: UnitEventDutyAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitEventDutyAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitEventDutyAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitEventDutyAssignment model
   */
  readonly fields: UnitEventDutyAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitEventDutyAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitEventDutyAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends UnitEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitEventDefaultArgs<ExtArgs>>): Prisma__UnitEventClient<$Result.GetResult<Prisma.$UnitEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventDutyPosition<T extends UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs> = {}>(args?: Subset<T, UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs>>): Prisma__UnitEventDutyPositionClient<$Result.GetResult<Prisma.$UnitEventDutyPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitEventDutyAssignment model
   */
  interface UnitEventDutyAssignmentFieldRefs {
    readonly id: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly eventId: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly eventDutyPositionId: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly memberId: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly status: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly isVolunteer: FieldRef<"UnitEventDutyAssignment", 'Boolean'>
    readonly confirmedAt: FieldRef<"UnitEventDutyAssignment", 'DateTime'>
    readonly releasedAt: FieldRef<"UnitEventDutyAssignment", 'DateTime'>
    readonly notes: FieldRef<"UnitEventDutyAssignment", 'String'>
    readonly createdAt: FieldRef<"UnitEventDutyAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitEventDutyAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitEventDutyAssignment findUnique
   */
  export type UnitEventDutyAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyAssignment to fetch.
     */
    where: UnitEventDutyAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment findUniqueOrThrow
   */
  export type UnitEventDutyAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyAssignment to fetch.
     */
    where: UnitEventDutyAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment findFirst
   */
  export type UnitEventDutyAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyAssignment to fetch.
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyAssignments to fetch.
     */
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventDutyAssignments.
     */
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventDutyAssignments.
     */
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment findFirstOrThrow
   */
  export type UnitEventDutyAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyAssignment to fetch.
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyAssignments to fetch.
     */
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitEventDutyAssignments.
     */
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitEventDutyAssignments.
     */
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment findMany
   */
  export type UnitEventDutyAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitEventDutyAssignments to fetch.
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitEventDutyAssignments to fetch.
     */
    orderBy?: UnitEventDutyAssignmentOrderByWithRelationInput | UnitEventDutyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitEventDutyAssignments.
     */
    cursor?: UnitEventDutyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitEventDutyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitEventDutyAssignments.
     */
    skip?: number
    distinct?: UnitEventDutyAssignmentScalarFieldEnum | UnitEventDutyAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment create
   */
  export type UnitEventDutyAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitEventDutyAssignment.
     */
    data: XOR<UnitEventDutyAssignmentCreateInput, UnitEventDutyAssignmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment createMany
   */
  export type UnitEventDutyAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitEventDutyAssignments.
     */
    data: UnitEventDutyAssignmentCreateManyInput | UnitEventDutyAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitEventDutyAssignment createManyAndReturn
   */
  export type UnitEventDutyAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many UnitEventDutyAssignments.
     */
    data: UnitEventDutyAssignmentCreateManyInput | UnitEventDutyAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEventDutyAssignment update
   */
  export type UnitEventDutyAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitEventDutyAssignment.
     */
    data: XOR<UnitEventDutyAssignmentUpdateInput, UnitEventDutyAssignmentUncheckedUpdateInput>
    /**
     * Choose, which UnitEventDutyAssignment to update.
     */
    where: UnitEventDutyAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment updateMany
   */
  export type UnitEventDutyAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitEventDutyAssignments.
     */
    data: XOR<UnitEventDutyAssignmentUpdateManyMutationInput, UnitEventDutyAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventDutyAssignments to update
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * Limit how many UnitEventDutyAssignments to update.
     */
    limit?: number
  }

  /**
   * UnitEventDutyAssignment updateManyAndReturn
   */
  export type UnitEventDutyAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update UnitEventDutyAssignments.
     */
    data: XOR<UnitEventDutyAssignmentUpdateManyMutationInput, UnitEventDutyAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which UnitEventDutyAssignments to update
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * Limit how many UnitEventDutyAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitEventDutyAssignment upsert
   */
  export type UnitEventDutyAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitEventDutyAssignment to update in case it exists.
     */
    where: UnitEventDutyAssignmentWhereUniqueInput
    /**
     * In case the UnitEventDutyAssignment found by the `where` argument doesn't exist, create a new UnitEventDutyAssignment with this data.
     */
    create: XOR<UnitEventDutyAssignmentCreateInput, UnitEventDutyAssignmentUncheckedCreateInput>
    /**
     * In case the UnitEventDutyAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitEventDutyAssignmentUpdateInput, UnitEventDutyAssignmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment delete
   */
  export type UnitEventDutyAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
    /**
     * Filter which UnitEventDutyAssignment to delete.
     */
    where: UnitEventDutyAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UnitEventDutyAssignment deleteMany
   */
  export type UnitEventDutyAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitEventDutyAssignments to delete
     */
    where?: UnitEventDutyAssignmentWhereInput
    /**
     * Limit how many UnitEventDutyAssignments to delete.
     */
    limit?: number
  }

  /**
   * UnitEventDutyAssignment.eventDutyPosition
   */
  export type UnitEventDutyAssignment$eventDutyPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyPosition
     */
    select?: UnitEventDutyPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyPosition
     */
    omit?: UnitEventDutyPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyPositionInclude<ExtArgs> | null
    where?: UnitEventDutyPositionWhereInput
  }

  /**
   * UnitEventDutyAssignment without action
   */
  export type UnitEventDutyAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitEventDutyAssignment
     */
    select?: UnitEventDutyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitEventDutyAssignment
     */
    omit?: UnitEventDutyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitEventDutyAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    fullName: 'fullName',
    role: 'role',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    first_name: 'first_name',
    last_name: 'last_name',
    updated_at: 'updated_at',
    disabled: 'disabled',
    disabledAt: 'disabledAt',
    disabledBy: 'disabledBy',
    updatedBy: 'updatedBy'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    adminUserId: 'adminUserId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    assignmentType: 'assignmentType',
    assignedToId: 'assignedToId',
    status: 'status',
    badgeStatusId: 'badgeStatusId',
    lastUsed: 'lastUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CheckinScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    badgeId: 'badgeId',
    direction: 'direction',
    timestamp: 'timestamp',
    kioskId: 'kioskId',
    synced: 'synced',
    createdAt: 'createdAt',
    flagged_for_review: 'flagged_for_review',
    flag_reason: 'flag_reason',
    method: 'method',
    created_by_admin: 'created_by_admin'
  };

  export type CheckinScalarFieldEnum = (typeof CheckinScalarFieldEnum)[keyof typeof CheckinScalarFieldEnum]


  export const DivisionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DivisionScalarFieldEnum = (typeof DivisionScalarFieldEnum)[keyof typeof DivisionScalarFieldEnum]


  export const EventAttendeeScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    rank: 'rank',
    organization: 'organization',
    role: 'role',
    badgeId: 'badgeId',
    badgeAssignedAt: 'badgeAssignedAt',
    accessStart: 'accessStart',
    accessEnd: 'accessEnd',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventAttendeeScalarFieldEnum = (typeof EventAttendeeScalarFieldEnum)[keyof typeof EventAttendeeScalarFieldEnum]


  export const EventCheckinScalarFieldEnum: {
    id: 'id',
    eventAttendeeId: 'eventAttendeeId',
    badgeId: 'badgeId',
    direction: 'direction',
    timestamp: 'timestamp',
    kioskId: 'kioskId',
    createdAt: 'createdAt'
  };

  export type EventCheckinScalarFieldEnum = (typeof EventCheckinScalarFieldEnum)[keyof typeof EventCheckinScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    autoExpireBadges: 'autoExpireBadges',
    customRoles: 'customRoles',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    serviceNumber: 'serviceNumber',
    rankId: 'rankId',
    rank: 'rank',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    mobilePhone: 'mobilePhone',
    divisionId: 'divisionId',
    badgeId: 'badgeId',
    memberType: 'memberType',
    status: 'status',
    memberTypeId: 'memberTypeId',
    memberStatusId: 'memberStatusId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employeeNumber: 'employeeNumber',
    initials: 'initials',
    mess: 'mess',
    moc: 'moc',
    classDetails: 'classDetails',
    homePhone: 'homePhone',
    notes: 'notes',
    contract_start: 'contract_start',
    contract_end: 'contract_end',
    missedCheckoutCount: 'missedCheckoutCount',
    lastMissedCheckout: 'lastMissedCheckout'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    displayOrder: 'displayOrder',
    chipVariant: 'chipVariant',
    chipColor: 'chipColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const MemberTagScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type MemberTagScalarFieldEnum = (typeof MemberTagScalarFieldEnum)[keyof typeof MemberTagScalarFieldEnum]


  export const SecurityAlertScalarFieldEnum: {
    id: 'id',
    alertType: 'alertType',
    severity: 'severity',
    badgeSerial: 'badgeSerial',
    memberId: 'memberId',
    kioskId: 'kioskId',
    message: 'message',
    details: 'details',
    status: 'status',
    acknowledgedBy: 'acknowledgedBy',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgeNote: 'acknowledgeNote',
    createdAt: 'createdAt'
  };

  export type SecurityAlertScalarFieldEnum = (typeof SecurityAlertScalarFieldEnum)[keyof typeof SecurityAlertScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organization: 'organization',
    visitType: 'visitType',
    visitTypeId: 'visitTypeId',
    visitReason: 'visitReason',
    eventId: 'eventId',
    hostMemberId: 'hostMemberId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    temporaryBadgeId: 'temporaryBadgeId',
    kioskId: 'kioskId',
    createdAt: 'createdAt',
    adminNotes: 'adminNotes',
    checkInMethod: 'checkInMethod',
    createdByAdmin: 'createdByAdmin'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const BmqCourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    trainingStartTime: 'trainingStartTime',
    trainingEndTime: 'trainingEndTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    trainingDays: 'trainingDays'
  };

  export type BmqCourseScalarFieldEnum = (typeof BmqCourseScalarFieldEnum)[keyof typeof BmqCourseScalarFieldEnum]


  export const BmqEnrollmentScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    bmqCourseId: 'bmqCourseId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    status: 'status'
  };

  export type BmqEnrollmentScalarFieldEnum = (typeof BmqEnrollmentScalarFieldEnum)[keyof typeof BmqEnrollmentScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    applied_at: 'applied_at'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const Report_audit_logScalarFieldEnum: {
    id: 'id',
    report_type: 'report_type',
    report_config: 'report_config',
    generated_by: 'generated_by',
    is_scheduled: 'is_scheduled',
    scheduled_report_id: 'scheduled_report_id',
    generated_at: 'generated_at',
    file_size_bytes: 'file_size_bytes',
    generation_time_ms: 'generation_time_ms'
  };

  export type Report_audit_logScalarFieldEnum = (typeof Report_audit_logScalarFieldEnum)[keyof typeof Report_audit_logScalarFieldEnum]


  export const ReportSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type ReportSettingScalarFieldEnum = (typeof ReportSettingScalarFieldEnum)[keyof typeof ReportSettingScalarFieldEnum]


  export const TrainingYearScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    holidayExclusions: 'holidayExclusions',
    dayExceptions: 'dayExceptions',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingYearScalarFieldEnum = (typeof TrainingYearScalarFieldEnum)[keyof typeof TrainingYearScalarFieldEnum]


  export const DdsAssignmentScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    assignedDate: 'assignedDate',
    acceptedAt: 'acceptedAt',
    releasedAt: 'releasedAt',
    transferredTo: 'transferredTo',
    assignedBy: 'assignedBy',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DdsAssignmentScalarFieldEnum = (typeof DdsAssignmentScalarFieldEnum)[keyof typeof DdsAssignmentScalarFieldEnum]


  export const ResponsibilityAuditLogScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    tagName: 'tagName',
    action: 'action',
    fromMemberId: 'fromMemberId',
    toMemberId: 'toMemberId',
    performedBy: 'performedBy',
    performedByType: 'performedByType',
    timestamp: 'timestamp',
    notes: 'notes'
  };

  export type ResponsibilityAuditLogScalarFieldEnum = (typeof ResponsibilityAuditLogScalarFieldEnum)[keyof typeof ResponsibilityAuditLogScalarFieldEnum]


  export const MemberStatusScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    chipVariant: 'chipVariant',
    chipColor: 'chipColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberStatusScalarFieldEnum = (typeof MemberStatusScalarFieldEnum)[keyof typeof MemberStatusScalarFieldEnum]


  export const MemberTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    chipVariant: 'chipVariant',
    chipColor: 'chipColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberTypeScalarFieldEnum = (typeof MemberTypeScalarFieldEnum)[keyof typeof MemberTypeScalarFieldEnum]


  export const VisitTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    chipVariant: 'chipVariant',
    chipColor: 'chipColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitTypeScalarFieldEnum = (typeof VisitTypeScalarFieldEnum)[keyof typeof VisitTypeScalarFieldEnum]


  export const BadgeStatusScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    chipVariant: 'chipVariant',
    chipColor: 'chipColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeStatusScalarFieldEnum = (typeof BadgeStatusScalarFieldEnum)[keyof typeof BadgeStatusScalarFieldEnum]


  export const ListItemScalarFieldEnum: {
    id: 'id',
    listType: 'listType',
    code: 'code',
    name: 'name',
    displayOrder: 'displayOrder',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListItemScalarFieldEnum = (typeof ListItemScalarFieldEnum)[keyof typeof ListItemScalarFieldEnum]


  export const RankScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    branch: 'branch',
    category: 'category',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    replacedBy: 'replacedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RankScalarFieldEnum = (typeof RankScalarFieldEnum)[keyof typeof RankScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    image: 'image',
    role: 'role',
    badgeId: 'badgeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    expiresAt: 'expiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const AlertConfigScalarFieldEnum: {
    key: 'key',
    config: 'config',
    updatedAt: 'updatedAt'
  };

  export type AlertConfigScalarFieldEnum = (typeof AlertConfigScalarFieldEnum)[keyof typeof AlertConfigScalarFieldEnum]


  export const StatHolidayScalarFieldEnum: {
    id: 'id',
    date: 'date',
    name: 'name',
    province: 'province',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatHolidayScalarFieldEnum = (typeof StatHolidayScalarFieldEnum)[keyof typeof StatHolidayScalarFieldEnum]


  export const QualificationTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    canReceiveLockup: 'canReceiveLockup',
    displayOrder: 'displayOrder',
    tagId: 'tagId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QualificationTypeScalarFieldEnum = (typeof QualificationTypeScalarFieldEnum)[keyof typeof QualificationTypeScalarFieldEnum]


  export const MemberQualificationScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    qualificationTypeId: 'qualificationTypeId',
    status: 'status',
    grantedAt: 'grantedAt',
    grantedBy: 'grantedBy',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    revokedBy: 'revokedBy',
    revokeReason: 'revokeReason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberQualificationScalarFieldEnum = (typeof MemberQualificationScalarFieldEnum)[keyof typeof MemberQualificationScalarFieldEnum]


  export const DutyRoleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    roleType: 'roleType',
    scheduleType: 'scheduleType',
    activeDays: 'activeDays',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DutyRoleScalarFieldEnum = (typeof DutyRoleScalarFieldEnum)[keyof typeof DutyRoleScalarFieldEnum]


  export const DutyPositionScalarFieldEnum: {
    id: 'id',
    dutyRoleId: 'dutyRoleId',
    code: 'code',
    name: 'name',
    description: 'description',
    maxSlots: 'maxSlots',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DutyPositionScalarFieldEnum = (typeof DutyPositionScalarFieldEnum)[keyof typeof DutyPositionScalarFieldEnum]


  export const WeeklyScheduleScalarFieldEnum: {
    id: 'id',
    dutyRoleId: 'dutyRoleId',
    weekStartDate: 'weekStartDate',
    status: 'status',
    createdBy: 'createdBy',
    publishedAt: 'publishedAt',
    publishedBy: 'publishedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeeklyScheduleScalarFieldEnum = (typeof WeeklyScheduleScalarFieldEnum)[keyof typeof WeeklyScheduleScalarFieldEnum]


  export const ScheduleAssignmentScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    dutyPositionId: 'dutyPositionId',
    memberId: 'memberId',
    status: 'status',
    confirmedAt: 'confirmedAt',
    releasedAt: 'releasedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleAssignmentScalarFieldEnum = (typeof ScheduleAssignmentScalarFieldEnum)[keyof typeof ScheduleAssignmentScalarFieldEnum]


  export const LockupStatusScalarFieldEnum: {
    id: 'id',
    date: 'date',
    currentHolderId: 'currentHolderId',
    acquiredAt: 'acquiredAt',
    buildingStatus: 'buildingStatus',
    securedAt: 'securedAt',
    securedBy: 'securedBy',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LockupStatusScalarFieldEnum = (typeof LockupStatusScalarFieldEnum)[keyof typeof LockupStatusScalarFieldEnum]


  export const LockupTransferScalarFieldEnum: {
    id: 'id',
    lockupStatusId: 'lockupStatusId',
    fromMemberId: 'fromMemberId',
    toMemberId: 'toMemberId',
    transferredAt: 'transferredAt',
    reason: 'reason',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type LockupTransferScalarFieldEnum = (typeof LockupTransferScalarFieldEnum)[keyof typeof LockupTransferScalarFieldEnum]


  export const LockupExecutionScalarFieldEnum: {
    id: 'id',
    lockupStatusId: 'lockupStatusId',
    executedBy: 'executedBy',
    executedAt: 'executedAt',
    membersCheckedOut: 'membersCheckedOut',
    visitorsCheckedOut: 'visitorsCheckedOut',
    totalCheckedOut: 'totalCheckedOut',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type LockupExecutionScalarFieldEnum = (typeof LockupExecutionScalarFieldEnum)[keyof typeof LockupExecutionScalarFieldEnum]


  export const MissedCheckoutScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    date: 'date',
    originalCheckinAt: 'originalCheckinAt',
    forcedCheckoutAt: 'forcedCheckoutAt',
    resolvedBy: 'resolvedBy',
    resolvedByAdminId: 'resolvedByAdminId',
    lockupExecutionId: 'lockupExecutionId',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type MissedCheckoutScalarFieldEnum = (typeof MissedCheckoutScalarFieldEnum)[keyof typeof MissedCheckoutScalarFieldEnum]


  export const UnitEventTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    defaultDurationMinutes: 'defaultDurationMinutes',
    requiresDutyWatch: 'requiresDutyWatch',
    defaultMetadata: 'defaultMetadata',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitEventTypeScalarFieldEnum = (typeof UnitEventTypeScalarFieldEnum)[keyof typeof UnitEventTypeScalarFieldEnum]


  export const UnitEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    eventTypeId: 'eventTypeId',
    eventDate: 'eventDate',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    description: 'description',
    organizer: 'organizer',
    requiresDutyWatch: 'requiresDutyWatch',
    status: 'status',
    metadata: 'metadata',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitEventScalarFieldEnum = (typeof UnitEventScalarFieldEnum)[keyof typeof UnitEventScalarFieldEnum]


  export const UnitEventDutyPositionScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    code: 'code',
    name: 'name',
    description: 'description',
    maxSlots: 'maxSlots',
    isStandard: 'isStandard',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitEventDutyPositionScalarFieldEnum = (typeof UnitEventDutyPositionScalarFieldEnum)[keyof typeof UnitEventDutyPositionScalarFieldEnum]


  export const UnitEventDutyAssignmentScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    eventDutyPositionId: 'eventDutyPositionId',
    memberId: 'memberId',
    status: 'status',
    isVolunteer: 'isVolunteer',
    confirmedAt: 'confirmedAt',
    releasedAt: 'releasedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitEventDutyAssignmentScalarFieldEnum = (typeof UnitEventDutyAssignmentScalarFieldEnum)[keyof typeof UnitEventDutyAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: UuidFilter<"AdminUser"> | string
    username?: StringFilter<"AdminUser"> | string
    email?: StringNullableFilter<"AdminUser"> | string | null
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckinListRelationFilter
    report_audit_log?: Report_audit_logListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    visitors?: VisitorListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    disabledByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    updatedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    disabledUsers?: AdminUserListRelationFilter
    updatedUsers?: AdminUserListRelationFilter
    qualificationsGranted?: MemberQualificationListRelationFilter
    qualificationsRevoked?: MemberQualificationListRelationFilter
    schedulesCreated?: WeeklyScheduleListRelationFilter
    schedulesPublished?: WeeklyScheduleListRelationFilter
    missedCheckoutsResolved?: MissedCheckoutListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    checkins?: CheckinOrderByRelationAggregateInput
    report_audit_log?: report_audit_logOrderByRelationAggregateInput
    securityAlerts?: SecurityAlertOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    ddsAssignments?: DdsAssignmentOrderByRelationAggregateInput
    disabledByAdmin?: AdminUserOrderByWithRelationInput
    updatedByAdmin?: AdminUserOrderByWithRelationInput
    disabledUsers?: AdminUserOrderByRelationAggregateInput
    updatedUsers?: AdminUserOrderByRelationAggregateInput
    qualificationsGranted?: MemberQualificationOrderByRelationAggregateInput
    qualificationsRevoked?: MemberQualificationOrderByRelationAggregateInput
    schedulesCreated?: WeeklyScheduleOrderByRelationAggregateInput
    schedulesPublished?: WeeklyScheduleOrderByRelationAggregateInput
    missedCheckoutsResolved?: MissedCheckoutOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckinListRelationFilter
    report_audit_log?: Report_audit_logListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    visitors?: VisitorListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    disabledByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    updatedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    disabledUsers?: AdminUserListRelationFilter
    updatedUsers?: AdminUserListRelationFilter
    qualificationsGranted?: MemberQualificationListRelationFilter
    qualificationsRevoked?: MemberQualificationListRelationFilter
    schedulesCreated?: WeeklyScheduleListRelationFilter
    schedulesPublished?: WeeklyScheduleListRelationFilter
    missedCheckoutsResolved?: MissedCheckoutListRelationFilter
  }, "id" | "username" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdminUser"> | string
    username?: StringWithAggregatesFilter<"AdminUser"> | string
    email?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    passwordHash?: StringWithAggregatesFilter<"AdminUser"> | string
    displayName?: StringWithAggregatesFilter<"AdminUser"> | string
    fullName?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    role?: StringWithAggregatesFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    disabled?: BoolWithAggregatesFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableWithAggregatesFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"AdminUser"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    adminUser?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminUser?: AdminUserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    adminUser?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    adminUserId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AuditLog"> | Date | string | null
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: UuidFilter<"Badge"> | string
    serialNumber?: StringFilter<"Badge"> | string
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    checkins?: CheckinListRelationFilter
    eventAttendees?: EventAttendeeListRelationFilter
    eventCheckins?: EventCheckinListRelationFilter
    members?: MemberListRelationFilter
    visitors?: VisitorListRelationFilter
    badgeStatusRef?: XOR<BadgeStatusNullableScalarRelationFilter, BadgeStatusWhereInput> | null
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    checkins?: CheckinOrderByRelationAggregateInput
    eventAttendees?: EventAttendeeOrderByRelationAggregateInput
    eventCheckins?: EventCheckinOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    badgeStatusRef?: BadgeStatusOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    checkins?: CheckinListRelationFilter
    eventAttendees?: EventAttendeeListRelationFilter
    eventCheckins?: EventCheckinListRelationFilter
    members?: MemberListRelationFilter
    visitors?: VisitorListRelationFilter
    badgeStatusRef?: XOR<BadgeStatusNullableScalarRelationFilter, BadgeStatusWhereInput> | null
  }, "id" | "serialNumber">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Badge"> | string
    serialNumber?: StringWithAggregatesFilter<"Badge"> | string
    assignmentType?: StringWithAggregatesFilter<"Badge"> | string
    assignedToId?: UuidNullableWithAggregatesFilter<"Badge"> | string | null
    status?: StringWithAggregatesFilter<"Badge"> | string
    badgeStatusId?: UuidNullableWithAggregatesFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
  }

  export type CheckinWhereInput = {
    AND?: CheckinWhereInput | CheckinWhereInput[]
    OR?: CheckinWhereInput[]
    NOT?: CheckinWhereInput | CheckinWhereInput[]
    id?: UuidFilter<"Checkin"> | string
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }

  export type CheckinOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    flagged_for_review?: SortOrderInput | SortOrder
    flag_reason?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    created_by_admin?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    admin_users?: AdminUserOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type CheckinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckinWhereInput | CheckinWhereInput[]
    OR?: CheckinWhereInput[]
    NOT?: CheckinWhereInput | CheckinWhereInput[]
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }, "id">

  export type CheckinOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    flagged_for_review?: SortOrderInput | SortOrder
    flag_reason?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    created_by_admin?: SortOrderInput | SortOrder
    _count?: CheckinCountOrderByAggregateInput
    _max?: CheckinMaxOrderByAggregateInput
    _min?: CheckinMinOrderByAggregateInput
  }

  export type CheckinScalarWhereWithAggregatesInput = {
    AND?: CheckinScalarWhereWithAggregatesInput | CheckinScalarWhereWithAggregatesInput[]
    OR?: CheckinScalarWhereWithAggregatesInput[]
    NOT?: CheckinScalarWhereWithAggregatesInput | CheckinScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Checkin"> | string
    memberId?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
    badgeId?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
    direction?: StringWithAggregatesFilter<"Checkin"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Checkin"> | Date | string
    kioskId?: StringWithAggregatesFilter<"Checkin"> | string
    synced?: BoolNullableWithAggregatesFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableWithAggregatesFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableWithAggregatesFilter<"Checkin"> | string | null
    method?: StringNullableWithAggregatesFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
  }

  export type DivisionWhereInput = {
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    id?: UuidFilter<"Division"> | string
    name?: StringFilter<"Division"> | string
    code?: StringFilter<"Division"> | string
    description?: StringNullableFilter<"Division"> | string | null
    createdAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type DivisionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type DivisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    name?: StringFilter<"Division"> | string
    description?: StringNullableFilter<"Division"> | string | null
    createdAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type DivisionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DivisionCountOrderByAggregateInput
    _max?: DivisionMaxOrderByAggregateInput
    _min?: DivisionMinOrderByAggregateInput
  }

  export type DivisionScalarWhereWithAggregatesInput = {
    AND?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    OR?: DivisionScalarWhereWithAggregatesInput[]
    NOT?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Division"> | string
    name?: StringWithAggregatesFilter<"Division"> | string
    code?: StringWithAggregatesFilter<"Division"> | string
    description?: StringNullableWithAggregatesFilter<"Division"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Division"> | Date | string | null
  }

  export type EventAttendeeWhereInput = {
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    id?: UuidFilter<"EventAttendee"> | string
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    eventCheckins?: EventCheckinListRelationFilter
  }

  export type EventAttendeeOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrderInput | SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    badgeAssignedAt?: SortOrderInput | SortOrder
    accessStart?: SortOrderInput | SortOrder
    accessEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    eventCheckins?: EventCheckinOrderByRelationAggregateInput
  }

  export type EventAttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    eventCheckins?: EventCheckinListRelationFilter
  }, "id">

  export type EventAttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrderInput | SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    badgeAssignedAt?: SortOrderInput | SortOrder
    accessStart?: SortOrderInput | SortOrder
    accessEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EventAttendeeCountOrderByAggregateInput
    _max?: EventAttendeeMaxOrderByAggregateInput
    _min?: EventAttendeeMinOrderByAggregateInput
  }

  export type EventAttendeeScalarWhereWithAggregatesInput = {
    AND?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    OR?: EventAttendeeScalarWhereWithAggregatesInput[]
    NOT?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventAttendee"> | string
    eventId?: UuidWithAggregatesFilter<"EventAttendee"> | string
    name?: StringWithAggregatesFilter<"EventAttendee"> | string
    rank?: StringNullableWithAggregatesFilter<"EventAttendee"> | string | null
    organization?: StringWithAggregatesFilter<"EventAttendee"> | string
    role?: StringWithAggregatesFilter<"EventAttendee"> | string
    badgeId?: UuidNullableWithAggregatesFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    status?: StringWithAggregatesFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
  }

  export type EventCheckinWhereInput = {
    AND?: EventCheckinWhereInput | EventCheckinWhereInput[]
    OR?: EventCheckinWhereInput[]
    NOT?: EventCheckinWhereInput | EventCheckinWhereInput[]
    id?: UuidFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
    eventAttendee?: XOR<EventAttendeeScalarRelationFilter, EventAttendeeWhereInput>
  }

  export type EventCheckinOrderByWithRelationInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    eventAttendee?: EventAttendeeOrderByWithRelationInput
  }

  export type EventCheckinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventCheckinWhereInput | EventCheckinWhereInput[]
    OR?: EventCheckinWhereInput[]
    NOT?: EventCheckinWhereInput | EventCheckinWhereInput[]
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
    eventAttendee?: XOR<EventAttendeeScalarRelationFilter, EventAttendeeWhereInput>
  }, "id">

  export type EventCheckinOrderByWithAggregationInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: EventCheckinCountOrderByAggregateInput
    _max?: EventCheckinMaxOrderByAggregateInput
    _min?: EventCheckinMinOrderByAggregateInput
  }

  export type EventCheckinScalarWhereWithAggregatesInput = {
    AND?: EventCheckinScalarWhereWithAggregatesInput | EventCheckinScalarWhereWithAggregatesInput[]
    OR?: EventCheckinScalarWhereWithAggregatesInput[]
    NOT?: EventCheckinScalarWhereWithAggregatesInput | EventCheckinScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidWithAggregatesFilter<"EventCheckin"> | string
    badgeId?: UuidWithAggregatesFilter<"EventCheckin"> | string
    direction?: StringWithAggregatesFilter<"EventCheckin"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EventCheckin"> | Date | string
    kioskId?: StringWithAggregatesFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"EventCheckin"> | Date | string | null
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: UuidFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    code?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    status?: StringFilter<"Event"> | string
    autoExpireBadges?: BoolNullableFilter<"Event"> | boolean | null
    customRoles?: JsonNullableFilter<"Event">
    createdBy?: UuidNullableFilter<"Event"> | string | null
    createdAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventAttendees?: EventAttendeeListRelationFilter
    visitors?: VisitorListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrderInput | SortOrder
    customRoles?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    eventAttendees?: EventAttendeeOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    name?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    status?: StringFilter<"Event"> | string
    autoExpireBadges?: BoolNullableFilter<"Event"> | boolean | null
    customRoles?: JsonNullableFilter<"Event">
    createdBy?: UuidNullableFilter<"Event"> | string | null
    createdAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventAttendees?: EventAttendeeListRelationFilter
    visitors?: VisitorListRelationFilter
  }, "id" | "code">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrderInput | SortOrder
    customRoles?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    code?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    status?: StringWithAggregatesFilter<"Event"> | string
    autoExpireBadges?: BoolNullableWithAggregatesFilter<"Event"> | boolean | null
    customRoles?: JsonNullableWithAggregatesFilter<"Event">
    createdBy?: UuidNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: UuidFilter<"Member"> | string
    serviceNumber?: StringFilter<"Member"> | string
    rankId?: UuidFilter<"Member"> | string
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
    missedCheckoutCount?: IntFilter<"Member"> | number
    lastMissedCheckout?: DateTimeNullableFilter<"Member"> | Date | string | null
    rankRef?: XOR<RankNullableScalarRelationFilter, RankWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    bmqEnrollments?: BmqEnrollmentListRelationFilter
    checkins?: CheckinListRelationFilter
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    visitors?: VisitorListRelationFilter
    memberTags?: MemberTagListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    ddsTransfers?: DdsAssignmentListRelationFilter
    memberTypeRef?: XOR<MemberTypeNullableScalarRelationFilter, MemberTypeWhereInput> | null
    memberStatusRef?: XOR<MemberStatusNullableScalarRelationFilter, MemberStatusWhereInput> | null
    qualifications?: MemberQualificationListRelationFilter
    scheduleAssignments?: ScheduleAssignmentListRelationFilter
    lockupHolding?: LockupStatusListRelationFilter
    lockupSecured?: LockupStatusListRelationFilter
    lockupTransfersFrom?: LockupTransferListRelationFilter
    lockupTransfersTo?: LockupTransferListRelationFilter
    lockupExecutions?: LockupExecutionListRelationFilter
    missedCheckouts?: MissedCheckoutListRelationFilter
    unitEventDutyAssignments?: UnitEventDutyAssignmentListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rankId?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    divisionId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrderInput | SortOrder
    memberStatusId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    mess?: SortOrderInput | SortOrder
    moc?: SortOrderInput | SortOrder
    classDetails?: SortOrderInput | SortOrder
    homePhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    contract_start?: SortOrderInput | SortOrder
    contract_end?: SortOrderInput | SortOrder
    missedCheckoutCount?: SortOrder
    lastMissedCheckout?: SortOrderInput | SortOrder
    rankRef?: RankOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
    bmqEnrollments?: BmqEnrollmentOrderByRelationAggregateInput
    checkins?: CheckinOrderByRelationAggregateInput
    division?: DivisionOrderByWithRelationInput
    visitors?: VisitorOrderByRelationAggregateInput
    memberTags?: MemberTagOrderByRelationAggregateInput
    ddsAssignments?: DdsAssignmentOrderByRelationAggregateInput
    ddsTransfers?: DdsAssignmentOrderByRelationAggregateInput
    memberTypeRef?: MemberTypeOrderByWithRelationInput
    memberStatusRef?: MemberStatusOrderByWithRelationInput
    qualifications?: MemberQualificationOrderByRelationAggregateInput
    scheduleAssignments?: ScheduleAssignmentOrderByRelationAggregateInput
    lockupHolding?: LockupStatusOrderByRelationAggregateInput
    lockupSecured?: LockupStatusOrderByRelationAggregateInput
    lockupTransfersFrom?: LockupTransferOrderByRelationAggregateInput
    lockupTransfersTo?: LockupTransferOrderByRelationAggregateInput
    lockupExecutions?: LockupExecutionOrderByRelationAggregateInput
    missedCheckouts?: MissedCheckoutOrderByRelationAggregateInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceNumber?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    rankId?: UuidFilter<"Member"> | string
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
    missedCheckoutCount?: IntFilter<"Member"> | number
    lastMissedCheckout?: DateTimeNullableFilter<"Member"> | Date | string | null
    rankRef?: XOR<RankNullableScalarRelationFilter, RankWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    bmqEnrollments?: BmqEnrollmentListRelationFilter
    checkins?: CheckinListRelationFilter
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    visitors?: VisitorListRelationFilter
    memberTags?: MemberTagListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    ddsTransfers?: DdsAssignmentListRelationFilter
    memberTypeRef?: XOR<MemberTypeNullableScalarRelationFilter, MemberTypeWhereInput> | null
    memberStatusRef?: XOR<MemberStatusNullableScalarRelationFilter, MemberStatusWhereInput> | null
    qualifications?: MemberQualificationListRelationFilter
    scheduleAssignments?: ScheduleAssignmentListRelationFilter
    lockupHolding?: LockupStatusListRelationFilter
    lockupSecured?: LockupStatusListRelationFilter
    lockupTransfersFrom?: LockupTransferListRelationFilter
    lockupTransfersTo?: LockupTransferListRelationFilter
    lockupExecutions?: LockupExecutionListRelationFilter
    missedCheckouts?: MissedCheckoutListRelationFilter
    unitEventDutyAssignments?: UnitEventDutyAssignmentListRelationFilter
  }, "id" | "serviceNumber">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rankId?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    divisionId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrderInput | SortOrder
    memberStatusId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    mess?: SortOrderInput | SortOrder
    moc?: SortOrderInput | SortOrder
    classDetails?: SortOrderInput | SortOrder
    homePhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    contract_start?: SortOrderInput | SortOrder
    contract_end?: SortOrderInput | SortOrder
    missedCheckoutCount?: SortOrder
    lastMissedCheckout?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Member"> | string
    serviceNumber?: StringWithAggregatesFilter<"Member"> | string
    rankId?: UuidWithAggregatesFilter<"Member"> | string
    rank?: StringWithAggregatesFilter<"Member"> | string
    firstName?: StringWithAggregatesFilter<"Member"> | string
    lastName?: StringWithAggregatesFilter<"Member"> | string
    email?: StringNullableWithAggregatesFilter<"Member"> | string | null
    mobilePhone?: StringNullableWithAggregatesFilter<"Member"> | string | null
    divisionId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    badgeId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    memberType?: StringWithAggregatesFilter<"Member"> | string
    status?: StringWithAggregatesFilter<"Member"> | string
    memberTypeId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    memberStatusId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableWithAggregatesFilter<"Member"> | string | null
    initials?: StringNullableWithAggregatesFilter<"Member"> | string | null
    mess?: StringNullableWithAggregatesFilter<"Member"> | string | null
    moc?: StringNullableWithAggregatesFilter<"Member"> | string | null
    classDetails?: StringNullableWithAggregatesFilter<"Member"> | string | null
    homePhone?: StringNullableWithAggregatesFilter<"Member"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Member"> | string | null
    contract_start?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    missedCheckoutCount?: IntWithAggregatesFilter<"Member"> | number
    lastMissedCheckout?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    displayOrder?: IntFilter<"Tag"> | number
    chipVariant?: StringFilter<"Tag"> | string
    chipColor?: StringFilter<"Tag"> | string
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    memberTags?: MemberTagListRelationFilter
    qualificationTypes?: QualificationTypeListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    memberTags?: MemberTagOrderByRelationAggregateInput
    qualificationTypes?: QualificationTypeOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    description?: StringNullableFilter<"Tag"> | string | null
    displayOrder?: IntFilter<"Tag"> | number
    chipVariant?: StringFilter<"Tag"> | string
    chipColor?: StringFilter<"Tag"> | string
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    memberTags?: MemberTagListRelationFilter
    qualificationTypes?: QualificationTypeListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Tag"> | number
    chipVariant?: StringWithAggregatesFilter<"Tag"> | string
    chipColor?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
  }

  export type MemberTagWhereInput = {
    AND?: MemberTagWhereInput | MemberTagWhereInput[]
    OR?: MemberTagWhereInput[]
    NOT?: MemberTagWhereInput | MemberTagWhereInput[]
    id?: UuidFilter<"MemberTag"> | string
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type MemberTagOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type MemberTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_tagId?: MemberTagMemberIdTagIdCompoundUniqueInput
    AND?: MemberTagWhereInput | MemberTagWhereInput[]
    OR?: MemberTagWhereInput[]
    NOT?: MemberTagWhereInput | MemberTagWhereInput[]
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "memberId_tagId">

  export type MemberTagOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: MemberTagCountOrderByAggregateInput
    _max?: MemberTagMaxOrderByAggregateInput
    _min?: MemberTagMinOrderByAggregateInput
  }

  export type MemberTagScalarWhereWithAggregatesInput = {
    AND?: MemberTagScalarWhereWithAggregatesInput | MemberTagScalarWhereWithAggregatesInput[]
    OR?: MemberTagScalarWhereWithAggregatesInput[]
    NOT?: MemberTagScalarWhereWithAggregatesInput | MemberTagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberTag"> | string
    memberId?: UuidWithAggregatesFilter<"MemberTag"> | string
    tagId?: UuidWithAggregatesFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberTag"> | Date | string | null
  }

  export type SecurityAlertWhereInput = {
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    id?: UuidFilter<"SecurityAlert"> | string
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    acknowledgedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type SecurityAlertOrderByWithRelationInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgeNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    acknowledgedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type SecurityAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    acknowledgedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type SecurityAlertOrderByWithAggregationInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgeNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityAlertCountOrderByAggregateInput
    _max?: SecurityAlertMaxOrderByAggregateInput
    _min?: SecurityAlertMinOrderByAggregateInput
  }

  export type SecurityAlertScalarWhereWithAggregatesInput = {
    AND?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    OR?: SecurityAlertScalarWhereWithAggregatesInput[]
    NOT?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SecurityAlert"> | string
    alertType?: StringWithAggregatesFilter<"SecurityAlert"> | string
    severity?: StringWithAggregatesFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    kioskId?: StringWithAggregatesFilter<"SecurityAlert"> | string
    message?: StringWithAggregatesFilter<"SecurityAlert"> | string
    details?: JsonNullableWithAggregatesFilter<"SecurityAlert">
    status?: StringWithAggregatesFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityAlert"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: UuidFilter<"Visitor"> | string
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    hostMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    visitTypeRef?: XOR<VisitTypeNullableScalarRelationFilter, VisitTypeWhereInput> | null
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrderInput | SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitReason?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    hostMemberId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    temporaryBadgeId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    checkInMethod?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrderInput | SortOrder
    admin_users?: AdminUserOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    hostMember?: MemberOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
    visitTypeRef?: VisitTypeOrderByWithRelationInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    hostMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    visitTypeRef?: XOR<VisitTypeNullableScalarRelationFilter, VisitTypeWhereInput> | null
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrderInput | SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitReason?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    hostMemberId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    temporaryBadgeId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    checkInMethod?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrderInput | SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Visitor"> | string
    name?: StringWithAggregatesFilter<"Visitor"> | string
    organization?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    visitType?: StringWithAggregatesFilter<"Visitor"> | string
    visitTypeId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    visitReason?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    eventId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    checkInTime?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    kioskId?: StringWithAggregatesFilter<"Visitor"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
  }

  export type BmqCourseWhereInput = {
    AND?: BmqCourseWhereInput | BmqCourseWhereInput[]
    OR?: BmqCourseWhereInput[]
    NOT?: BmqCourseWhereInput | BmqCourseWhereInput[]
    id?: UuidFilter<"BmqCourse"> | string
    name?: StringFilter<"BmqCourse"> | string
    startDate?: DateTimeFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeFilter<"BmqCourse"> | Date | string
    isActive?: BoolFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
    bmqEnrollments?: BmqEnrollmentListRelationFilter
  }

  export type BmqCourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
    bmqEnrollments?: BmqEnrollmentOrderByRelationAggregateInput
  }

  export type BmqCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BmqCourseWhereInput | BmqCourseWhereInput[]
    OR?: BmqCourseWhereInput[]
    NOT?: BmqCourseWhereInput | BmqCourseWhereInput[]
    name?: StringFilter<"BmqCourse"> | string
    startDate?: DateTimeFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeFilter<"BmqCourse"> | Date | string
    isActive?: BoolFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
    bmqEnrollments?: BmqEnrollmentListRelationFilter
  }, "id">

  export type BmqCourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
    _count?: BmqCourseCountOrderByAggregateInput
    _max?: BmqCourseMaxOrderByAggregateInput
    _min?: BmqCourseMinOrderByAggregateInput
  }

  export type BmqCourseScalarWhereWithAggregatesInput = {
    AND?: BmqCourseScalarWhereWithAggregatesInput | BmqCourseScalarWhereWithAggregatesInput[]
    OR?: BmqCourseScalarWhereWithAggregatesInput[]
    NOT?: BmqCourseScalarWhereWithAggregatesInput | BmqCourseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BmqCourse"> | string
    name?: StringWithAggregatesFilter<"BmqCourse"> | string
    startDate?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    isActive?: BoolWithAggregatesFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
  }

  export type BmqEnrollmentWhereInput = {
    AND?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    OR?: BmqEnrollmentWhereInput[]
    NOT?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    id?: UuidFilter<"BmqEnrollment"> | string
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
    bmqCourse?: XOR<BmqCourseScalarRelationFilter, BmqCourseWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type BmqEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    bmqCourse?: BmqCourseOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type BmqEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_bmqCourseId?: BmqEnrollmentMemberIdBmqCourseIdCompoundUniqueInput
    AND?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    OR?: BmqEnrollmentWhereInput[]
    NOT?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
    bmqCourse?: XOR<BmqCourseScalarRelationFilter, BmqCourseWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId_bmqCourseId">

  export type BmqEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: BmqEnrollmentCountOrderByAggregateInput
    _max?: BmqEnrollmentMaxOrderByAggregateInput
    _min?: BmqEnrollmentMinOrderByAggregateInput
  }

  export type BmqEnrollmentScalarWhereWithAggregatesInput = {
    AND?: BmqEnrollmentScalarWhereWithAggregatesInput | BmqEnrollmentScalarWhereWithAggregatesInput[]
    OR?: BmqEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: BmqEnrollmentScalarWhereWithAggregatesInput | BmqEnrollmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    memberId?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"BmqEnrollment"> | Date | string | null
    status?: StringWithAggregatesFilter<"BmqEnrollment"> | string
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    name?: StringFilter<"migrations"> | string
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }, "id" | "name">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    name?: StringWithAggregatesFilter<"migrations"> | string
    applied_at?: DateTimeNullableWithAggregatesFilter<"migrations"> | Date | string | null
  }

  export type report_audit_logWhereInput = {
    AND?: report_audit_logWhereInput | report_audit_logWhereInput[]
    OR?: report_audit_logWhereInput[]
    NOT?: report_audit_logWhereInput | report_audit_logWhereInput[]
    id?: UuidFilter<"report_audit_log"> | string
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type report_audit_logOrderByWithRelationInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrderInput | SortOrder
    is_scheduled?: SortOrderInput | SortOrder
    scheduled_report_id?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    file_size_bytes?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    admin_users?: AdminUserOrderByWithRelationInput
  }

  export type report_audit_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: report_audit_logWhereInput | report_audit_logWhereInput[]
    OR?: report_audit_logWhereInput[]
    NOT?: report_audit_logWhereInput | report_audit_logWhereInput[]
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type report_audit_logOrderByWithAggregationInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrderInput | SortOrder
    is_scheduled?: SortOrderInput | SortOrder
    scheduled_report_id?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    file_size_bytes?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    _count?: report_audit_logCountOrderByAggregateInput
    _avg?: report_audit_logAvgOrderByAggregateInput
    _max?: report_audit_logMaxOrderByAggregateInput
    _min?: report_audit_logMinOrderByAggregateInput
    _sum?: report_audit_logSumOrderByAggregateInput
  }

  export type report_audit_logScalarWhereWithAggregatesInput = {
    AND?: report_audit_logScalarWhereWithAggregatesInput | report_audit_logScalarWhereWithAggregatesInput[]
    OR?: report_audit_logScalarWhereWithAggregatesInput[]
    NOT?: report_audit_logScalarWhereWithAggregatesInput | report_audit_logScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"report_audit_log"> | string
    report_type?: StringWithAggregatesFilter<"report_audit_log"> | string
    report_config?: JsonWithAggregatesFilter<"report_audit_log">
    generated_by?: UuidNullableWithAggregatesFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableWithAggregatesFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableWithAggregatesFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableWithAggregatesFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableWithAggregatesFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableWithAggregatesFilter<"report_audit_log"> | number | null
  }

  export type ReportSettingWhereInput = {
    AND?: ReportSettingWhereInput | ReportSettingWhereInput[]
    OR?: ReportSettingWhereInput[]
    NOT?: ReportSettingWhereInput | ReportSettingWhereInput[]
    key?: StringFilter<"ReportSetting"> | string
    value?: JsonFilter<"ReportSetting">
    updatedAt?: DateTimeFilter<"ReportSetting"> | Date | string
  }

  export type ReportSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: ReportSettingWhereInput | ReportSettingWhereInput[]
    OR?: ReportSettingWhereInput[]
    NOT?: ReportSettingWhereInput | ReportSettingWhereInput[]
    value?: JsonFilter<"ReportSetting">
    updatedAt?: DateTimeFilter<"ReportSetting"> | Date | string
  }, "key">

  export type ReportSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportSettingCountOrderByAggregateInput
    _max?: ReportSettingMaxOrderByAggregateInput
    _min?: ReportSettingMinOrderByAggregateInput
  }

  export type ReportSettingScalarWhereWithAggregatesInput = {
    AND?: ReportSettingScalarWhereWithAggregatesInput | ReportSettingScalarWhereWithAggregatesInput[]
    OR?: ReportSettingScalarWhereWithAggregatesInput[]
    NOT?: ReportSettingScalarWhereWithAggregatesInput | ReportSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"ReportSetting"> | string
    value?: JsonWithAggregatesFilter<"ReportSetting">
    updatedAt?: DateTimeWithAggregatesFilter<"ReportSetting"> | Date | string
  }

  export type TrainingYearWhereInput = {
    AND?: TrainingYearWhereInput | TrainingYearWhereInput[]
    OR?: TrainingYearWhereInput[]
    NOT?: TrainingYearWhereInput | TrainingYearWhereInput[]
    id?: UuidFilter<"TrainingYear"> | string
    name?: StringFilter<"TrainingYear"> | string
    startDate?: DateTimeFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonFilter<"TrainingYear">
    dayExceptions?: JsonFilter<"TrainingYear">
    isCurrent?: BoolFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingYear"> | Date | string
  }

  export type TrainingYearOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingYearWhereInput | TrainingYearWhereInput[]
    OR?: TrainingYearWhereInput[]
    NOT?: TrainingYearWhereInput | TrainingYearWhereInput[]
    name?: StringFilter<"TrainingYear"> | string
    startDate?: DateTimeFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonFilter<"TrainingYear">
    dayExceptions?: JsonFilter<"TrainingYear">
    isCurrent?: BoolFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingYear"> | Date | string
  }, "id">

  export type TrainingYearOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingYearCountOrderByAggregateInput
    _max?: TrainingYearMaxOrderByAggregateInput
    _min?: TrainingYearMinOrderByAggregateInput
  }

  export type TrainingYearScalarWhereWithAggregatesInput = {
    AND?: TrainingYearScalarWhereWithAggregatesInput | TrainingYearScalarWhereWithAggregatesInput[]
    OR?: TrainingYearScalarWhereWithAggregatesInput[]
    NOT?: TrainingYearScalarWhereWithAggregatesInput | TrainingYearScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TrainingYear"> | string
    name?: StringWithAggregatesFilter<"TrainingYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonWithAggregatesFilter<"TrainingYear">
    dayExceptions?: JsonWithAggregatesFilter<"TrainingYear">
    isCurrent?: BoolWithAggregatesFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
  }

  export type DdsAssignmentWhereInput = {
    AND?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    OR?: DdsAssignmentWhereInput[]
    NOT?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    id?: UuidFilter<"DdsAssignment"> | string
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    transferredToMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    assignedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type DdsAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    transferredTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
    transferredToMember?: MemberOrderByWithRelationInput
    assignedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type DdsAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    OR?: DdsAssignmentWhereInput[]
    NOT?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    transferredToMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    assignedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type DdsAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    transferredTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DdsAssignmentCountOrderByAggregateInput
    _max?: DdsAssignmentMaxOrderByAggregateInput
    _min?: DdsAssignmentMinOrderByAggregateInput
  }

  export type DdsAssignmentScalarWhereWithAggregatesInput = {
    AND?: DdsAssignmentScalarWhereWithAggregatesInput | DdsAssignmentScalarWhereWithAggregatesInput[]
    OR?: DdsAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DdsAssignmentScalarWhereWithAggregatesInput | DdsAssignmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DdsAssignment"> | string
    memberId?: UuidWithAggregatesFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    status?: StringWithAggregatesFilter<"DdsAssignment"> | string
    notes?: StringNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
  }

  export type ResponsibilityAuditLogWhereInput = {
    AND?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    OR?: ResponsibilityAuditLogWhereInput[]
    NOT?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    id?: UuidFilter<"ResponsibilityAuditLog"> | string
    memberId?: UuidFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringFilter<"ResponsibilityAuditLog"> | string
    action?: StringFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableFilter<"ResponsibilityAuditLog"> | string | null
  }

  export type ResponsibilityAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrderInput | SortOrder
    toMemberId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type ResponsibilityAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    OR?: ResponsibilityAuditLogWhereInput[]
    NOT?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    memberId?: UuidFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringFilter<"ResponsibilityAuditLog"> | string
    action?: StringFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableFilter<"ResponsibilityAuditLog"> | string | null
  }, "id">

  export type ResponsibilityAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrderInput | SortOrder
    toMemberId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ResponsibilityAuditLogCountOrderByAggregateInput
    _max?: ResponsibilityAuditLogMaxOrderByAggregateInput
    _min?: ResponsibilityAuditLogMinOrderByAggregateInput
  }

  export type ResponsibilityAuditLogScalarWhereWithAggregatesInput = {
    AND?: ResponsibilityAuditLogScalarWhereWithAggregatesInput | ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    OR?: ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    NOT?: ResponsibilityAuditLogScalarWhereWithAggregatesInput | ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    memberId?: UuidWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    action?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
  }

  export type MemberStatusWhereInput = {
    AND?: MemberStatusWhereInput | MemberStatusWhereInput[]
    OR?: MemberStatusWhereInput[]
    NOT?: MemberStatusWhereInput | MemberStatusWhereInput[]
    id?: UuidFilter<"MemberStatus"> | string
    code?: StringFilter<"MemberStatus"> | string
    name?: StringFilter<"MemberStatus"> | string
    description?: StringNullableFilter<"MemberStatus"> | string | null
    chipVariant?: StringFilter<"MemberStatus"> | string
    chipColor?: StringFilter<"MemberStatus"> | string
    createdAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type MemberStatusOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type MemberStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: MemberStatusWhereInput | MemberStatusWhereInput[]
    OR?: MemberStatusWhereInput[]
    NOT?: MemberStatusWhereInput | MemberStatusWhereInput[]
    name?: StringFilter<"MemberStatus"> | string
    description?: StringNullableFilter<"MemberStatus"> | string | null
    chipVariant?: StringFilter<"MemberStatus"> | string
    chipColor?: StringFilter<"MemberStatus"> | string
    createdAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type MemberStatusOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberStatusCountOrderByAggregateInput
    _max?: MemberStatusMaxOrderByAggregateInput
    _min?: MemberStatusMinOrderByAggregateInput
  }

  export type MemberStatusScalarWhereWithAggregatesInput = {
    AND?: MemberStatusScalarWhereWithAggregatesInput | MemberStatusScalarWhereWithAggregatesInput[]
    OR?: MemberStatusScalarWhereWithAggregatesInput[]
    NOT?: MemberStatusScalarWhereWithAggregatesInput | MemberStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberStatus"> | string
    code?: StringWithAggregatesFilter<"MemberStatus"> | string
    name?: StringWithAggregatesFilter<"MemberStatus"> | string
    description?: StringNullableWithAggregatesFilter<"MemberStatus"> | string | null
    chipVariant?: StringWithAggregatesFilter<"MemberStatus"> | string
    chipColor?: StringWithAggregatesFilter<"MemberStatus"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberStatus"> | Date | string | null
  }

  export type MemberTypeWhereInput = {
    AND?: MemberTypeWhereInput | MemberTypeWhereInput[]
    OR?: MemberTypeWhereInput[]
    NOT?: MemberTypeWhereInput | MemberTypeWhereInput[]
    id?: UuidFilter<"MemberType"> | string
    code?: StringFilter<"MemberType"> | string
    name?: StringFilter<"MemberType"> | string
    description?: StringNullableFilter<"MemberType"> | string | null
    chipVariant?: StringFilter<"MemberType"> | string
    chipColor?: StringFilter<"MemberType"> | string
    createdAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type MemberTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type MemberTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: MemberTypeWhereInput | MemberTypeWhereInput[]
    OR?: MemberTypeWhereInput[]
    NOT?: MemberTypeWhereInput | MemberTypeWhereInput[]
    name?: StringFilter<"MemberType"> | string
    description?: StringNullableFilter<"MemberType"> | string | null
    chipVariant?: StringFilter<"MemberType"> | string
    chipColor?: StringFilter<"MemberType"> | string
    createdAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type MemberTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberTypeCountOrderByAggregateInput
    _max?: MemberTypeMaxOrderByAggregateInput
    _min?: MemberTypeMinOrderByAggregateInput
  }

  export type MemberTypeScalarWhereWithAggregatesInput = {
    AND?: MemberTypeScalarWhereWithAggregatesInput | MemberTypeScalarWhereWithAggregatesInput[]
    OR?: MemberTypeScalarWhereWithAggregatesInput[]
    NOT?: MemberTypeScalarWhereWithAggregatesInput | MemberTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberType"> | string
    code?: StringWithAggregatesFilter<"MemberType"> | string
    name?: StringWithAggregatesFilter<"MemberType"> | string
    description?: StringNullableWithAggregatesFilter<"MemberType"> | string | null
    chipVariant?: StringWithAggregatesFilter<"MemberType"> | string
    chipColor?: StringWithAggregatesFilter<"MemberType"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberType"> | Date | string | null
  }

  export type VisitTypeWhereInput = {
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    id?: UuidFilter<"VisitType"> | string
    code?: StringFilter<"VisitType"> | string
    name?: StringFilter<"VisitType"> | string
    description?: StringNullableFilter<"VisitType"> | string | null
    chipVariant?: StringFilter<"VisitType"> | string
    chipColor?: StringFilter<"VisitType"> | string
    createdAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    visitors?: VisitorListRelationFilter
  }

  export type VisitTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    visitors?: VisitorOrderByRelationAggregateInput
  }

  export type VisitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    name?: StringFilter<"VisitType"> | string
    description?: StringNullableFilter<"VisitType"> | string | null
    chipVariant?: StringFilter<"VisitType"> | string
    chipColor?: StringFilter<"VisitType"> | string
    createdAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    visitors?: VisitorListRelationFilter
  }, "id" | "code">

  export type VisitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VisitTypeCountOrderByAggregateInput
    _max?: VisitTypeMaxOrderByAggregateInput
    _min?: VisitTypeMinOrderByAggregateInput
  }

  export type VisitTypeScalarWhereWithAggregatesInput = {
    AND?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    OR?: VisitTypeScalarWhereWithAggregatesInput[]
    NOT?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VisitType"> | string
    code?: StringWithAggregatesFilter<"VisitType"> | string
    name?: StringWithAggregatesFilter<"VisitType"> | string
    description?: StringNullableWithAggregatesFilter<"VisitType"> | string | null
    chipVariant?: StringWithAggregatesFilter<"VisitType"> | string
    chipColor?: StringWithAggregatesFilter<"VisitType"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"VisitType"> | Date | string | null
  }

  export type BadgeStatusWhereInput = {
    AND?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    OR?: BadgeStatusWhereInput[]
    NOT?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    id?: UuidFilter<"BadgeStatus"> | string
    code?: StringFilter<"BadgeStatus"> | string
    name?: StringFilter<"BadgeStatus"> | string
    description?: StringNullableFilter<"BadgeStatus"> | string | null
    chipVariant?: StringFilter<"BadgeStatus"> | string
    chipColor?: StringFilter<"BadgeStatus"> | string
    createdAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    badges?: BadgeListRelationFilter
  }

  export type BadgeStatusOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badges?: BadgeOrderByRelationAggregateInput
  }

  export type BadgeStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    OR?: BadgeStatusWhereInput[]
    NOT?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    name?: StringFilter<"BadgeStatus"> | string
    description?: StringNullableFilter<"BadgeStatus"> | string | null
    chipVariant?: StringFilter<"BadgeStatus"> | string
    chipColor?: StringFilter<"BadgeStatus"> | string
    createdAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    badges?: BadgeListRelationFilter
  }, "id" | "code">

  export type BadgeStatusOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BadgeStatusCountOrderByAggregateInput
    _max?: BadgeStatusMaxOrderByAggregateInput
    _min?: BadgeStatusMinOrderByAggregateInput
  }

  export type BadgeStatusScalarWhereWithAggregatesInput = {
    AND?: BadgeStatusScalarWhereWithAggregatesInput | BadgeStatusScalarWhereWithAggregatesInput[]
    OR?: BadgeStatusScalarWhereWithAggregatesInput[]
    NOT?: BadgeStatusScalarWhereWithAggregatesInput | BadgeStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BadgeStatus"> | string
    code?: StringWithAggregatesFilter<"BadgeStatus"> | string
    name?: StringWithAggregatesFilter<"BadgeStatus"> | string
    description?: StringNullableWithAggregatesFilter<"BadgeStatus"> | string | null
    chipVariant?: StringWithAggregatesFilter<"BadgeStatus"> | string
    chipColor?: StringWithAggregatesFilter<"BadgeStatus"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BadgeStatus"> | Date | string | null
  }

  export type ListItemWhereInput = {
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    id?: UuidFilter<"ListItem"> | string
    listType?: StringFilter<"ListItem"> | string
    code?: StringFilter<"ListItem"> | string
    name?: StringFilter<"ListItem"> | string
    displayOrder?: IntFilter<"ListItem"> | number
    description?: StringNullableFilter<"ListItem"> | string | null
    isSystem?: BoolFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
  }

  export type ListItemOrderByWithRelationInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type ListItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listType_code?: ListItemListTypeCodeCompoundUniqueInput
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    listType?: StringFilter<"ListItem"> | string
    code?: StringFilter<"ListItem"> | string
    name?: StringFilter<"ListItem"> | string
    displayOrder?: IntFilter<"ListItem"> | number
    description?: StringNullableFilter<"ListItem"> | string | null
    isSystem?: BoolFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
  }, "id" | "listType_code">

  export type ListItemOrderByWithAggregationInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ListItemCountOrderByAggregateInput
    _avg?: ListItemAvgOrderByAggregateInput
    _max?: ListItemMaxOrderByAggregateInput
    _min?: ListItemMinOrderByAggregateInput
    _sum?: ListItemSumOrderByAggregateInput
  }

  export type ListItemScalarWhereWithAggregatesInput = {
    AND?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    OR?: ListItemScalarWhereWithAggregatesInput[]
    NOT?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ListItem"> | string
    listType?: StringWithAggregatesFilter<"ListItem"> | string
    code?: StringWithAggregatesFilter<"ListItem"> | string
    name?: StringWithAggregatesFilter<"ListItem"> | string
    displayOrder?: IntWithAggregatesFilter<"ListItem"> | number
    description?: StringNullableWithAggregatesFilter<"ListItem"> | string | null
    isSystem?: BoolWithAggregatesFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ListItem"> | Date | string | null
  }

  export type RankWhereInput = {
    AND?: RankWhereInput | RankWhereInput[]
    OR?: RankWhereInput[]
    NOT?: RankWhereInput | RankWhereInput[]
    id?: UuidFilter<"Rank"> | string
    code?: StringFilter<"Rank"> | string
    name?: StringFilter<"Rank"> | string
    branch?: StringFilter<"Rank"> | string
    category?: StringFilter<"Rank"> | string
    displayOrder?: IntFilter<"Rank"> | number
    isActive?: BoolFilter<"Rank"> | boolean
    replacedBy?: UuidNullableFilter<"Rank"> | string | null
    createdAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
    members?: MemberListRelationFilter
    replacedByRank?: XOR<RankNullableScalarRelationFilter, RankWhereInput> | null
    replacesRanks?: RankListRelationFilter
  }

  export type RankOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    replacedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
    replacedByRank?: RankOrderByWithRelationInput
    replacesRanks?: RankOrderByRelationAggregateInput
  }

  export type RankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RankWhereInput | RankWhereInput[]
    OR?: RankWhereInput[]
    NOT?: RankWhereInput | RankWhereInput[]
    name?: StringFilter<"Rank"> | string
    branch?: StringFilter<"Rank"> | string
    category?: StringFilter<"Rank"> | string
    displayOrder?: IntFilter<"Rank"> | number
    isActive?: BoolFilter<"Rank"> | boolean
    replacedBy?: UuidNullableFilter<"Rank"> | string | null
    createdAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
    members?: MemberListRelationFilter
    replacedByRank?: XOR<RankNullableScalarRelationFilter, RankWhereInput> | null
    replacesRanks?: RankListRelationFilter
  }, "id" | "code">

  export type RankOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    replacedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RankCountOrderByAggregateInput
    _avg?: RankAvgOrderByAggregateInput
    _max?: RankMaxOrderByAggregateInput
    _min?: RankMinOrderByAggregateInput
    _sum?: RankSumOrderByAggregateInput
  }

  export type RankScalarWhereWithAggregatesInput = {
    AND?: RankScalarWhereWithAggregatesInput | RankScalarWhereWithAggregatesInput[]
    OR?: RankScalarWhereWithAggregatesInput[]
    NOT?: RankScalarWhereWithAggregatesInput | RankScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Rank"> | string
    code?: StringWithAggregatesFilter<"Rank"> | string
    name?: StringWithAggregatesFilter<"Rank"> | string
    branch?: StringWithAggregatesFilter<"Rank"> | string
    category?: StringWithAggregatesFilter<"Rank"> | string
    displayOrder?: IntWithAggregatesFilter<"Rank"> | number
    isActive?: BoolWithAggregatesFilter<"Rank"> | boolean
    replacedBy?: UuidNullableWithAggregatesFilter<"Rank"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Rank"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Rank"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    badgeId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    badgeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }, "id" | "email" | "badgeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    badgeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: UuidFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    userId?: UuidWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Account"> | string
    userId?: UuidWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: UuidFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_value?: VerificationIdentifierValueCompoundUniqueInput
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "identifier_value">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: UuidFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: JsonFilter<"Setting">
    category?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: JsonFilter<"Setting">
    category?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: JsonWithAggregatesFilter<"Setting">
    category?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type AlertConfigWhereInput = {
    AND?: AlertConfigWhereInput | AlertConfigWhereInput[]
    OR?: AlertConfigWhereInput[]
    NOT?: AlertConfigWhereInput | AlertConfigWhereInput[]
    key?: StringFilter<"AlertConfig"> | string
    config?: JsonFilter<"AlertConfig">
    updatedAt?: DateTimeFilter<"AlertConfig"> | Date | string
  }

  export type AlertConfigOrderByWithRelationInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: AlertConfigWhereInput | AlertConfigWhereInput[]
    OR?: AlertConfigWhereInput[]
    NOT?: AlertConfigWhereInput | AlertConfigWhereInput[]
    config?: JsonFilter<"AlertConfig">
    updatedAt?: DateTimeFilter<"AlertConfig"> | Date | string
  }, "key">

  export type AlertConfigOrderByWithAggregationInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertConfigCountOrderByAggregateInput
    _max?: AlertConfigMaxOrderByAggregateInput
    _min?: AlertConfigMinOrderByAggregateInput
  }

  export type AlertConfigScalarWhereWithAggregatesInput = {
    AND?: AlertConfigScalarWhereWithAggregatesInput | AlertConfigScalarWhereWithAggregatesInput[]
    OR?: AlertConfigScalarWhereWithAggregatesInput[]
    NOT?: AlertConfigScalarWhereWithAggregatesInput | AlertConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"AlertConfig"> | string
    config?: JsonWithAggregatesFilter<"AlertConfig">
    updatedAt?: DateTimeWithAggregatesFilter<"AlertConfig"> | Date | string
  }

  export type StatHolidayWhereInput = {
    AND?: StatHolidayWhereInput | StatHolidayWhereInput[]
    OR?: StatHolidayWhereInput[]
    NOT?: StatHolidayWhereInput | StatHolidayWhereInput[]
    id?: UuidFilter<"StatHoliday"> | string
    date?: DateTimeFilter<"StatHoliday"> | Date | string
    name?: StringFilter<"StatHoliday"> | string
    province?: StringNullableFilter<"StatHoliday"> | string | null
    isActive?: BoolFilter<"StatHoliday"> | boolean
    createdAt?: DateTimeFilter<"StatHoliday"> | Date | string
    updatedAt?: DateTimeFilter<"StatHoliday"> | Date | string
  }

  export type StatHolidayOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    province?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatHolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: StatHolidayWhereInput | StatHolidayWhereInput[]
    OR?: StatHolidayWhereInput[]
    NOT?: StatHolidayWhereInput | StatHolidayWhereInput[]
    name?: StringFilter<"StatHoliday"> | string
    province?: StringNullableFilter<"StatHoliday"> | string | null
    isActive?: BoolFilter<"StatHoliday"> | boolean
    createdAt?: DateTimeFilter<"StatHoliday"> | Date | string
    updatedAt?: DateTimeFilter<"StatHoliday"> | Date | string
  }, "id" | "date">

  export type StatHolidayOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    province?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatHolidayCountOrderByAggregateInput
    _max?: StatHolidayMaxOrderByAggregateInput
    _min?: StatHolidayMinOrderByAggregateInput
  }

  export type StatHolidayScalarWhereWithAggregatesInput = {
    AND?: StatHolidayScalarWhereWithAggregatesInput | StatHolidayScalarWhereWithAggregatesInput[]
    OR?: StatHolidayScalarWhereWithAggregatesInput[]
    NOT?: StatHolidayScalarWhereWithAggregatesInput | StatHolidayScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StatHoliday"> | string
    date?: DateTimeWithAggregatesFilter<"StatHoliday"> | Date | string
    name?: StringWithAggregatesFilter<"StatHoliday"> | string
    province?: StringNullableWithAggregatesFilter<"StatHoliday"> | string | null
    isActive?: BoolWithAggregatesFilter<"StatHoliday"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StatHoliday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatHoliday"> | Date | string
  }

  export type QualificationTypeWhereInput = {
    AND?: QualificationTypeWhereInput | QualificationTypeWhereInput[]
    OR?: QualificationTypeWhereInput[]
    NOT?: QualificationTypeWhereInput | QualificationTypeWhereInput[]
    id?: UuidFilter<"QualificationType"> | string
    code?: StringFilter<"QualificationType"> | string
    name?: StringFilter<"QualificationType"> | string
    description?: StringNullableFilter<"QualificationType"> | string | null
    canReceiveLockup?: BoolFilter<"QualificationType"> | boolean
    displayOrder?: IntFilter<"QualificationType"> | number
    tagId?: UuidNullableFilter<"QualificationType"> | string | null
    createdAt?: DateTimeFilter<"QualificationType"> | Date | string
    updatedAt?: DateTimeFilter<"QualificationType"> | Date | string
    memberQualifications?: MemberQualificationListRelationFilter
    tag?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
  }

  export type QualificationTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    canReceiveLockup?: SortOrder
    displayOrder?: SortOrder
    tagId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberQualifications?: MemberQualificationOrderByRelationAggregateInput
    tag?: TagOrderByWithRelationInput
  }

  export type QualificationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: QualificationTypeWhereInput | QualificationTypeWhereInput[]
    OR?: QualificationTypeWhereInput[]
    NOT?: QualificationTypeWhereInput | QualificationTypeWhereInput[]
    name?: StringFilter<"QualificationType"> | string
    description?: StringNullableFilter<"QualificationType"> | string | null
    canReceiveLockup?: BoolFilter<"QualificationType"> | boolean
    displayOrder?: IntFilter<"QualificationType"> | number
    tagId?: UuidNullableFilter<"QualificationType"> | string | null
    createdAt?: DateTimeFilter<"QualificationType"> | Date | string
    updatedAt?: DateTimeFilter<"QualificationType"> | Date | string
    memberQualifications?: MemberQualificationListRelationFilter
    tag?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
  }, "id" | "code">

  export type QualificationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    canReceiveLockup?: SortOrder
    displayOrder?: SortOrder
    tagId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QualificationTypeCountOrderByAggregateInput
    _avg?: QualificationTypeAvgOrderByAggregateInput
    _max?: QualificationTypeMaxOrderByAggregateInput
    _min?: QualificationTypeMinOrderByAggregateInput
    _sum?: QualificationTypeSumOrderByAggregateInput
  }

  export type QualificationTypeScalarWhereWithAggregatesInput = {
    AND?: QualificationTypeScalarWhereWithAggregatesInput | QualificationTypeScalarWhereWithAggregatesInput[]
    OR?: QualificationTypeScalarWhereWithAggregatesInput[]
    NOT?: QualificationTypeScalarWhereWithAggregatesInput | QualificationTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QualificationType"> | string
    code?: StringWithAggregatesFilter<"QualificationType"> | string
    name?: StringWithAggregatesFilter<"QualificationType"> | string
    description?: StringNullableWithAggregatesFilter<"QualificationType"> | string | null
    canReceiveLockup?: BoolWithAggregatesFilter<"QualificationType"> | boolean
    displayOrder?: IntWithAggregatesFilter<"QualificationType"> | number
    tagId?: UuidNullableWithAggregatesFilter<"QualificationType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QualificationType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QualificationType"> | Date | string
  }

  export type MemberQualificationWhereInput = {
    AND?: MemberQualificationWhereInput | MemberQualificationWhereInput[]
    OR?: MemberQualificationWhereInput[]
    NOT?: MemberQualificationWhereInput | MemberQualificationWhereInput[]
    id?: UuidFilter<"MemberQualification"> | string
    memberId?: UuidFilter<"MemberQualification"> | string
    qualificationTypeId?: UuidFilter<"MemberQualification"> | string
    status?: StringFilter<"MemberQualification"> | string
    grantedAt?: DateTimeFilter<"MemberQualification"> | Date | string
    grantedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    expiresAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    revokeReason?: StringNullableFilter<"MemberQualification"> | string | null
    notes?: StringNullableFilter<"MemberQualification"> | string | null
    createdAt?: DateTimeFilter<"MemberQualification"> | Date | string
    updatedAt?: DateTimeFilter<"MemberQualification"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    qualificationType?: XOR<QualificationTypeScalarRelationFilter, QualificationTypeWhereInput>
    grantedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    revokedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type MemberQualificationOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    qualificationTypeId?: SortOrder
    status?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokeReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
    qualificationType?: QualificationTypeOrderByWithRelationInput
    grantedByAdmin?: AdminUserOrderByWithRelationInput
    revokedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type MemberQualificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_qualificationTypeId?: MemberQualificationMemberIdQualificationTypeIdCompoundUniqueInput
    AND?: MemberQualificationWhereInput | MemberQualificationWhereInput[]
    OR?: MemberQualificationWhereInput[]
    NOT?: MemberQualificationWhereInput | MemberQualificationWhereInput[]
    memberId?: UuidFilter<"MemberQualification"> | string
    qualificationTypeId?: UuidFilter<"MemberQualification"> | string
    status?: StringFilter<"MemberQualification"> | string
    grantedAt?: DateTimeFilter<"MemberQualification"> | Date | string
    grantedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    expiresAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    revokeReason?: StringNullableFilter<"MemberQualification"> | string | null
    notes?: StringNullableFilter<"MemberQualification"> | string | null
    createdAt?: DateTimeFilter<"MemberQualification"> | Date | string
    updatedAt?: DateTimeFilter<"MemberQualification"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    qualificationType?: XOR<QualificationTypeScalarRelationFilter, QualificationTypeWhereInput>
    grantedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    revokedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id" | "memberId_qualificationTypeId">

  export type MemberQualificationOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    qualificationTypeId?: SortOrder
    status?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokeReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberQualificationCountOrderByAggregateInput
    _max?: MemberQualificationMaxOrderByAggregateInput
    _min?: MemberQualificationMinOrderByAggregateInput
  }

  export type MemberQualificationScalarWhereWithAggregatesInput = {
    AND?: MemberQualificationScalarWhereWithAggregatesInput | MemberQualificationScalarWhereWithAggregatesInput[]
    OR?: MemberQualificationScalarWhereWithAggregatesInput[]
    NOT?: MemberQualificationScalarWhereWithAggregatesInput | MemberQualificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberQualification"> | string
    memberId?: UuidWithAggregatesFilter<"MemberQualification"> | string
    qualificationTypeId?: UuidWithAggregatesFilter<"MemberQualification"> | string
    status?: StringWithAggregatesFilter<"MemberQualification"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"MemberQualification"> | Date | string
    grantedBy?: UuidNullableWithAggregatesFilter<"MemberQualification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"MemberQualification"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"MemberQualification"> | Date | string | null
    revokedBy?: UuidNullableWithAggregatesFilter<"MemberQualification"> | string | null
    revokeReason?: StringNullableWithAggregatesFilter<"MemberQualification"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MemberQualification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MemberQualification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberQualification"> | Date | string
  }

  export type DutyRoleWhereInput = {
    AND?: DutyRoleWhereInput | DutyRoleWhereInput[]
    OR?: DutyRoleWhereInput[]
    NOT?: DutyRoleWhereInput | DutyRoleWhereInput[]
    id?: UuidFilter<"DutyRole"> | string
    code?: StringFilter<"DutyRole"> | string
    name?: StringFilter<"DutyRole"> | string
    description?: StringNullableFilter<"DutyRole"> | string | null
    roleType?: StringFilter<"DutyRole"> | string
    scheduleType?: StringFilter<"DutyRole"> | string
    activeDays?: IntNullableListFilter<"DutyRole">
    displayOrder?: IntFilter<"DutyRole"> | number
    createdAt?: DateTimeFilter<"DutyRole"> | Date | string
    updatedAt?: DateTimeFilter<"DutyRole"> | Date | string
    positions?: DutyPositionListRelationFilter
    schedules?: WeeklyScheduleListRelationFilter
  }

  export type DutyRoleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    roleType?: SortOrder
    scheduleType?: SortOrder
    activeDays?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positions?: DutyPositionOrderByRelationAggregateInput
    schedules?: WeeklyScheduleOrderByRelationAggregateInput
  }

  export type DutyRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DutyRoleWhereInput | DutyRoleWhereInput[]
    OR?: DutyRoleWhereInput[]
    NOT?: DutyRoleWhereInput | DutyRoleWhereInput[]
    name?: StringFilter<"DutyRole"> | string
    description?: StringNullableFilter<"DutyRole"> | string | null
    roleType?: StringFilter<"DutyRole"> | string
    scheduleType?: StringFilter<"DutyRole"> | string
    activeDays?: IntNullableListFilter<"DutyRole">
    displayOrder?: IntFilter<"DutyRole"> | number
    createdAt?: DateTimeFilter<"DutyRole"> | Date | string
    updatedAt?: DateTimeFilter<"DutyRole"> | Date | string
    positions?: DutyPositionListRelationFilter
    schedules?: WeeklyScheduleListRelationFilter
  }, "id" | "code">

  export type DutyRoleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    roleType?: SortOrder
    scheduleType?: SortOrder
    activeDays?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DutyRoleCountOrderByAggregateInput
    _avg?: DutyRoleAvgOrderByAggregateInput
    _max?: DutyRoleMaxOrderByAggregateInput
    _min?: DutyRoleMinOrderByAggregateInput
    _sum?: DutyRoleSumOrderByAggregateInput
  }

  export type DutyRoleScalarWhereWithAggregatesInput = {
    AND?: DutyRoleScalarWhereWithAggregatesInput | DutyRoleScalarWhereWithAggregatesInput[]
    OR?: DutyRoleScalarWhereWithAggregatesInput[]
    NOT?: DutyRoleScalarWhereWithAggregatesInput | DutyRoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DutyRole"> | string
    code?: StringWithAggregatesFilter<"DutyRole"> | string
    name?: StringWithAggregatesFilter<"DutyRole"> | string
    description?: StringNullableWithAggregatesFilter<"DutyRole"> | string | null
    roleType?: StringWithAggregatesFilter<"DutyRole"> | string
    scheduleType?: StringWithAggregatesFilter<"DutyRole"> | string
    activeDays?: IntNullableListFilter<"DutyRole">
    displayOrder?: IntWithAggregatesFilter<"DutyRole"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DutyRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DutyRole"> | Date | string
  }

  export type DutyPositionWhereInput = {
    AND?: DutyPositionWhereInput | DutyPositionWhereInput[]
    OR?: DutyPositionWhereInput[]
    NOT?: DutyPositionWhereInput | DutyPositionWhereInput[]
    id?: UuidFilter<"DutyPosition"> | string
    dutyRoleId?: UuidFilter<"DutyPosition"> | string
    code?: StringFilter<"DutyPosition"> | string
    name?: StringFilter<"DutyPosition"> | string
    description?: StringNullableFilter<"DutyPosition"> | string | null
    maxSlots?: IntFilter<"DutyPosition"> | number
    displayOrder?: IntFilter<"DutyPosition"> | number
    createdAt?: DateTimeFilter<"DutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"DutyPosition"> | Date | string
    dutyRole?: XOR<DutyRoleScalarRelationFilter, DutyRoleWhereInput>
    assignments?: ScheduleAssignmentListRelationFilter
  }

  export type DutyPositionOrderByWithRelationInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxSlots?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dutyRole?: DutyRoleOrderByWithRelationInput
    assignments?: ScheduleAssignmentOrderByRelationAggregateInput
  }

  export type DutyPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dutyRoleId_code?: DutyPositionDutyRoleIdCodeCompoundUniqueInput
    AND?: DutyPositionWhereInput | DutyPositionWhereInput[]
    OR?: DutyPositionWhereInput[]
    NOT?: DutyPositionWhereInput | DutyPositionWhereInput[]
    dutyRoleId?: UuidFilter<"DutyPosition"> | string
    code?: StringFilter<"DutyPosition"> | string
    name?: StringFilter<"DutyPosition"> | string
    description?: StringNullableFilter<"DutyPosition"> | string | null
    maxSlots?: IntFilter<"DutyPosition"> | number
    displayOrder?: IntFilter<"DutyPosition"> | number
    createdAt?: DateTimeFilter<"DutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"DutyPosition"> | Date | string
    dutyRole?: XOR<DutyRoleScalarRelationFilter, DutyRoleWhereInput>
    assignments?: ScheduleAssignmentListRelationFilter
  }, "id" | "dutyRoleId_code">

  export type DutyPositionOrderByWithAggregationInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxSlots?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DutyPositionCountOrderByAggregateInput
    _avg?: DutyPositionAvgOrderByAggregateInput
    _max?: DutyPositionMaxOrderByAggregateInput
    _min?: DutyPositionMinOrderByAggregateInput
    _sum?: DutyPositionSumOrderByAggregateInput
  }

  export type DutyPositionScalarWhereWithAggregatesInput = {
    AND?: DutyPositionScalarWhereWithAggregatesInput | DutyPositionScalarWhereWithAggregatesInput[]
    OR?: DutyPositionScalarWhereWithAggregatesInput[]
    NOT?: DutyPositionScalarWhereWithAggregatesInput | DutyPositionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DutyPosition"> | string
    dutyRoleId?: UuidWithAggregatesFilter<"DutyPosition"> | string
    code?: StringWithAggregatesFilter<"DutyPosition"> | string
    name?: StringWithAggregatesFilter<"DutyPosition"> | string
    description?: StringNullableWithAggregatesFilter<"DutyPosition"> | string | null
    maxSlots?: IntWithAggregatesFilter<"DutyPosition"> | number
    displayOrder?: IntWithAggregatesFilter<"DutyPosition"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DutyPosition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DutyPosition"> | Date | string
  }

  export type WeeklyScheduleWhereInput = {
    AND?: WeeklyScheduleWhereInput | WeeklyScheduleWhereInput[]
    OR?: WeeklyScheduleWhereInput[]
    NOT?: WeeklyScheduleWhereInput | WeeklyScheduleWhereInput[]
    id?: UuidFilter<"WeeklySchedule"> | string
    dutyRoleId?: UuidFilter<"WeeklySchedule"> | string
    weekStartDate?: DateTimeFilter<"WeeklySchedule"> | Date | string
    status?: StringFilter<"WeeklySchedule"> | string
    createdBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    publishedAt?: DateTimeNullableFilter<"WeeklySchedule"> | Date | string | null
    publishedBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    notes?: StringNullableFilter<"WeeklySchedule"> | string | null
    createdAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
    dutyRole?: XOR<DutyRoleScalarRelationFilter, DutyRoleWhereInput>
    createdByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    publishedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    assignments?: ScheduleAssignmentListRelationFilter
  }

  export type WeeklyScheduleOrderByWithRelationInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    weekStartDate?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dutyRole?: DutyRoleOrderByWithRelationInput
    createdByAdmin?: AdminUserOrderByWithRelationInput
    publishedByAdmin?: AdminUserOrderByWithRelationInput
    assignments?: ScheduleAssignmentOrderByRelationAggregateInput
  }

  export type WeeklyScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dutyRoleId_weekStartDate?: WeeklyScheduleDutyRoleIdWeekStartDateCompoundUniqueInput
    AND?: WeeklyScheduleWhereInput | WeeklyScheduleWhereInput[]
    OR?: WeeklyScheduleWhereInput[]
    NOT?: WeeklyScheduleWhereInput | WeeklyScheduleWhereInput[]
    dutyRoleId?: UuidFilter<"WeeklySchedule"> | string
    weekStartDate?: DateTimeFilter<"WeeklySchedule"> | Date | string
    status?: StringFilter<"WeeklySchedule"> | string
    createdBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    publishedAt?: DateTimeNullableFilter<"WeeklySchedule"> | Date | string | null
    publishedBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    notes?: StringNullableFilter<"WeeklySchedule"> | string | null
    createdAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
    dutyRole?: XOR<DutyRoleScalarRelationFilter, DutyRoleWhereInput>
    createdByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    publishedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    assignments?: ScheduleAssignmentListRelationFilter
  }, "id" | "dutyRoleId_weekStartDate">

  export type WeeklyScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    weekStartDate?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeeklyScheduleCountOrderByAggregateInput
    _max?: WeeklyScheduleMaxOrderByAggregateInput
    _min?: WeeklyScheduleMinOrderByAggregateInput
  }

  export type WeeklyScheduleScalarWhereWithAggregatesInput = {
    AND?: WeeklyScheduleScalarWhereWithAggregatesInput | WeeklyScheduleScalarWhereWithAggregatesInput[]
    OR?: WeeklyScheduleScalarWhereWithAggregatesInput[]
    NOT?: WeeklyScheduleScalarWhereWithAggregatesInput | WeeklyScheduleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WeeklySchedule"> | string
    dutyRoleId?: UuidWithAggregatesFilter<"WeeklySchedule"> | string
    weekStartDate?: DateTimeWithAggregatesFilter<"WeeklySchedule"> | Date | string
    status?: StringWithAggregatesFilter<"WeeklySchedule"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"WeeklySchedule"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"WeeklySchedule"> | Date | string | null
    publishedBy?: UuidNullableWithAggregatesFilter<"WeeklySchedule"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WeeklySchedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeeklySchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeeklySchedule"> | Date | string
  }

  export type ScheduleAssignmentWhereInput = {
    AND?: ScheduleAssignmentWhereInput | ScheduleAssignmentWhereInput[]
    OR?: ScheduleAssignmentWhereInput[]
    NOT?: ScheduleAssignmentWhereInput | ScheduleAssignmentWhereInput[]
    id?: UuidFilter<"ScheduleAssignment"> | string
    scheduleId?: UuidFilter<"ScheduleAssignment"> | string
    dutyPositionId?: UuidNullableFilter<"ScheduleAssignment"> | string | null
    memberId?: UuidFilter<"ScheduleAssignment"> | string
    status?: StringFilter<"ScheduleAssignment"> | string
    confirmedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    notes?: StringNullableFilter<"ScheduleAssignment"> | string | null
    createdAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
    schedule?: XOR<WeeklyScheduleScalarRelationFilter, WeeklyScheduleWhereInput>
    dutyPosition?: XOR<DutyPositionNullableScalarRelationFilter, DutyPositionWhereInput> | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type ScheduleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dutyPositionId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schedule?: WeeklyScheduleOrderByWithRelationInput
    dutyPosition?: DutyPositionOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type ScheduleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleAssignmentWhereInput | ScheduleAssignmentWhereInput[]
    OR?: ScheduleAssignmentWhereInput[]
    NOT?: ScheduleAssignmentWhereInput | ScheduleAssignmentWhereInput[]
    scheduleId?: UuidFilter<"ScheduleAssignment"> | string
    dutyPositionId?: UuidNullableFilter<"ScheduleAssignment"> | string | null
    memberId?: UuidFilter<"ScheduleAssignment"> | string
    status?: StringFilter<"ScheduleAssignment"> | string
    confirmedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    notes?: StringNullableFilter<"ScheduleAssignment"> | string | null
    createdAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
    schedule?: XOR<WeeklyScheduleScalarRelationFilter, WeeklyScheduleWhereInput>
    dutyPosition?: XOR<DutyPositionNullableScalarRelationFilter, DutyPositionWhereInput> | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type ScheduleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dutyPositionId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleAssignmentCountOrderByAggregateInput
    _max?: ScheduleAssignmentMaxOrderByAggregateInput
    _min?: ScheduleAssignmentMinOrderByAggregateInput
  }

  export type ScheduleAssignmentScalarWhereWithAggregatesInput = {
    AND?: ScheduleAssignmentScalarWhereWithAggregatesInput | ScheduleAssignmentScalarWhereWithAggregatesInput[]
    OR?: ScheduleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ScheduleAssignmentScalarWhereWithAggregatesInput | ScheduleAssignmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ScheduleAssignment"> | string
    scheduleId?: UuidWithAggregatesFilter<"ScheduleAssignment"> | string
    dutyPositionId?: UuidNullableWithAggregatesFilter<"ScheduleAssignment"> | string | null
    memberId?: UuidWithAggregatesFilter<"ScheduleAssignment"> | string
    status?: StringWithAggregatesFilter<"ScheduleAssignment"> | string
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"ScheduleAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"ScheduleAssignment"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ScheduleAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleAssignment"> | Date | string
  }

  export type LockupStatusWhereInput = {
    AND?: LockupStatusWhereInput | LockupStatusWhereInput[]
    OR?: LockupStatusWhereInput[]
    NOT?: LockupStatusWhereInput | LockupStatusWhereInput[]
    id?: UuidFilter<"LockupStatus"> | string
    date?: DateTimeFilter<"LockupStatus"> | Date | string
    currentHolderId?: UuidNullableFilter<"LockupStatus"> | string | null
    acquiredAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    buildingStatus?: StringFilter<"LockupStatus"> | string
    securedAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    securedBy?: UuidNullableFilter<"LockupStatus"> | string | null
    isActive?: BoolFilter<"LockupStatus"> | boolean
    createdAt?: DateTimeFilter<"LockupStatus"> | Date | string
    updatedAt?: DateTimeFilter<"LockupStatus"> | Date | string
    currentHolder?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    securedByMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    transfers?: LockupTransferListRelationFilter
    execution?: XOR<LockupExecutionNullableScalarRelationFilter, LockupExecutionWhereInput> | null
  }

  export type LockupStatusOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    currentHolderId?: SortOrderInput | SortOrder
    acquiredAt?: SortOrderInput | SortOrder
    buildingStatus?: SortOrder
    securedAt?: SortOrderInput | SortOrder
    securedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHolder?: MemberOrderByWithRelationInput
    securedByMember?: MemberOrderByWithRelationInput
    transfers?: LockupTransferOrderByRelationAggregateInput
    execution?: LockupExecutionOrderByWithRelationInput
  }

  export type LockupStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: LockupStatusWhereInput | LockupStatusWhereInput[]
    OR?: LockupStatusWhereInput[]
    NOT?: LockupStatusWhereInput | LockupStatusWhereInput[]
    currentHolderId?: UuidNullableFilter<"LockupStatus"> | string | null
    acquiredAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    buildingStatus?: StringFilter<"LockupStatus"> | string
    securedAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    securedBy?: UuidNullableFilter<"LockupStatus"> | string | null
    isActive?: BoolFilter<"LockupStatus"> | boolean
    createdAt?: DateTimeFilter<"LockupStatus"> | Date | string
    updatedAt?: DateTimeFilter<"LockupStatus"> | Date | string
    currentHolder?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    securedByMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    transfers?: LockupTransferListRelationFilter
    execution?: XOR<LockupExecutionNullableScalarRelationFilter, LockupExecutionWhereInput> | null
  }, "id" | "date">

  export type LockupStatusOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    currentHolderId?: SortOrderInput | SortOrder
    acquiredAt?: SortOrderInput | SortOrder
    buildingStatus?: SortOrder
    securedAt?: SortOrderInput | SortOrder
    securedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LockupStatusCountOrderByAggregateInput
    _max?: LockupStatusMaxOrderByAggregateInput
    _min?: LockupStatusMinOrderByAggregateInput
  }

  export type LockupStatusScalarWhereWithAggregatesInput = {
    AND?: LockupStatusScalarWhereWithAggregatesInput | LockupStatusScalarWhereWithAggregatesInput[]
    OR?: LockupStatusScalarWhereWithAggregatesInput[]
    NOT?: LockupStatusScalarWhereWithAggregatesInput | LockupStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LockupStatus"> | string
    date?: DateTimeWithAggregatesFilter<"LockupStatus"> | Date | string
    currentHolderId?: UuidNullableWithAggregatesFilter<"LockupStatus"> | string | null
    acquiredAt?: DateTimeNullableWithAggregatesFilter<"LockupStatus"> | Date | string | null
    buildingStatus?: StringWithAggregatesFilter<"LockupStatus"> | string
    securedAt?: DateTimeNullableWithAggregatesFilter<"LockupStatus"> | Date | string | null
    securedBy?: UuidNullableWithAggregatesFilter<"LockupStatus"> | string | null
    isActive?: BoolWithAggregatesFilter<"LockupStatus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LockupStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LockupStatus"> | Date | string
  }

  export type LockupTransferWhereInput = {
    AND?: LockupTransferWhereInput | LockupTransferWhereInput[]
    OR?: LockupTransferWhereInput[]
    NOT?: LockupTransferWhereInput | LockupTransferWhereInput[]
    id?: UuidFilter<"LockupTransfer"> | string
    lockupStatusId?: UuidFilter<"LockupTransfer"> | string
    fromMemberId?: UuidFilter<"LockupTransfer"> | string
    toMemberId?: UuidFilter<"LockupTransfer"> | string
    transferredAt?: DateTimeFilter<"LockupTransfer"> | Date | string
    reason?: StringFilter<"LockupTransfer"> | string
    notes?: StringNullableFilter<"LockupTransfer"> | string | null
    createdAt?: DateTimeFilter<"LockupTransfer"> | Date | string
    lockupStatus?: XOR<LockupStatusScalarRelationFilter, LockupStatusWhereInput>
    fromMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    toMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type LockupTransferOrderByWithRelationInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    transferredAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lockupStatus?: LockupStatusOrderByWithRelationInput
    fromMember?: MemberOrderByWithRelationInput
    toMember?: MemberOrderByWithRelationInput
  }

  export type LockupTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LockupTransferWhereInput | LockupTransferWhereInput[]
    OR?: LockupTransferWhereInput[]
    NOT?: LockupTransferWhereInput | LockupTransferWhereInput[]
    lockupStatusId?: UuidFilter<"LockupTransfer"> | string
    fromMemberId?: UuidFilter<"LockupTransfer"> | string
    toMemberId?: UuidFilter<"LockupTransfer"> | string
    transferredAt?: DateTimeFilter<"LockupTransfer"> | Date | string
    reason?: StringFilter<"LockupTransfer"> | string
    notes?: StringNullableFilter<"LockupTransfer"> | string | null
    createdAt?: DateTimeFilter<"LockupTransfer"> | Date | string
    lockupStatus?: XOR<LockupStatusScalarRelationFilter, LockupStatusWhereInput>
    fromMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    toMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type LockupTransferOrderByWithAggregationInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    transferredAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LockupTransferCountOrderByAggregateInput
    _max?: LockupTransferMaxOrderByAggregateInput
    _min?: LockupTransferMinOrderByAggregateInput
  }

  export type LockupTransferScalarWhereWithAggregatesInput = {
    AND?: LockupTransferScalarWhereWithAggregatesInput | LockupTransferScalarWhereWithAggregatesInput[]
    OR?: LockupTransferScalarWhereWithAggregatesInput[]
    NOT?: LockupTransferScalarWhereWithAggregatesInput | LockupTransferScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LockupTransfer"> | string
    lockupStatusId?: UuidWithAggregatesFilter<"LockupTransfer"> | string
    fromMemberId?: UuidWithAggregatesFilter<"LockupTransfer"> | string
    toMemberId?: UuidWithAggregatesFilter<"LockupTransfer"> | string
    transferredAt?: DateTimeWithAggregatesFilter<"LockupTransfer"> | Date | string
    reason?: StringWithAggregatesFilter<"LockupTransfer"> | string
    notes?: StringNullableWithAggregatesFilter<"LockupTransfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LockupTransfer"> | Date | string
  }

  export type LockupExecutionWhereInput = {
    AND?: LockupExecutionWhereInput | LockupExecutionWhereInput[]
    OR?: LockupExecutionWhereInput[]
    NOT?: LockupExecutionWhereInput | LockupExecutionWhereInput[]
    id?: UuidFilter<"LockupExecution"> | string
    lockupStatusId?: UuidFilter<"LockupExecution"> | string
    executedBy?: UuidFilter<"LockupExecution"> | string
    executedAt?: DateTimeFilter<"LockupExecution"> | Date | string
    membersCheckedOut?: JsonFilter<"LockupExecution">
    visitorsCheckedOut?: JsonFilter<"LockupExecution">
    totalCheckedOut?: IntFilter<"LockupExecution"> | number
    notes?: StringNullableFilter<"LockupExecution"> | string | null
    createdAt?: DateTimeFilter<"LockupExecution"> | Date | string
    lockupStatus?: XOR<LockupStatusScalarRelationFilter, LockupStatusWhereInput>
    executedByMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type LockupExecutionOrderByWithRelationInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    executedBy?: SortOrder
    executedAt?: SortOrder
    membersCheckedOut?: SortOrder
    visitorsCheckedOut?: SortOrder
    totalCheckedOut?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lockupStatus?: LockupStatusOrderByWithRelationInput
    executedByMember?: MemberOrderByWithRelationInput
  }

  export type LockupExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lockupStatusId?: string
    AND?: LockupExecutionWhereInput | LockupExecutionWhereInput[]
    OR?: LockupExecutionWhereInput[]
    NOT?: LockupExecutionWhereInput | LockupExecutionWhereInput[]
    executedBy?: UuidFilter<"LockupExecution"> | string
    executedAt?: DateTimeFilter<"LockupExecution"> | Date | string
    membersCheckedOut?: JsonFilter<"LockupExecution">
    visitorsCheckedOut?: JsonFilter<"LockupExecution">
    totalCheckedOut?: IntFilter<"LockupExecution"> | number
    notes?: StringNullableFilter<"LockupExecution"> | string | null
    createdAt?: DateTimeFilter<"LockupExecution"> | Date | string
    lockupStatus?: XOR<LockupStatusScalarRelationFilter, LockupStatusWhereInput>
    executedByMember?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "lockupStatusId">

  export type LockupExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    executedBy?: SortOrder
    executedAt?: SortOrder
    membersCheckedOut?: SortOrder
    visitorsCheckedOut?: SortOrder
    totalCheckedOut?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LockupExecutionCountOrderByAggregateInput
    _avg?: LockupExecutionAvgOrderByAggregateInput
    _max?: LockupExecutionMaxOrderByAggregateInput
    _min?: LockupExecutionMinOrderByAggregateInput
    _sum?: LockupExecutionSumOrderByAggregateInput
  }

  export type LockupExecutionScalarWhereWithAggregatesInput = {
    AND?: LockupExecutionScalarWhereWithAggregatesInput | LockupExecutionScalarWhereWithAggregatesInput[]
    OR?: LockupExecutionScalarWhereWithAggregatesInput[]
    NOT?: LockupExecutionScalarWhereWithAggregatesInput | LockupExecutionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LockupExecution"> | string
    lockupStatusId?: UuidWithAggregatesFilter<"LockupExecution"> | string
    executedBy?: UuidWithAggregatesFilter<"LockupExecution"> | string
    executedAt?: DateTimeWithAggregatesFilter<"LockupExecution"> | Date | string
    membersCheckedOut?: JsonWithAggregatesFilter<"LockupExecution">
    visitorsCheckedOut?: JsonWithAggregatesFilter<"LockupExecution">
    totalCheckedOut?: IntWithAggregatesFilter<"LockupExecution"> | number
    notes?: StringNullableWithAggregatesFilter<"LockupExecution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LockupExecution"> | Date | string
  }

  export type MissedCheckoutWhereInput = {
    AND?: MissedCheckoutWhereInput | MissedCheckoutWhereInput[]
    OR?: MissedCheckoutWhereInput[]
    NOT?: MissedCheckoutWhereInput | MissedCheckoutWhereInput[]
    id?: UuidFilter<"MissedCheckout"> | string
    memberId?: UuidFilter<"MissedCheckout"> | string
    date?: DateTimeFilter<"MissedCheckout"> | Date | string
    originalCheckinAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    forcedCheckoutAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    resolvedBy?: StringFilter<"MissedCheckout"> | string
    resolvedByAdminId?: UuidNullableFilter<"MissedCheckout"> | string | null
    lockupExecutionId?: UuidNullableFilter<"MissedCheckout"> | string | null
    notes?: StringNullableFilter<"MissedCheckout"> | string | null
    createdAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    resolvedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type MissedCheckoutOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    originalCheckinAt?: SortOrder
    forcedCheckoutAt?: SortOrder
    resolvedBy?: SortOrder
    resolvedByAdminId?: SortOrderInput | SortOrder
    lockupExecutionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    member?: MemberOrderByWithRelationInput
    resolvedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type MissedCheckoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MissedCheckoutWhereInput | MissedCheckoutWhereInput[]
    OR?: MissedCheckoutWhereInput[]
    NOT?: MissedCheckoutWhereInput | MissedCheckoutWhereInput[]
    memberId?: UuidFilter<"MissedCheckout"> | string
    date?: DateTimeFilter<"MissedCheckout"> | Date | string
    originalCheckinAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    forcedCheckoutAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    resolvedBy?: StringFilter<"MissedCheckout"> | string
    resolvedByAdminId?: UuidNullableFilter<"MissedCheckout"> | string | null
    lockupExecutionId?: UuidNullableFilter<"MissedCheckout"> | string | null
    notes?: StringNullableFilter<"MissedCheckout"> | string | null
    createdAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    resolvedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type MissedCheckoutOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    originalCheckinAt?: SortOrder
    forcedCheckoutAt?: SortOrder
    resolvedBy?: SortOrder
    resolvedByAdminId?: SortOrderInput | SortOrder
    lockupExecutionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MissedCheckoutCountOrderByAggregateInput
    _max?: MissedCheckoutMaxOrderByAggregateInput
    _min?: MissedCheckoutMinOrderByAggregateInput
  }

  export type MissedCheckoutScalarWhereWithAggregatesInput = {
    AND?: MissedCheckoutScalarWhereWithAggregatesInput | MissedCheckoutScalarWhereWithAggregatesInput[]
    OR?: MissedCheckoutScalarWhereWithAggregatesInput[]
    NOT?: MissedCheckoutScalarWhereWithAggregatesInput | MissedCheckoutScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MissedCheckout"> | string
    memberId?: UuidWithAggregatesFilter<"MissedCheckout"> | string
    date?: DateTimeWithAggregatesFilter<"MissedCheckout"> | Date | string
    originalCheckinAt?: DateTimeWithAggregatesFilter<"MissedCheckout"> | Date | string
    forcedCheckoutAt?: DateTimeWithAggregatesFilter<"MissedCheckout"> | Date | string
    resolvedBy?: StringWithAggregatesFilter<"MissedCheckout"> | string
    resolvedByAdminId?: UuidNullableWithAggregatesFilter<"MissedCheckout"> | string | null
    lockupExecutionId?: UuidNullableWithAggregatesFilter<"MissedCheckout"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MissedCheckout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MissedCheckout"> | Date | string
  }

  export type UnitEventTypeWhereInput = {
    AND?: UnitEventTypeWhereInput | UnitEventTypeWhereInput[]
    OR?: UnitEventTypeWhereInput[]
    NOT?: UnitEventTypeWhereInput | UnitEventTypeWhereInput[]
    id?: UuidFilter<"UnitEventType"> | string
    name?: StringFilter<"UnitEventType"> | string
    category?: StringFilter<"UnitEventType"> | string
    defaultDurationMinutes?: IntFilter<"UnitEventType"> | number
    requiresDutyWatch?: BoolFilter<"UnitEventType"> | boolean
    defaultMetadata?: JsonNullableFilter<"UnitEventType">
    displayOrder?: IntFilter<"UnitEventType"> | number
    createdAt?: DateTimeFilter<"UnitEventType"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventType"> | Date | string
    unitEvents?: UnitEventListRelationFilter
  }

  export type UnitEventTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultDurationMinutes?: SortOrder
    requiresDutyWatch?: SortOrder
    defaultMetadata?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unitEvents?: UnitEventOrderByRelationAggregateInput
  }

  export type UnitEventTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitEventTypeWhereInput | UnitEventTypeWhereInput[]
    OR?: UnitEventTypeWhereInput[]
    NOT?: UnitEventTypeWhereInput | UnitEventTypeWhereInput[]
    name?: StringFilter<"UnitEventType"> | string
    category?: StringFilter<"UnitEventType"> | string
    defaultDurationMinutes?: IntFilter<"UnitEventType"> | number
    requiresDutyWatch?: BoolFilter<"UnitEventType"> | boolean
    defaultMetadata?: JsonNullableFilter<"UnitEventType">
    displayOrder?: IntFilter<"UnitEventType"> | number
    createdAt?: DateTimeFilter<"UnitEventType"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventType"> | Date | string
    unitEvents?: UnitEventListRelationFilter
  }, "id">

  export type UnitEventTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultDurationMinutes?: SortOrder
    requiresDutyWatch?: SortOrder
    defaultMetadata?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitEventTypeCountOrderByAggregateInput
    _avg?: UnitEventTypeAvgOrderByAggregateInput
    _max?: UnitEventTypeMaxOrderByAggregateInput
    _min?: UnitEventTypeMinOrderByAggregateInput
    _sum?: UnitEventTypeSumOrderByAggregateInput
  }

  export type UnitEventTypeScalarWhereWithAggregatesInput = {
    AND?: UnitEventTypeScalarWhereWithAggregatesInput | UnitEventTypeScalarWhereWithAggregatesInput[]
    OR?: UnitEventTypeScalarWhereWithAggregatesInput[]
    NOT?: UnitEventTypeScalarWhereWithAggregatesInput | UnitEventTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UnitEventType"> | string
    name?: StringWithAggregatesFilter<"UnitEventType"> | string
    category?: StringWithAggregatesFilter<"UnitEventType"> | string
    defaultDurationMinutes?: IntWithAggregatesFilter<"UnitEventType"> | number
    requiresDutyWatch?: BoolWithAggregatesFilter<"UnitEventType"> | boolean
    defaultMetadata?: JsonNullableWithAggregatesFilter<"UnitEventType">
    displayOrder?: IntWithAggregatesFilter<"UnitEventType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnitEventType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitEventType"> | Date | string
  }

  export type UnitEventWhereInput = {
    AND?: UnitEventWhereInput | UnitEventWhereInput[]
    OR?: UnitEventWhereInput[]
    NOT?: UnitEventWhereInput | UnitEventWhereInput[]
    id?: UuidFilter<"UnitEvent"> | string
    title?: StringFilter<"UnitEvent"> | string
    eventTypeId?: UuidNullableFilter<"UnitEvent"> | string | null
    eventDate?: DateTimeFilter<"UnitEvent"> | Date | string
    startTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    endTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    location?: StringNullableFilter<"UnitEvent"> | string | null
    description?: StringNullableFilter<"UnitEvent"> | string | null
    organizer?: StringNullableFilter<"UnitEvent"> | string | null
    requiresDutyWatch?: BoolFilter<"UnitEvent"> | boolean
    status?: StringFilter<"UnitEvent"> | string
    metadata?: JsonNullableFilter<"UnitEvent">
    notes?: StringNullableFilter<"UnitEvent"> | string | null
    createdBy?: UuidNullableFilter<"UnitEvent"> | string | null
    createdAt?: DateTimeFilter<"UnitEvent"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEvent"> | Date | string
    eventType?: XOR<UnitEventTypeNullableScalarRelationFilter, UnitEventTypeWhereInput> | null
    dutyPositions?: UnitEventDutyPositionListRelationFilter
    dutyAssignments?: UnitEventDutyAssignmentListRelationFilter
  }

  export type UnitEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    eventTypeId?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    requiresDutyWatch?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: UnitEventTypeOrderByWithRelationInput
    dutyPositions?: UnitEventDutyPositionOrderByRelationAggregateInput
    dutyAssignments?: UnitEventDutyAssignmentOrderByRelationAggregateInput
  }

  export type UnitEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitEventWhereInput | UnitEventWhereInput[]
    OR?: UnitEventWhereInput[]
    NOT?: UnitEventWhereInput | UnitEventWhereInput[]
    title?: StringFilter<"UnitEvent"> | string
    eventTypeId?: UuidNullableFilter<"UnitEvent"> | string | null
    eventDate?: DateTimeFilter<"UnitEvent"> | Date | string
    startTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    endTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    location?: StringNullableFilter<"UnitEvent"> | string | null
    description?: StringNullableFilter<"UnitEvent"> | string | null
    organizer?: StringNullableFilter<"UnitEvent"> | string | null
    requiresDutyWatch?: BoolFilter<"UnitEvent"> | boolean
    status?: StringFilter<"UnitEvent"> | string
    metadata?: JsonNullableFilter<"UnitEvent">
    notes?: StringNullableFilter<"UnitEvent"> | string | null
    createdBy?: UuidNullableFilter<"UnitEvent"> | string | null
    createdAt?: DateTimeFilter<"UnitEvent"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEvent"> | Date | string
    eventType?: XOR<UnitEventTypeNullableScalarRelationFilter, UnitEventTypeWhereInput> | null
    dutyPositions?: UnitEventDutyPositionListRelationFilter
    dutyAssignments?: UnitEventDutyAssignmentListRelationFilter
  }, "id">

  export type UnitEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    eventTypeId?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    requiresDutyWatch?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitEventCountOrderByAggregateInput
    _max?: UnitEventMaxOrderByAggregateInput
    _min?: UnitEventMinOrderByAggregateInput
  }

  export type UnitEventScalarWhereWithAggregatesInput = {
    AND?: UnitEventScalarWhereWithAggregatesInput | UnitEventScalarWhereWithAggregatesInput[]
    OR?: UnitEventScalarWhereWithAggregatesInput[]
    NOT?: UnitEventScalarWhereWithAggregatesInput | UnitEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UnitEvent"> | string
    title?: StringWithAggregatesFilter<"UnitEvent"> | string
    eventTypeId?: UuidNullableWithAggregatesFilter<"UnitEvent"> | string | null
    eventDate?: DateTimeWithAggregatesFilter<"UnitEvent"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"UnitEvent"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"UnitEvent"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"UnitEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"UnitEvent"> | string | null
    organizer?: StringNullableWithAggregatesFilter<"UnitEvent"> | string | null
    requiresDutyWatch?: BoolWithAggregatesFilter<"UnitEvent"> | boolean
    status?: StringWithAggregatesFilter<"UnitEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"UnitEvent">
    notes?: StringNullableWithAggregatesFilter<"UnitEvent"> | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"UnitEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitEvent"> | Date | string
  }

  export type UnitEventDutyPositionWhereInput = {
    AND?: UnitEventDutyPositionWhereInput | UnitEventDutyPositionWhereInput[]
    OR?: UnitEventDutyPositionWhereInput[]
    NOT?: UnitEventDutyPositionWhereInput | UnitEventDutyPositionWhereInput[]
    id?: UuidFilter<"UnitEventDutyPosition"> | string
    eventId?: UuidFilter<"UnitEventDutyPosition"> | string
    code?: StringFilter<"UnitEventDutyPosition"> | string
    name?: StringFilter<"UnitEventDutyPosition"> | string
    description?: StringNullableFilter<"UnitEventDutyPosition"> | string | null
    maxSlots?: IntFilter<"UnitEventDutyPosition"> | number
    isStandard?: BoolFilter<"UnitEventDutyPosition"> | boolean
    displayOrder?: IntFilter<"UnitEventDutyPosition"> | number
    createdAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
    event?: XOR<UnitEventScalarRelationFilter, UnitEventWhereInput>
    assignments?: UnitEventDutyAssignmentListRelationFilter
  }

  export type UnitEventDutyPositionOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxSlots?: SortOrder
    isStandard?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: UnitEventOrderByWithRelationInput
    assignments?: UnitEventDutyAssignmentOrderByRelationAggregateInput
  }

  export type UnitEventDutyPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_code?: UnitEventDutyPositionEventIdCodeCompoundUniqueInput
    AND?: UnitEventDutyPositionWhereInput | UnitEventDutyPositionWhereInput[]
    OR?: UnitEventDutyPositionWhereInput[]
    NOT?: UnitEventDutyPositionWhereInput | UnitEventDutyPositionWhereInput[]
    eventId?: UuidFilter<"UnitEventDutyPosition"> | string
    code?: StringFilter<"UnitEventDutyPosition"> | string
    name?: StringFilter<"UnitEventDutyPosition"> | string
    description?: StringNullableFilter<"UnitEventDutyPosition"> | string | null
    maxSlots?: IntFilter<"UnitEventDutyPosition"> | number
    isStandard?: BoolFilter<"UnitEventDutyPosition"> | boolean
    displayOrder?: IntFilter<"UnitEventDutyPosition"> | number
    createdAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
    event?: XOR<UnitEventScalarRelationFilter, UnitEventWhereInput>
    assignments?: UnitEventDutyAssignmentListRelationFilter
  }, "id" | "eventId_code">

  export type UnitEventDutyPositionOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxSlots?: SortOrder
    isStandard?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitEventDutyPositionCountOrderByAggregateInput
    _avg?: UnitEventDutyPositionAvgOrderByAggregateInput
    _max?: UnitEventDutyPositionMaxOrderByAggregateInput
    _min?: UnitEventDutyPositionMinOrderByAggregateInput
    _sum?: UnitEventDutyPositionSumOrderByAggregateInput
  }

  export type UnitEventDutyPositionScalarWhereWithAggregatesInput = {
    AND?: UnitEventDutyPositionScalarWhereWithAggregatesInput | UnitEventDutyPositionScalarWhereWithAggregatesInput[]
    OR?: UnitEventDutyPositionScalarWhereWithAggregatesInput[]
    NOT?: UnitEventDutyPositionScalarWhereWithAggregatesInput | UnitEventDutyPositionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UnitEventDutyPosition"> | string
    eventId?: UuidWithAggregatesFilter<"UnitEventDutyPosition"> | string
    code?: StringWithAggregatesFilter<"UnitEventDutyPosition"> | string
    name?: StringWithAggregatesFilter<"UnitEventDutyPosition"> | string
    description?: StringNullableWithAggregatesFilter<"UnitEventDutyPosition"> | string | null
    maxSlots?: IntWithAggregatesFilter<"UnitEventDutyPosition"> | number
    isStandard?: BoolWithAggregatesFilter<"UnitEventDutyPosition"> | boolean
    displayOrder?: IntWithAggregatesFilter<"UnitEventDutyPosition"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnitEventDutyPosition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitEventDutyPosition"> | Date | string
  }

  export type UnitEventDutyAssignmentWhereInput = {
    AND?: UnitEventDutyAssignmentWhereInput | UnitEventDutyAssignmentWhereInput[]
    OR?: UnitEventDutyAssignmentWhereInput[]
    NOT?: UnitEventDutyAssignmentWhereInput | UnitEventDutyAssignmentWhereInput[]
    id?: UuidFilter<"UnitEventDutyAssignment"> | string
    eventId?: UuidFilter<"UnitEventDutyAssignment"> | string
    eventDutyPositionId?: UuidNullableFilter<"UnitEventDutyAssignment"> | string | null
    memberId?: UuidFilter<"UnitEventDutyAssignment"> | string
    status?: StringFilter<"UnitEventDutyAssignment"> | string
    isVolunteer?: BoolFilter<"UnitEventDutyAssignment"> | boolean
    confirmedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    notes?: StringNullableFilter<"UnitEventDutyAssignment"> | string | null
    createdAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
    event?: XOR<UnitEventScalarRelationFilter, UnitEventWhereInput>
    eventDutyPosition?: XOR<UnitEventDutyPositionNullableScalarRelationFilter, UnitEventDutyPositionWhereInput> | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type UnitEventDutyAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventDutyPositionId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    status?: SortOrder
    isVolunteer?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: UnitEventOrderByWithRelationInput
    eventDutyPosition?: UnitEventDutyPositionOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type UnitEventDutyAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_memberId_eventDutyPositionId?: UnitEventDutyAssignmentEventIdMemberIdEventDutyPositionIdCompoundUniqueInput
    AND?: UnitEventDutyAssignmentWhereInput | UnitEventDutyAssignmentWhereInput[]
    OR?: UnitEventDutyAssignmentWhereInput[]
    NOT?: UnitEventDutyAssignmentWhereInput | UnitEventDutyAssignmentWhereInput[]
    eventId?: UuidFilter<"UnitEventDutyAssignment"> | string
    eventDutyPositionId?: UuidNullableFilter<"UnitEventDutyAssignment"> | string | null
    memberId?: UuidFilter<"UnitEventDutyAssignment"> | string
    status?: StringFilter<"UnitEventDutyAssignment"> | string
    isVolunteer?: BoolFilter<"UnitEventDutyAssignment"> | boolean
    confirmedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    notes?: StringNullableFilter<"UnitEventDutyAssignment"> | string | null
    createdAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
    event?: XOR<UnitEventScalarRelationFilter, UnitEventWhereInput>
    eventDutyPosition?: XOR<UnitEventDutyPositionNullableScalarRelationFilter, UnitEventDutyPositionWhereInput> | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "eventId_memberId_eventDutyPositionId">

  export type UnitEventDutyAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventDutyPositionId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    status?: SortOrder
    isVolunteer?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitEventDutyAssignmentCountOrderByAggregateInput
    _max?: UnitEventDutyAssignmentMaxOrderByAggregateInput
    _min?: UnitEventDutyAssignmentMinOrderByAggregateInput
  }

  export type UnitEventDutyAssignmentScalarWhereWithAggregatesInput = {
    AND?: UnitEventDutyAssignmentScalarWhereWithAggregatesInput | UnitEventDutyAssignmentScalarWhereWithAggregatesInput[]
    OR?: UnitEventDutyAssignmentScalarWhereWithAggregatesInput[]
    NOT?: UnitEventDutyAssignmentScalarWhereWithAggregatesInput | UnitEventDutyAssignmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UnitEventDutyAssignment"> | string
    eventId?: UuidWithAggregatesFilter<"UnitEventDutyAssignment"> | string
    eventDutyPositionId?: UuidNullableWithAggregatesFilter<"UnitEventDutyAssignment"> | string | null
    memberId?: UuidWithAggregatesFilter<"UnitEventDutyAssignment"> | string
    status?: StringWithAggregatesFilter<"UnitEventDutyAssignment"> | string
    isVolunteer?: BoolWithAggregatesFilter<"UnitEventDutyAssignment"> | boolean
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"UnitEventDutyAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"UnitEventDutyAssignment"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"UnitEventDutyAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitEventDutyAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitEventDutyAssignment"> | Date | string
  }

  export type AdminUserCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
    adminUser?: AdminUserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    adminUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminUser?: AdminUserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    adminUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeCreateInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckinCreateInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinCreateManyInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DivisionCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DivisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    event: EventCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeCreateManyInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventAttendeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    badge: BadgeCreateNestedOneWithoutEventCheckinsInput
    eventAttendee: EventAttendeeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateInput = {
    id?: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput
    eventAttendee?: EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateManyInput = {
    id?: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutEventInput
    visitors?: VisitorCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutEventNestedInput
    visitors?: VisitorUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagCreateNestedManyWithoutTagInput
    qualificationTypes?: QualificationTypeCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutTagInput
    qualificationTypes?: QualificationTypeUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUpdateManyWithoutTagNestedInput
    qualificationTypes?: QualificationTypeUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUncheckedUpdateManyWithoutTagNestedInput
    qualificationTypes?: QualificationTypeUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagCreateInput = {
    id?: string
    createdAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberTagsInput
    tag: TagCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateInput = {
    id?: string
    memberId: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagCreateManyInput = {
    id?: string
    memberId: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityAlertCreateInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
    acknowledgedByAdmin?: AdminUserCreateNestedOneWithoutSecurityAlertsInput
  }

  export type SecurityAlertUncheckedCreateInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedByAdmin?: AdminUserUpdateOneWithoutSecurityAlertsNestedInput
  }

  export type SecurityAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertCreateManyInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorCreateManyInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmqCourseCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutBmqCourseInput
  }

  export type BmqCourseUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutBmqCourseInput
  }

  export type BmqCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutBmqCourseNestedInput
  }

  export type BmqCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseNestedInput
  }

  export type BmqCourseCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    bmqCourse: BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput
    member: MemberCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateInput = {
    id?: string
    memberId: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    bmqCourse?: BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentCreateManyInput = {
    id?: string
    memberId: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsCreateInput = {
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateManyInput = {
    id?: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type report_audit_logCreateInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
    admin_users?: AdminUserCreateNestedOneWithoutReport_audit_logInput
  }

  export type report_audit_logUncheckedCreateInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    generated_by?: string | null
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users?: AdminUserUpdateOneWithoutReport_audit_logNestedInput
  }

  export type report_audit_logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logCreateManyInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    generated_by?: string | null
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportSettingCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUncheckedCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingCreateManyInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentCreateInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentCreateManyInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponsibilityAuditLogCreateInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUncheckedCreateInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogCreateManyInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberStatusCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutMemberStatusRefInput
  }

  export type MemberStatusUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutMemberStatusRefInput
  }

  export type MemberStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutMemberStatusRefNestedInput
  }

  export type MemberStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutMemberStatusRefNestedInput
  }

  export type MemberStatusCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutMemberTypeRefInput
  }

  export type MemberTypeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutMemberTypeRefInput
  }

  export type MemberTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutMemberTypeRefNestedInput
  }

  export type MemberTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutMemberTypeRefNestedInput
  }

  export type MemberTypeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorCreateNestedManyWithoutVisitTypeRefInput
  }

  export type VisitTypeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorUncheckedCreateNestedManyWithoutVisitTypeRefInput
  }

  export type VisitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUpdateManyWithoutVisitTypeRefNestedInput
  }

  export type VisitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUncheckedUpdateManyWithoutVisitTypeRefNestedInput
  }

  export type VisitTypeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badges?: BadgeCreateNestedManyWithoutBadgeStatusRefInput
  }

  export type BadgeStatusUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badges?: BadgeUncheckedCreateNestedManyWithoutBadgeStatusRefInput
  }

  export type BadgeStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: BadgeUpdateManyWithoutBadgeStatusRefNestedInput
  }

  export type BadgeStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: BadgeUncheckedUpdateManyWithoutBadgeStatusRefNestedInput
  }

  export type BadgeStatusCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemCreateInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUncheckedCreateInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemCreateManyInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RankCreateInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutRankRefInput
    replacedByRank?: RankCreateNestedOneWithoutReplacesRanksInput
    replacesRanks?: RankCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    replacedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutRankRefInput
    replacesRanks?: RankUncheckedCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutRankRefNestedInput
    replacedByRank?: RankUpdateOneWithoutReplacesRanksNestedInput
    replacesRanks?: RankUpdateManyWithoutReplacedByRankNestedInput
  }

  export type RankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    replacedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutRankRefNestedInput
    replacesRanks?: RankUncheckedUpdateManyWithoutReplacedByRankNestedInput
  }

  export type RankCreateManyInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    replacedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    replacedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigCreateInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUncheckedCreateInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigCreateManyInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatHolidayCreateInput = {
    id?: string
    date: Date | string
    name: string
    province?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatHolidayUncheckedCreateInput = {
    id?: string
    date: Date | string
    name: string
    province?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatHolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    province?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatHolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    province?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatHolidayCreateManyInput = {
    id?: string
    date: Date | string
    name: string
    province?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatHolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    province?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatHolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    province?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualificationTypeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberQualifications?: MemberQualificationCreateNestedManyWithoutQualificationTypeInput
    tag?: TagCreateNestedOneWithoutQualificationTypesInput
  }

  export type QualificationTypeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    tagId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberQualifications?: MemberQualificationUncheckedCreateNestedManyWithoutQualificationTypeInput
  }

  export type QualificationTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberQualifications?: MemberQualificationUpdateManyWithoutQualificationTypeNestedInput
    tag?: TagUpdateOneWithoutQualificationTypesNestedInput
  }

  export type QualificationTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberQualifications?: MemberQualificationUncheckedUpdateManyWithoutQualificationTypeNestedInput
  }

  export type QualificationTypeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    tagId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualificationTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualificationTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationCreateInput = {
    id?: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutQualificationsInput
    qualificationType: QualificationTypeCreateNestedOneWithoutMemberQualificationsInput
    grantedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsGrantedInput
    revokedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsRevokedInput
  }

  export type MemberQualificationUncheckedCreateInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutQualificationsNestedInput
    qualificationType?: QualificationTypeUpdateOneRequiredWithoutMemberQualificationsNestedInput
    grantedByAdmin?: AdminUserUpdateOneWithoutQualificationsGrantedNestedInput
    revokedByAdmin?: AdminUserUpdateOneWithoutQualificationsRevokedNestedInput
  }

  export type MemberQualificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationCreateManyInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRoleCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: DutyPositionCreateNestedManyWithoutDutyRoleInput
    schedules?: WeeklyScheduleCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: DutyPositionUncheckedCreateNestedManyWithoutDutyRoleInput
    schedules?: WeeklyScheduleUncheckedCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: DutyPositionUpdateManyWithoutDutyRoleNestedInput
    schedules?: WeeklyScheduleUpdateManyWithoutDutyRoleNestedInput
  }

  export type DutyRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: DutyPositionUncheckedUpdateManyWithoutDutyRoleNestedInput
    schedules?: WeeklyScheduleUncheckedUpdateManyWithoutDutyRoleNestedInput
  }

  export type DutyRoleCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyPositionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutPositionsInput
    assignments?: ScheduleAssignmentCreateNestedManyWithoutDutyPositionInput
  }

  export type DutyPositionUncheckedCreateInput = {
    id?: string
    dutyRoleId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutDutyPositionInput
  }

  export type DutyPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutPositionsNestedInput
    assignments?: ScheduleAssignmentUpdateManyWithoutDutyPositionNestedInput
  }

  export type DutyPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutDutyPositionNestedInput
  }

  export type DutyPositionCreateManyInput = {
    id?: string
    dutyRoleId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyScheduleCreateInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutSchedulesInput
    createdByAdmin?: AdminUserCreateNestedOneWithoutSchedulesCreatedInput
    publishedByAdmin?: AdminUserCreateNestedOneWithoutSchedulesPublishedInput
    assignments?: ScheduleAssignmentCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleUncheckedCreateInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutSchedulesNestedInput
    createdByAdmin?: AdminUserUpdateOneWithoutSchedulesCreatedNestedInput
    publishedByAdmin?: AdminUserUpdateOneWithoutSchedulesPublishedNestedInput
    assignments?: ScheduleAssignmentUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleCreateManyInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentCreateInput = {
    id?: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: WeeklyScheduleCreateNestedOneWithoutAssignmentsInput
    dutyPosition?: DutyPositionCreateNestedOneWithoutAssignmentsInput
    member: MemberCreateNestedOneWithoutScheduleAssignmentsInput
  }

  export type ScheduleAssignmentUncheckedCreateInput = {
    id?: string
    scheduleId: string
    dutyPositionId?: string | null
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: WeeklyScheduleUpdateOneRequiredWithoutAssignmentsNestedInput
    dutyPosition?: DutyPositionUpdateOneWithoutAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutScheduleAssignmentsNestedInput
  }

  export type ScheduleAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentCreateManyInput = {
    id?: string
    scheduleId: string
    dutyPositionId?: string | null
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupStatusCreateInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHolder?: MemberCreateNestedOneWithoutLockupHoldingInput
    securedByMember?: MemberCreateNestedOneWithoutLockupSecuredInput
    transfers?: LockupTransferCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusUncheckedCreateInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transfers?: LockupTransferUncheckedCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionUncheckedCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolder?: MemberUpdateOneWithoutLockupHoldingNestedInput
    securedByMember?: MemberUpdateOneWithoutLockupSecuredNestedInput
    transfers?: LockupTransferUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfers?: LockupTransferUncheckedUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUncheckedUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusCreateManyInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LockupStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferCreateInput = {
    id?: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
    lockupStatus: LockupStatusCreateNestedOneWithoutTransfersInput
    fromMember: MemberCreateNestedOneWithoutLockupTransfersFromInput
    toMember: MemberCreateNestedOneWithoutLockupTransfersToInput
  }

  export type LockupTransferUncheckedCreateInput = {
    id?: string
    lockupStatusId: string
    fromMemberId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockupStatus?: LockupStatusUpdateOneRequiredWithoutTransfersNestedInput
    fromMember?: MemberUpdateOneRequiredWithoutLockupTransfersFromNestedInput
    toMember?: MemberUpdateOneRequiredWithoutLockupTransfersToNestedInput
  }

  export type LockupTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferCreateManyInput = {
    id?: string
    lockupStatusId: string
    fromMemberId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupExecutionCreateInput = {
    id?: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
    lockupStatus: LockupStatusCreateNestedOneWithoutExecutionInput
    executedByMember: MemberCreateNestedOneWithoutLockupExecutionsInput
  }

  export type LockupExecutionUncheckedCreateInput = {
    id?: string
    lockupStatusId: string
    executedBy: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockupStatus?: LockupStatusUpdateOneRequiredWithoutExecutionNestedInput
    executedByMember?: MemberUpdateOneRequiredWithoutLockupExecutionsNestedInput
  }

  export type LockupExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupExecutionCreateManyInput = {
    id?: string
    lockupStatusId: string
    executedBy: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutCreateInput = {
    id?: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    member: MemberCreateNestedOneWithoutMissedCheckoutsInput
    resolvedByAdmin?: AdminUserCreateNestedOneWithoutMissedCheckoutsResolvedInput
  }

  export type MissedCheckoutUncheckedCreateInput = {
    id?: string
    memberId: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    resolvedByAdminId?: string | null
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MissedCheckoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutMissedCheckoutsNestedInput
    resolvedByAdmin?: AdminUserUpdateOneWithoutMissedCheckoutsResolvedNestedInput
  }

  export type MissedCheckoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutCreateManyInput = {
    id?: string
    memberId: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    resolvedByAdminId?: string | null
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MissedCheckoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventTypeCreateInput = {
    id?: string
    name: string
    category: string
    defaultDurationMinutes?: number
    requiresDutyWatch?: boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unitEvents?: UnitEventCreateNestedManyWithoutEventTypeInput
  }

  export type UnitEventTypeUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    defaultDurationMinutes?: number
    requiresDutyWatch?: boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unitEvents?: UnitEventUncheckedCreateNestedManyWithoutEventTypeInput
  }

  export type UnitEventTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitEvents?: UnitEventUpdateManyWithoutEventTypeNestedInput
  }

  export type UnitEventTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitEvents?: UnitEventUncheckedUpdateManyWithoutEventTypeNestedInput
  }

  export type UnitEventTypeCreateManyInput = {
    id?: string
    name: string
    category: string
    defaultDurationMinutes?: number
    requiresDutyWatch?: boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventCreateInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: UnitEventTypeCreateNestedOneWithoutUnitEventsInput
    dutyPositions?: UnitEventDutyPositionCreateNestedManyWithoutEventInput
    dutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutEventInput
  }

  export type UnitEventUncheckedCreateInput = {
    id?: string
    title: string
    eventTypeId?: string | null
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedCreateNestedManyWithoutEventInput
    dutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventInput
  }

  export type UnitEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: UnitEventTypeUpdateOneWithoutUnitEventsNestedInput
    dutyPositions?: UnitEventDutyPositionUpdateManyWithoutEventNestedInput
    dutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutEventNestedInput
  }

  export type UnitEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedUpdateManyWithoutEventNestedInput
    dutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UnitEventCreateManyInput = {
    id?: string
    title: string
    eventTypeId?: string | null
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyPositionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    event: UnitEventCreateNestedOneWithoutDutyPositionsInput
    assignments?: UnitEventDutyAssignmentCreateNestedManyWithoutEventDutyPositionInput
  }

  export type UnitEventDutyPositionUncheckedCreateInput = {
    id?: string
    eventId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventDutyPositionInput
  }

  export type UnitEventDutyPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: UnitEventUpdateOneRequiredWithoutDutyPositionsNestedInput
    assignments?: UnitEventDutyAssignmentUpdateManyWithoutEventDutyPositionNestedInput
  }

  export type UnitEventDutyPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventDutyPositionNestedInput
  }

  export type UnitEventDutyPositionCreateManyInput = {
    id?: string
    eventId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentCreateInput = {
    id?: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: UnitEventCreateNestedOneWithoutDutyAssignmentsInput
    eventDutyPosition?: UnitEventDutyPositionCreateNestedOneWithoutAssignmentsInput
    member: MemberCreateNestedOneWithoutUnitEventDutyAssignmentsInput
  }

  export type UnitEventDutyAssignmentUncheckedCreateInput = {
    id?: string
    eventId: string
    eventDutyPositionId?: string | null
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: UnitEventUpdateOneRequiredWithoutDutyAssignmentsNestedInput
    eventDutyPosition?: UnitEventDutyPositionUpdateOneWithoutAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutUnitEventDutyAssignmentsNestedInput
  }

  export type UnitEventDutyAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentCreateManyInput = {
    id?: string
    eventId: string
    eventDutyPositionId?: string | null
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CheckinListRelationFilter = {
    every?: CheckinWhereInput
    some?: CheckinWhereInput
    none?: CheckinWhereInput
  }

  export type Report_audit_logListRelationFilter = {
    every?: report_audit_logWhereInput
    some?: report_audit_logWhereInput
    none?: report_audit_logWhereInput
  }

  export type SecurityAlertListRelationFilter = {
    every?: SecurityAlertWhereInput
    some?: SecurityAlertWhereInput
    none?: SecurityAlertWhereInput
  }

  export type VisitorListRelationFilter = {
    every?: VisitorWhereInput
    some?: VisitorWhereInput
    none?: VisitorWhereInput
  }

  export type DdsAssignmentListRelationFilter = {
    every?: DdsAssignmentWhereInput
    some?: DdsAssignmentWhereInput
    none?: DdsAssignmentWhereInput
  }

  export type AdminUserNullableScalarRelationFilter = {
    is?: AdminUserWhereInput | null
    isNot?: AdminUserWhereInput | null
  }

  export type AdminUserListRelationFilter = {
    every?: AdminUserWhereInput
    some?: AdminUserWhereInput
    none?: AdminUserWhereInput
  }

  export type MemberQualificationListRelationFilter = {
    every?: MemberQualificationWhereInput
    some?: MemberQualificationWhereInput
    none?: MemberQualificationWhereInput
  }

  export type WeeklyScheduleListRelationFilter = {
    every?: WeeklyScheduleWhereInput
    some?: WeeklyScheduleWhereInput
    none?: WeeklyScheduleWhereInput
  }

  export type MissedCheckoutListRelationFilter = {
    every?: MissedCheckoutWhereInput
    some?: MissedCheckoutWhereInput
    none?: MissedCheckoutWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type report_audit_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DdsAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberQualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissedCheckoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EventAttendeeListRelationFilter = {
    every?: EventAttendeeWhereInput
    some?: EventAttendeeWhereInput
    none?: EventAttendeeWhereInput
  }

  export type EventCheckinListRelationFilter = {
    every?: EventCheckinWhereInput
    some?: EventCheckinWhereInput
    none?: EventCheckinWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type BadgeStatusNullableScalarRelationFilter = {
    is?: BadgeStatusWhereInput | null
    isNot?: BadgeStatusWhereInput | null
  }

  export type EventAttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCheckinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BadgeNullableScalarRelationFilter = {
    is?: BadgeWhereInput | null
    isNot?: BadgeWhereInput | null
  }

  export type MemberNullableScalarRelationFilter = {
    is?: MemberWhereInput | null
    isNot?: MemberWhereInput | null
  }

  export type CheckinCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type CheckinMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type CheckinMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DivisionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DivisionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DivisionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventAttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type EventAttendeeScalarRelationFilter = {
    is?: EventAttendeeWhereInput
    isNot?: EventAttendeeWhereInput
  }

  export type EventCheckinCountOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCheckinMaxOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCheckinMinOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    customRoles?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RankNullableScalarRelationFilter = {
    is?: RankWhereInput | null
    isNot?: RankWhereInput | null
  }

  export type BmqEnrollmentListRelationFilter = {
    every?: BmqEnrollmentWhereInput
    some?: BmqEnrollmentWhereInput
    none?: BmqEnrollmentWhereInput
  }

  export type DivisionNullableScalarRelationFilter = {
    is?: DivisionWhereInput | null
    isNot?: DivisionWhereInput | null
  }

  export type MemberTagListRelationFilter = {
    every?: MemberTagWhereInput
    some?: MemberTagWhereInput
    none?: MemberTagWhereInput
  }

  export type MemberTypeNullableScalarRelationFilter = {
    is?: MemberTypeWhereInput | null
    isNot?: MemberTypeWhereInput | null
  }

  export type MemberStatusNullableScalarRelationFilter = {
    is?: MemberStatusWhereInput | null
    isNot?: MemberStatusWhereInput | null
  }

  export type ScheduleAssignmentListRelationFilter = {
    every?: ScheduleAssignmentWhereInput
    some?: ScheduleAssignmentWhereInput
    none?: ScheduleAssignmentWhereInput
  }

  export type LockupStatusListRelationFilter = {
    every?: LockupStatusWhereInput
    some?: LockupStatusWhereInput
    none?: LockupStatusWhereInput
  }

  export type LockupTransferListRelationFilter = {
    every?: LockupTransferWhereInput
    some?: LockupTransferWhereInput
    none?: LockupTransferWhereInput
  }

  export type LockupExecutionListRelationFilter = {
    every?: LockupExecutionWhereInput
    some?: LockupExecutionWhereInput
    none?: LockupExecutionWhereInput
  }

  export type UnitEventDutyAssignmentListRelationFilter = {
    every?: UnitEventDutyAssignmentWhereInput
    some?: UnitEventDutyAssignmentWhereInput
    none?: UnitEventDutyAssignmentWhereInput
  }

  export type BmqEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LockupStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LockupTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LockupExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitEventDutyAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rankId?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
    missedCheckoutCount?: SortOrder
    lastMissedCheckout?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    missedCheckoutCount?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rankId?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
    missedCheckoutCount?: SortOrder
    lastMissedCheckout?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rankId?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
    missedCheckoutCount?: SortOrder
    lastMissedCheckout?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    missedCheckoutCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type QualificationTypeListRelationFilter = {
    every?: QualificationTypeWhereInput
    some?: QualificationTypeWhereInput
    none?: QualificationTypeWhereInput
  }

  export type QualificationTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type MemberTagMemberIdTagIdCompoundUniqueInput = {
    memberId: string
    tagId: string
  }

  export type MemberTagCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberTagMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberTagMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertCountOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMinOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type EventNullableScalarRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type VisitTypeNullableScalarRelationFilter = {
    is?: VisitTypeWhereInput | null
    isNot?: VisitTypeWhereInput | null
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BmqCourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
  }

  export type BmqCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BmqCourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BmqCourseScalarRelationFilter = {
    is?: BmqCourseWhereInput
    isNot?: BmqCourseWhereInput
  }

  export type BmqEnrollmentMemberIdBmqCourseIdCompoundUniqueInput = {
    memberId: string
    bmqCourseId: string
  }

  export type BmqEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type BmqEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type BmqEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type report_audit_logCountOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logAvgOrderByAggregateInput = {
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logMaxOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logMinOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logSumOrderByAggregateInput = {
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReportSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingMinOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponsibilityAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type ResponsibilityAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type ResponsibilityAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type MemberStatusCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberStatusMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeStatusCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeStatusMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chipVariant?: SortOrder
    chipColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemListTypeCodeCompoundUniqueInput = {
    listType: string
    code: string
  }

  export type ListItemCountOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ListItemMaxOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemMinOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RankListRelationFilter = {
    every?: RankWhereInput
    some?: RankWhereInput
    none?: RankWhereInput
  }

  export type RankOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RankCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    replacedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RankAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RankMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    replacedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RankMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    replacedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RankSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationIdentifierValueCompoundUniqueInput = {
    identifier: string
    value: string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigCountOrderByAggregateInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigMinOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatHolidayCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    province?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatHolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    province?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatHolidayMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    province?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagNullableScalarRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type QualificationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    canReceiveLockup?: SortOrder
    displayOrder?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationTypeAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type QualificationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    canReceiveLockup?: SortOrder
    displayOrder?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    canReceiveLockup?: SortOrder
    displayOrder?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationTypeSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type QualificationTypeScalarRelationFilter = {
    is?: QualificationTypeWhereInput
    isNot?: QualificationTypeWhereInput
  }

  export type MemberQualificationMemberIdQualificationTypeIdCompoundUniqueInput = {
    memberId: string
    qualificationTypeId: string
  }

  export type MemberQualificationCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    qualificationTypeId?: SortOrder
    status?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokeReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberQualificationMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    qualificationTypeId?: SortOrder
    status?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokeReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberQualificationMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    qualificationTypeId?: SortOrder
    status?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokeReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DutyPositionListRelationFilter = {
    every?: DutyPositionWhereInput
    some?: DutyPositionWhereInput
    none?: DutyPositionWhereInput
  }

  export type DutyPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DutyRoleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    roleType?: SortOrder
    scheduleType?: SortOrder
    activeDays?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRoleAvgOrderByAggregateInput = {
    activeDays?: SortOrder
    displayOrder?: SortOrder
  }

  export type DutyRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    roleType?: SortOrder
    scheduleType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRoleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    roleType?: SortOrder
    scheduleType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRoleSumOrderByAggregateInput = {
    activeDays?: SortOrder
    displayOrder?: SortOrder
  }

  export type DutyRoleScalarRelationFilter = {
    is?: DutyRoleWhereInput
    isNot?: DutyRoleWhereInput
  }

  export type DutyPositionDutyRoleIdCodeCompoundUniqueInput = {
    dutyRoleId: string
    code: string
  }

  export type DutyPositionCountOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyPositionAvgOrderByAggregateInput = {
    maxSlots?: SortOrder
    displayOrder?: SortOrder
  }

  export type DutyPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyPositionMinOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyPositionSumOrderByAggregateInput = {
    maxSlots?: SortOrder
    displayOrder?: SortOrder
  }

  export type WeeklyScheduleDutyRoleIdWeekStartDateCompoundUniqueInput = {
    dutyRoleId: string
    weekStartDate: Date | string
  }

  export type WeeklyScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    weekStartDate?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    weekStartDate?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    dutyRoleId?: SortOrder
    weekStartDate?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyScheduleScalarRelationFilter = {
    is?: WeeklyScheduleWhereInput
    isNot?: WeeklyScheduleWhereInput
  }

  export type DutyPositionNullableScalarRelationFilter = {
    is?: DutyPositionWhereInput | null
    isNot?: DutyPositionWhereInput | null
  }

  export type ScheduleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    dutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LockupExecutionNullableScalarRelationFilter = {
    is?: LockupExecutionWhereInput | null
    isNot?: LockupExecutionWhereInput | null
  }

  export type LockupStatusCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentHolderId?: SortOrder
    acquiredAt?: SortOrder
    buildingStatus?: SortOrder
    securedAt?: SortOrder
    securedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LockupStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentHolderId?: SortOrder
    acquiredAt?: SortOrder
    buildingStatus?: SortOrder
    securedAt?: SortOrder
    securedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LockupStatusMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentHolderId?: SortOrder
    acquiredAt?: SortOrder
    buildingStatus?: SortOrder
    securedAt?: SortOrder
    securedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LockupStatusScalarRelationFilter = {
    is?: LockupStatusWhereInput
    isNot?: LockupStatusWhereInput
  }

  export type LockupTransferCountOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    transferredAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    transferredAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupTransferMinOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    transferredAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    executedBy?: SortOrder
    executedAt?: SortOrder
    membersCheckedOut?: SortOrder
    visitorsCheckedOut?: SortOrder
    totalCheckedOut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupExecutionAvgOrderByAggregateInput = {
    totalCheckedOut?: SortOrder
  }

  export type LockupExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    executedBy?: SortOrder
    executedAt?: SortOrder
    totalCheckedOut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    lockupStatusId?: SortOrder
    executedBy?: SortOrder
    executedAt?: SortOrder
    totalCheckedOut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LockupExecutionSumOrderByAggregateInput = {
    totalCheckedOut?: SortOrder
  }

  export type MissedCheckoutCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    originalCheckinAt?: SortOrder
    forcedCheckoutAt?: SortOrder
    resolvedBy?: SortOrder
    resolvedByAdminId?: SortOrder
    lockupExecutionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type MissedCheckoutMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    originalCheckinAt?: SortOrder
    forcedCheckoutAt?: SortOrder
    resolvedBy?: SortOrder
    resolvedByAdminId?: SortOrder
    lockupExecutionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type MissedCheckoutMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    originalCheckinAt?: SortOrder
    forcedCheckoutAt?: SortOrder
    resolvedBy?: SortOrder
    resolvedByAdminId?: SortOrder
    lockupExecutionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitEventListRelationFilter = {
    every?: UnitEventWhereInput
    some?: UnitEventWhereInput
    none?: UnitEventWhereInput
  }

  export type UnitEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitEventTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultDurationMinutes?: SortOrder
    requiresDutyWatch?: SortOrder
    defaultMetadata?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventTypeAvgOrderByAggregateInput = {
    defaultDurationMinutes?: SortOrder
    displayOrder?: SortOrder
  }

  export type UnitEventTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultDurationMinutes?: SortOrder
    requiresDutyWatch?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultDurationMinutes?: SortOrder
    requiresDutyWatch?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventTypeSumOrderByAggregateInput = {
    defaultDurationMinutes?: SortOrder
    displayOrder?: SortOrder
  }

  export type UnitEventTypeNullableScalarRelationFilter = {
    is?: UnitEventTypeWhereInput | null
    isNot?: UnitEventTypeWhereInput | null
  }

  export type UnitEventDutyPositionListRelationFilter = {
    every?: UnitEventDutyPositionWhereInput
    some?: UnitEventDutyPositionWhereInput
    none?: UnitEventDutyPositionWhereInput
  }

  export type UnitEventDutyPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    eventTypeId?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    description?: SortOrder
    organizer?: SortOrder
    requiresDutyWatch?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    eventTypeId?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    description?: SortOrder
    organizer?: SortOrder
    requiresDutyWatch?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    eventTypeId?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    description?: SortOrder
    organizer?: SortOrder
    requiresDutyWatch?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventScalarRelationFilter = {
    is?: UnitEventWhereInput
    isNot?: UnitEventWhereInput
  }

  export type UnitEventDutyPositionEventIdCodeCompoundUniqueInput = {
    eventId: string
    code: string
  }

  export type UnitEventDutyPositionCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    isStandard?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventDutyPositionAvgOrderByAggregateInput = {
    maxSlots?: SortOrder
    displayOrder?: SortOrder
  }

  export type UnitEventDutyPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    isStandard?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventDutyPositionMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxSlots?: SortOrder
    isStandard?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventDutyPositionSumOrderByAggregateInput = {
    maxSlots?: SortOrder
    displayOrder?: SortOrder
  }

  export type UnitEventDutyPositionNullableScalarRelationFilter = {
    is?: UnitEventDutyPositionWhereInput | null
    isNot?: UnitEventDutyPositionWhereInput | null
  }

  export type UnitEventDutyAssignmentEventIdMemberIdEventDutyPositionIdCompoundUniqueInput = {
    eventId: string
    memberId: string
    eventDutyPositionId: string
  }

  export type UnitEventDutyAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventDutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    isVolunteer?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventDutyAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventDutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    isVolunteer?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitEventDutyAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventDutyPositionId?: SortOrder
    memberId?: SortOrder
    status?: SortOrder
    isVolunteer?: SortOrder
    confirmedAt?: SortOrder
    releasedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckinCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type report_audit_logCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
  }

  export type SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type AdminUserCreateNestedOneWithoutDisabledUsersInput = {
    create?: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledUsersInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutUpdatedUsersInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedUsersInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedManyWithoutDisabledByAdminInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type AdminUserCreateNestedManyWithoutUpdatedByAdminInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type MemberQualificationCreateNestedManyWithoutGrantedByAdminInput = {
    create?: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput> | MemberQualificationCreateWithoutGrantedByAdminInput[] | MemberQualificationUncheckedCreateWithoutGrantedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutGrantedByAdminInput | MemberQualificationCreateOrConnectWithoutGrantedByAdminInput[]
    createMany?: MemberQualificationCreateManyGrantedByAdminInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type MemberQualificationCreateNestedManyWithoutRevokedByAdminInput = {
    create?: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput> | MemberQualificationCreateWithoutRevokedByAdminInput[] | MemberQualificationUncheckedCreateWithoutRevokedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutRevokedByAdminInput | MemberQualificationCreateOrConnectWithoutRevokedByAdminInput[]
    createMany?: MemberQualificationCreateManyRevokedByAdminInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput> | WeeklyScheduleCreateWithoutCreatedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput | WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyCreatedByAdminInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput = {
    create?: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput> | WeeklyScheduleCreateWithoutPublishedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput | WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyPublishedByAdminInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput = {
    create?: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput> | MissedCheckoutCreateWithoutResolvedByAdminInput[] | MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput | MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput[]
    createMany?: MissedCheckoutCreateManyResolvedByAdminInputEnvelope
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
  }

  export type SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput = {
    create?: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput> | MemberQualificationCreateWithoutGrantedByAdminInput[] | MemberQualificationUncheckedCreateWithoutGrantedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutGrantedByAdminInput | MemberQualificationCreateOrConnectWithoutGrantedByAdminInput[]
    createMany?: MemberQualificationCreateManyGrantedByAdminInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput = {
    create?: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput> | MemberQualificationCreateWithoutRevokedByAdminInput[] | MemberQualificationUncheckedCreateWithoutRevokedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutRevokedByAdminInput | MemberQualificationCreateOrConnectWithoutRevokedByAdminInput[]
    createMany?: MemberQualificationCreateManyRevokedByAdminInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput> | WeeklyScheduleCreateWithoutCreatedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput | WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyCreatedByAdminInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput = {
    create?: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput> | WeeklyScheduleCreateWithoutPublishedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput | WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyPublishedByAdminInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput = {
    create?: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput> | MissedCheckoutCreateWithoutResolvedByAdminInput[] | MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput | MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput[]
    createMany?: MissedCheckoutCreateManyResolvedByAdminInputEnvelope
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AuditLogUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminUserInput | AuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckinUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput | CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput | CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutAdmin_usersInput | CheckinUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type report_audit_logUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    set?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    disconnect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    delete?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    update?: report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput | report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
  }

  export type SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput | SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput | VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput | VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutAdmin_usersInput | VisitorUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput | DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type AdminUserUpdateOneWithoutDisabledUsersNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledUsersInput
    upsert?: AdminUserUpsertWithoutDisabledUsersInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutDisabledUsersInput, AdminUserUpdateWithoutDisabledUsersInput>, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
  }

  export type AdminUserUpdateOneWithoutUpdatedUsersNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedUsersInput
    upsert?: AdminUserUpsertWithoutUpdatedUsersInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUpdatedUsersInput, AdminUserUpdateWithoutUpdatedUsersInput>, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type AdminUserUpdateManyWithoutDisabledByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput | AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AdminUserUpdateManyWithoutUpdatedByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput | AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput> | MemberQualificationCreateWithoutGrantedByAdminInput[] | MemberQualificationUncheckedCreateWithoutGrantedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutGrantedByAdminInput | MemberQualificationCreateOrConnectWithoutGrantedByAdminInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutGrantedByAdminInput | MemberQualificationUpsertWithWhereUniqueWithoutGrantedByAdminInput[]
    createMany?: MemberQualificationCreateManyGrantedByAdminInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutGrantedByAdminInput | MemberQualificationUpdateWithWhereUniqueWithoutGrantedByAdminInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutGrantedByAdminInput | MemberQualificationUpdateManyWithWhereWithoutGrantedByAdminInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput> | MemberQualificationCreateWithoutRevokedByAdminInput[] | MemberQualificationUncheckedCreateWithoutRevokedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutRevokedByAdminInput | MemberQualificationCreateOrConnectWithoutRevokedByAdminInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutRevokedByAdminInput | MemberQualificationUpsertWithWhereUniqueWithoutRevokedByAdminInput[]
    createMany?: MemberQualificationCreateManyRevokedByAdminInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutRevokedByAdminInput | MemberQualificationUpdateWithWhereUniqueWithoutRevokedByAdminInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutRevokedByAdminInput | MemberQualificationUpdateManyWithWhereWithoutRevokedByAdminInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput> | WeeklyScheduleCreateWithoutCreatedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput | WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutCreatedByAdminInput | WeeklyScheduleUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyCreatedByAdminInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutCreatedByAdminInput | WeeklyScheduleUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutCreatedByAdminInput | WeeklyScheduleUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput> | WeeklyScheduleCreateWithoutPublishedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput | WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutPublishedByAdminInput | WeeklyScheduleUpsertWithWhereUniqueWithoutPublishedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyPublishedByAdminInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutPublishedByAdminInput | WeeklyScheduleUpdateWithWhereUniqueWithoutPublishedByAdminInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutPublishedByAdminInput | WeeklyScheduleUpdateManyWithWhereWithoutPublishedByAdminInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput = {
    create?: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput> | MissedCheckoutCreateWithoutResolvedByAdminInput[] | MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput | MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput[]
    upsert?: MissedCheckoutUpsertWithWhereUniqueWithoutResolvedByAdminInput | MissedCheckoutUpsertWithWhereUniqueWithoutResolvedByAdminInput[]
    createMany?: MissedCheckoutCreateManyResolvedByAdminInputEnvelope
    set?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    disconnect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    delete?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    update?: MissedCheckoutUpdateWithWhereUniqueWithoutResolvedByAdminInput | MissedCheckoutUpdateWithWhereUniqueWithoutResolvedByAdminInput[]
    updateMany?: MissedCheckoutUpdateManyWithWhereWithoutResolvedByAdminInput | MissedCheckoutUpdateManyWithWhereWithoutResolvedByAdminInput[]
    deleteMany?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminUserInput | AuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput | CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput | CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutAdmin_usersInput | CheckinUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    set?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    disconnect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    delete?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    update?: report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput | report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
  }

  export type SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput | SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput | VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput | VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutAdmin_usersInput | VisitorUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput | DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput | AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput | AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput> | MemberQualificationCreateWithoutGrantedByAdminInput[] | MemberQualificationUncheckedCreateWithoutGrantedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutGrantedByAdminInput | MemberQualificationCreateOrConnectWithoutGrantedByAdminInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutGrantedByAdminInput | MemberQualificationUpsertWithWhereUniqueWithoutGrantedByAdminInput[]
    createMany?: MemberQualificationCreateManyGrantedByAdminInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutGrantedByAdminInput | MemberQualificationUpdateWithWhereUniqueWithoutGrantedByAdminInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutGrantedByAdminInput | MemberQualificationUpdateManyWithWhereWithoutGrantedByAdminInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput> | MemberQualificationCreateWithoutRevokedByAdminInput[] | MemberQualificationUncheckedCreateWithoutRevokedByAdminInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutRevokedByAdminInput | MemberQualificationCreateOrConnectWithoutRevokedByAdminInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutRevokedByAdminInput | MemberQualificationUpsertWithWhereUniqueWithoutRevokedByAdminInput[]
    createMany?: MemberQualificationCreateManyRevokedByAdminInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutRevokedByAdminInput | MemberQualificationUpdateWithWhereUniqueWithoutRevokedByAdminInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutRevokedByAdminInput | MemberQualificationUpdateManyWithWhereWithoutRevokedByAdminInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput> | WeeklyScheduleCreateWithoutCreatedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput | WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutCreatedByAdminInput | WeeklyScheduleUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyCreatedByAdminInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutCreatedByAdminInput | WeeklyScheduleUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutCreatedByAdminInput | WeeklyScheduleUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput> | WeeklyScheduleCreateWithoutPublishedByAdminInput[] | WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput | WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutPublishedByAdminInput | WeeklyScheduleUpsertWithWhereUniqueWithoutPublishedByAdminInput[]
    createMany?: WeeklyScheduleCreateManyPublishedByAdminInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutPublishedByAdminInput | WeeklyScheduleUpdateWithWhereUniqueWithoutPublishedByAdminInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutPublishedByAdminInput | WeeklyScheduleUpdateManyWithWhereWithoutPublishedByAdminInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput = {
    create?: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput> | MissedCheckoutCreateWithoutResolvedByAdminInput[] | MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput | MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput[]
    upsert?: MissedCheckoutUpsertWithWhereUniqueWithoutResolvedByAdminInput | MissedCheckoutUpsertWithWhereUniqueWithoutResolvedByAdminInput[]
    createMany?: MissedCheckoutCreateManyResolvedByAdminInputEnvelope
    set?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    disconnect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    delete?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    update?: MissedCheckoutUpdateWithWhereUniqueWithoutResolvedByAdminInput | MissedCheckoutUpdateWithWhereUniqueWithoutResolvedByAdminInput[]
    updateMany?: MissedCheckoutUpdateManyWithWhereWithoutResolvedByAdminInput | MissedCheckoutUpdateManyWithWhereWithoutResolvedByAdminInput[]
    deleteMany?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
  }

  export type AdminUserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUserUpsertWithoutAuditLogsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutAuditLogsInput, AdminUserUpdateWithoutAuditLogsInput>, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CheckinCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type EventAttendeeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EventCheckinCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutBadgeInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutBadgeInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type BadgeStatusCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeStatusCreateOrConnectWithoutBadgesInput
    connect?: BadgeStatusWhereUniqueInput
  }

  export type CheckinUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EventCheckinUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type CheckinUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutBadgeInput | CheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutBadgeInput | CheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutBadgeInput | CheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type EventAttendeeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput | EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput | EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutBadgeInput | EventAttendeeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type EventCheckinUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutBadgeInput | EventCheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutBadgeInput | EventCheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutBadgeInput | EventCheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBadgeInput | MemberUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBadgeInput | MemberUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBadgeInput | MemberUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutBadgeInput | VisitorUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutBadgeInput | VisitorUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutBadgeInput | VisitorUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeStatusUpdateOneWithoutBadgesNestedInput = {
    create?: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeStatusCreateOrConnectWithoutBadgesInput
    upsert?: BadgeStatusUpsertWithoutBadgesInput
    disconnect?: BadgeStatusWhereInput | boolean
    delete?: BadgeStatusWhereInput | boolean
    connect?: BadgeStatusWhereUniqueInput
    update?: XOR<XOR<BadgeStatusUpdateToOneWithWhereWithoutBadgesInput, BadgeStatusUpdateWithoutBadgesInput>, BadgeStatusUncheckedUpdateWithoutBadgesInput>
  }

  export type CheckinUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutBadgeInput | CheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutBadgeInput | CheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutBadgeInput | CheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput | EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput | EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutBadgeInput | EventAttendeeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutBadgeInput | EventCheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutBadgeInput | EventCheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutBadgeInput | EventCheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBadgeInput | MemberUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBadgeInput | MemberUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBadgeInput | MemberUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutBadgeInput | VisitorUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutBadgeInput | VisitorUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutBadgeInput | VisitorUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCheckinsInput
    connect?: BadgeWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutCheckinsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheckinsInput
    connect?: MemberWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BadgeUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCheckinsInput
    upsert?: BadgeUpsertWithoutCheckinsInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutCheckinsInput, BadgeUpdateWithoutCheckinsInput>, BadgeUncheckedUpdateWithoutCheckinsInput>
  }

  export type AdminUserUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutCheckinsInput
    upsert?: AdminUserUpsertWithoutCheckinsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutCheckinsInput, AdminUserUpdateWithoutCheckinsInput>, AdminUserUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheckinsInput
    upsert?: MemberUpsertWithoutCheckinsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCheckinsInput, MemberUpdateWithoutCheckinsInput>, MemberUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberCreateNestedManyWithoutDivisionInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutDivisionInput | MemberUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutDivisionInput | MemberUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutDivisionInput | MemberUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutDivisionInput | MemberUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutDivisionInput | MemberUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutDivisionInput | MemberUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutEventAttendeesInput = {
    create?: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventAttendeesInput
    connect?: BadgeWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutEventAttendeesInput = {
    create?: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventAttendeesInput
    connect?: EventWhereUniqueInput
  }

  export type EventCheckinCreateNestedManyWithoutEventAttendeeInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type BadgeUpdateOneWithoutEventAttendeesNestedInput = {
    create?: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventAttendeesInput
    upsert?: BadgeUpsertWithoutEventAttendeesInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutEventAttendeesInput, BadgeUpdateWithoutEventAttendeesInput>, BadgeUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventUpdateOneRequiredWithoutEventAttendeesNestedInput = {
    create?: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventAttendeesInput
    upsert?: EventUpsertWithoutEventAttendeesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventAttendeesInput, EventUpdateWithoutEventAttendeesInput>, EventUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventCheckinUpdateManyWithoutEventAttendeeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput | EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput | EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutEventCheckinsInput = {
    create?: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventCheckinsInput
    connect?: BadgeWhereUniqueInput
  }

  export type EventAttendeeCreateNestedOneWithoutEventCheckinsInput = {
    create?: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventCheckinsInput
    connect?: EventAttendeeWhereUniqueInput
  }

  export type BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput = {
    create?: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventCheckinsInput
    upsert?: BadgeUpsertWithoutEventCheckinsInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutEventCheckinsInput, BadgeUpdateWithoutEventCheckinsInput>, BadgeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventCheckinsInput
    upsert?: EventAttendeeUpsertWithoutEventCheckinsInput
    connect?: EventAttendeeWhereUniqueInput
    update?: XOR<XOR<EventAttendeeUpdateToOneWithWhereWithoutEventCheckinsInput, EventAttendeeUpdateWithoutEventCheckinsInput>, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutEventInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type EventAttendeeUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutEventNestedInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutEventInput | VisitorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutEventInput | VisitorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutEventInput | VisitorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutEventInput | VisitorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutEventInput | VisitorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutEventInput | VisitorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type RankCreateNestedOneWithoutMembersInput = {
    create?: XOR<RankCreateWithoutMembersInput, RankUncheckedCreateWithoutMembersInput>
    connectOrCreate?: RankCreateOrConnectWithoutMembersInput
    connect?: RankWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutMembersInput = {
    create?: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutMembersInput
    connect?: BadgeWhereUniqueInput
  }

  export type BmqEnrollmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type CheckinCreateNestedManyWithoutMemberInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type DivisionCreateNestedOneWithoutMembersInput = {
    create?: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutMembersInput
    connect?: DivisionWhereUniqueInput
  }

  export type VisitorCreateNestedManyWithoutHostMemberInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type MemberTagCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type MemberTypeCreateNestedOneWithoutMembersInput = {
    create?: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberTypeCreateOrConnectWithoutMembersInput
    connect?: MemberTypeWhereUniqueInput
  }

  export type MemberStatusCreateNestedOneWithoutMembersInput = {
    create?: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberStatusCreateOrConnectWithoutMembersInput
    connect?: MemberStatusWhereUniqueInput
  }

  export type MemberQualificationCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput> | MemberQualificationCreateWithoutMemberInput[] | MemberQualificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutMemberInput | MemberQualificationCreateOrConnectWithoutMemberInput[]
    createMany?: MemberQualificationCreateManyMemberInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type ScheduleAssignmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput> | ScheduleAssignmentCreateWithoutMemberInput[] | ScheduleAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutMemberInput | ScheduleAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: ScheduleAssignmentCreateManyMemberInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type LockupStatusCreateNestedManyWithoutCurrentHolderInput = {
    create?: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput> | LockupStatusCreateWithoutCurrentHolderInput[] | LockupStatusUncheckedCreateWithoutCurrentHolderInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutCurrentHolderInput | LockupStatusCreateOrConnectWithoutCurrentHolderInput[]
    createMany?: LockupStatusCreateManyCurrentHolderInputEnvelope
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
  }

  export type LockupStatusCreateNestedManyWithoutSecuredByMemberInput = {
    create?: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput> | LockupStatusCreateWithoutSecuredByMemberInput[] | LockupStatusUncheckedCreateWithoutSecuredByMemberInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutSecuredByMemberInput | LockupStatusCreateOrConnectWithoutSecuredByMemberInput[]
    createMany?: LockupStatusCreateManySecuredByMemberInputEnvelope
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
  }

  export type LockupTransferCreateNestedManyWithoutFromMemberInput = {
    create?: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput> | LockupTransferCreateWithoutFromMemberInput[] | LockupTransferUncheckedCreateWithoutFromMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutFromMemberInput | LockupTransferCreateOrConnectWithoutFromMemberInput[]
    createMany?: LockupTransferCreateManyFromMemberInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupTransferCreateNestedManyWithoutToMemberInput = {
    create?: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput> | LockupTransferCreateWithoutToMemberInput[] | LockupTransferUncheckedCreateWithoutToMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutToMemberInput | LockupTransferCreateOrConnectWithoutToMemberInput[]
    createMany?: LockupTransferCreateManyToMemberInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupExecutionCreateNestedManyWithoutExecutedByMemberInput = {
    create?: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput> | LockupExecutionCreateWithoutExecutedByMemberInput[] | LockupExecutionUncheckedCreateWithoutExecutedByMemberInput[]
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutExecutedByMemberInput | LockupExecutionCreateOrConnectWithoutExecutedByMemberInput[]
    createMany?: LockupExecutionCreateManyExecutedByMemberInputEnvelope
    connect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
  }

  export type MissedCheckoutCreateNestedManyWithoutMemberInput = {
    create?: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput> | MissedCheckoutCreateWithoutMemberInput[] | MissedCheckoutUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutMemberInput | MissedCheckoutCreateOrConnectWithoutMemberInput[]
    createMany?: MissedCheckoutCreateManyMemberInputEnvelope
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
  }

  export type UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput> | UnitEventDutyAssignmentCreateWithoutMemberInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput | UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: UnitEventDutyAssignmentCreateManyMemberInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type CheckinUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutHostMemberInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type MemberTagUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type MemberQualificationUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput> | MemberQualificationCreateWithoutMemberInput[] | MemberQualificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutMemberInput | MemberQualificationCreateOrConnectWithoutMemberInput[]
    createMany?: MemberQualificationCreateManyMemberInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput> | ScheduleAssignmentCreateWithoutMemberInput[] | ScheduleAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutMemberInput | ScheduleAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: ScheduleAssignmentCreateManyMemberInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput = {
    create?: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput> | LockupStatusCreateWithoutCurrentHolderInput[] | LockupStatusUncheckedCreateWithoutCurrentHolderInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutCurrentHolderInput | LockupStatusCreateOrConnectWithoutCurrentHolderInput[]
    createMany?: LockupStatusCreateManyCurrentHolderInputEnvelope
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
  }

  export type LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput = {
    create?: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput> | LockupStatusCreateWithoutSecuredByMemberInput[] | LockupStatusUncheckedCreateWithoutSecuredByMemberInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutSecuredByMemberInput | LockupStatusCreateOrConnectWithoutSecuredByMemberInput[]
    createMany?: LockupStatusCreateManySecuredByMemberInputEnvelope
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
  }

  export type LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput = {
    create?: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput> | LockupTransferCreateWithoutFromMemberInput[] | LockupTransferUncheckedCreateWithoutFromMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutFromMemberInput | LockupTransferCreateOrConnectWithoutFromMemberInput[]
    createMany?: LockupTransferCreateManyFromMemberInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupTransferUncheckedCreateNestedManyWithoutToMemberInput = {
    create?: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput> | LockupTransferCreateWithoutToMemberInput[] | LockupTransferUncheckedCreateWithoutToMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutToMemberInput | LockupTransferCreateOrConnectWithoutToMemberInput[]
    createMany?: LockupTransferCreateManyToMemberInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput = {
    create?: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput> | LockupExecutionCreateWithoutExecutedByMemberInput[] | LockupExecutionUncheckedCreateWithoutExecutedByMemberInput[]
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutExecutedByMemberInput | LockupExecutionCreateOrConnectWithoutExecutedByMemberInput[]
    createMany?: LockupExecutionCreateManyExecutedByMemberInputEnvelope
    connect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
  }

  export type MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput> | MissedCheckoutCreateWithoutMemberInput[] | MissedCheckoutUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutMemberInput | MissedCheckoutCreateOrConnectWithoutMemberInput[]
    createMany?: MissedCheckoutCreateManyMemberInputEnvelope
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
  }

  export type UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput> | UnitEventDutyAssignmentCreateWithoutMemberInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput | UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: UnitEventDutyAssignmentCreateManyMemberInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RankUpdateOneWithoutMembersNestedInput = {
    create?: XOR<RankCreateWithoutMembersInput, RankUncheckedCreateWithoutMembersInput>
    connectOrCreate?: RankCreateOrConnectWithoutMembersInput
    upsert?: RankUpsertWithoutMembersInput
    disconnect?: RankWhereInput | boolean
    delete?: RankWhereInput | boolean
    connect?: RankWhereUniqueInput
    update?: XOR<XOR<RankUpdateToOneWithWhereWithoutMembersInput, RankUpdateWithoutMembersInput>, RankUncheckedUpdateWithoutMembersInput>
  }

  export type BadgeUpdateOneWithoutMembersNestedInput = {
    create?: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutMembersInput
    upsert?: BadgeUpsertWithoutMembersInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutMembersInput, BadgeUpdateWithoutMembersInput>, BadgeUncheckedUpdateWithoutMembersInput>
  }

  export type BmqEnrollmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutMemberInput | BmqEnrollmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type CheckinUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutMemberInput | CheckinUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutMemberInput | CheckinUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutMemberInput | CheckinUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type DivisionUpdateOneWithoutMembersNestedInput = {
    create?: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutMembersInput
    upsert?: DivisionUpsertWithoutMembersInput
    disconnect?: DivisionWhereInput | boolean
    delete?: DivisionWhereInput | boolean
    connect?: DivisionWhereUniqueInput
    update?: XOR<XOR<DivisionUpdateToOneWithWhereWithoutMembersInput, DivisionUpdateWithoutMembersInput>, DivisionUncheckedUpdateWithoutMembersInput>
  }

  export type VisitorUpdateManyWithoutHostMemberNestedInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutHostMemberInput | VisitorUpsertWithWhereUniqueWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutHostMemberInput | VisitorUpdateWithWhereUniqueWithoutHostMemberInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutHostMemberInput | VisitorUpdateManyWithWhereWithoutHostMemberInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type MemberTagUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutMemberInput | MemberTagUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutMemberInput | MemberTagUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutMemberInput | MemberTagUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutMemberInput | DdsAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput | DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type MemberTypeUpdateOneWithoutMembersNestedInput = {
    create?: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberTypeCreateOrConnectWithoutMembersInput
    upsert?: MemberTypeUpsertWithoutMembersInput
    disconnect?: MemberTypeWhereInput | boolean
    delete?: MemberTypeWhereInput | boolean
    connect?: MemberTypeWhereUniqueInput
    update?: XOR<XOR<MemberTypeUpdateToOneWithWhereWithoutMembersInput, MemberTypeUpdateWithoutMembersInput>, MemberTypeUncheckedUpdateWithoutMembersInput>
  }

  export type MemberStatusUpdateOneWithoutMembersNestedInput = {
    create?: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberStatusCreateOrConnectWithoutMembersInput
    upsert?: MemberStatusUpsertWithoutMembersInput
    disconnect?: MemberStatusWhereInput | boolean
    delete?: MemberStatusWhereInput | boolean
    connect?: MemberStatusWhereUniqueInput
    update?: XOR<XOR<MemberStatusUpdateToOneWithWhereWithoutMembersInput, MemberStatusUpdateWithoutMembersInput>, MemberStatusUncheckedUpdateWithoutMembersInput>
  }

  export type MemberQualificationUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput> | MemberQualificationCreateWithoutMemberInput[] | MemberQualificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutMemberInput | MemberQualificationCreateOrConnectWithoutMemberInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutMemberInput | MemberQualificationUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberQualificationCreateManyMemberInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutMemberInput | MemberQualificationUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutMemberInput | MemberQualificationUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type ScheduleAssignmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput> | ScheduleAssignmentCreateWithoutMemberInput[] | ScheduleAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutMemberInput | ScheduleAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutMemberInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ScheduleAssignmentCreateManyMemberInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutMemberInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutMemberInput | ScheduleAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type LockupStatusUpdateManyWithoutCurrentHolderNestedInput = {
    create?: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput> | LockupStatusCreateWithoutCurrentHolderInput[] | LockupStatusUncheckedCreateWithoutCurrentHolderInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutCurrentHolderInput | LockupStatusCreateOrConnectWithoutCurrentHolderInput[]
    upsert?: LockupStatusUpsertWithWhereUniqueWithoutCurrentHolderInput | LockupStatusUpsertWithWhereUniqueWithoutCurrentHolderInput[]
    createMany?: LockupStatusCreateManyCurrentHolderInputEnvelope
    set?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    disconnect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    delete?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    update?: LockupStatusUpdateWithWhereUniqueWithoutCurrentHolderInput | LockupStatusUpdateWithWhereUniqueWithoutCurrentHolderInput[]
    updateMany?: LockupStatusUpdateManyWithWhereWithoutCurrentHolderInput | LockupStatusUpdateManyWithWhereWithoutCurrentHolderInput[]
    deleteMany?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
  }

  export type LockupStatusUpdateManyWithoutSecuredByMemberNestedInput = {
    create?: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput> | LockupStatusCreateWithoutSecuredByMemberInput[] | LockupStatusUncheckedCreateWithoutSecuredByMemberInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutSecuredByMemberInput | LockupStatusCreateOrConnectWithoutSecuredByMemberInput[]
    upsert?: LockupStatusUpsertWithWhereUniqueWithoutSecuredByMemberInput | LockupStatusUpsertWithWhereUniqueWithoutSecuredByMemberInput[]
    createMany?: LockupStatusCreateManySecuredByMemberInputEnvelope
    set?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    disconnect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    delete?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    update?: LockupStatusUpdateWithWhereUniqueWithoutSecuredByMemberInput | LockupStatusUpdateWithWhereUniqueWithoutSecuredByMemberInput[]
    updateMany?: LockupStatusUpdateManyWithWhereWithoutSecuredByMemberInput | LockupStatusUpdateManyWithWhereWithoutSecuredByMemberInput[]
    deleteMany?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
  }

  export type LockupTransferUpdateManyWithoutFromMemberNestedInput = {
    create?: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput> | LockupTransferCreateWithoutFromMemberInput[] | LockupTransferUncheckedCreateWithoutFromMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutFromMemberInput | LockupTransferCreateOrConnectWithoutFromMemberInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutFromMemberInput | LockupTransferUpsertWithWhereUniqueWithoutFromMemberInput[]
    createMany?: LockupTransferCreateManyFromMemberInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutFromMemberInput | LockupTransferUpdateWithWhereUniqueWithoutFromMemberInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutFromMemberInput | LockupTransferUpdateManyWithWhereWithoutFromMemberInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupTransferUpdateManyWithoutToMemberNestedInput = {
    create?: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput> | LockupTransferCreateWithoutToMemberInput[] | LockupTransferUncheckedCreateWithoutToMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutToMemberInput | LockupTransferCreateOrConnectWithoutToMemberInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutToMemberInput | LockupTransferUpsertWithWhereUniqueWithoutToMemberInput[]
    createMany?: LockupTransferCreateManyToMemberInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutToMemberInput | LockupTransferUpdateWithWhereUniqueWithoutToMemberInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutToMemberInput | LockupTransferUpdateManyWithWhereWithoutToMemberInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput = {
    create?: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput> | LockupExecutionCreateWithoutExecutedByMemberInput[] | LockupExecutionUncheckedCreateWithoutExecutedByMemberInput[]
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutExecutedByMemberInput | LockupExecutionCreateOrConnectWithoutExecutedByMemberInput[]
    upsert?: LockupExecutionUpsertWithWhereUniqueWithoutExecutedByMemberInput | LockupExecutionUpsertWithWhereUniqueWithoutExecutedByMemberInput[]
    createMany?: LockupExecutionCreateManyExecutedByMemberInputEnvelope
    set?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    disconnect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    delete?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    connect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    update?: LockupExecutionUpdateWithWhereUniqueWithoutExecutedByMemberInput | LockupExecutionUpdateWithWhereUniqueWithoutExecutedByMemberInput[]
    updateMany?: LockupExecutionUpdateManyWithWhereWithoutExecutedByMemberInput | LockupExecutionUpdateManyWithWhereWithoutExecutedByMemberInput[]
    deleteMany?: LockupExecutionScalarWhereInput | LockupExecutionScalarWhereInput[]
  }

  export type MissedCheckoutUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput> | MissedCheckoutCreateWithoutMemberInput[] | MissedCheckoutUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutMemberInput | MissedCheckoutCreateOrConnectWithoutMemberInput[]
    upsert?: MissedCheckoutUpsertWithWhereUniqueWithoutMemberInput | MissedCheckoutUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MissedCheckoutCreateManyMemberInputEnvelope
    set?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    disconnect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    delete?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    update?: MissedCheckoutUpdateWithWhereUniqueWithoutMemberInput | MissedCheckoutUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MissedCheckoutUpdateManyWithWhereWithoutMemberInput | MissedCheckoutUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
  }

  export type UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput> | UnitEventDutyAssignmentCreateWithoutMemberInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput | UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutMemberInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: UnitEventDutyAssignmentCreateManyMemberInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutMemberInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutMemberInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutMemberInput | BmqEnrollmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type CheckinUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutMemberInput | CheckinUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutMemberInput | CheckinUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutMemberInput | CheckinUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutHostMemberNestedInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutHostMemberInput | VisitorUpsertWithWhereUniqueWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutHostMemberInput | VisitorUpdateWithWhereUniqueWithoutHostMemberInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutHostMemberInput | VisitorUpdateManyWithWhereWithoutHostMemberInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type MemberTagUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutMemberInput | MemberTagUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutMemberInput | MemberTagUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutMemberInput | MemberTagUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutMemberInput | DdsAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput | DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput> | MemberQualificationCreateWithoutMemberInput[] | MemberQualificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutMemberInput | MemberQualificationCreateOrConnectWithoutMemberInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutMemberInput | MemberQualificationUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberQualificationCreateManyMemberInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutMemberInput | MemberQualificationUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutMemberInput | MemberQualificationUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput> | ScheduleAssignmentCreateWithoutMemberInput[] | ScheduleAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutMemberInput | ScheduleAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutMemberInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ScheduleAssignmentCreateManyMemberInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutMemberInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutMemberInput | ScheduleAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput = {
    create?: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput> | LockupStatusCreateWithoutCurrentHolderInput[] | LockupStatusUncheckedCreateWithoutCurrentHolderInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutCurrentHolderInput | LockupStatusCreateOrConnectWithoutCurrentHolderInput[]
    upsert?: LockupStatusUpsertWithWhereUniqueWithoutCurrentHolderInput | LockupStatusUpsertWithWhereUniqueWithoutCurrentHolderInput[]
    createMany?: LockupStatusCreateManyCurrentHolderInputEnvelope
    set?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    disconnect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    delete?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    update?: LockupStatusUpdateWithWhereUniqueWithoutCurrentHolderInput | LockupStatusUpdateWithWhereUniqueWithoutCurrentHolderInput[]
    updateMany?: LockupStatusUpdateManyWithWhereWithoutCurrentHolderInput | LockupStatusUpdateManyWithWhereWithoutCurrentHolderInput[]
    deleteMany?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
  }

  export type LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput = {
    create?: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput> | LockupStatusCreateWithoutSecuredByMemberInput[] | LockupStatusUncheckedCreateWithoutSecuredByMemberInput[]
    connectOrCreate?: LockupStatusCreateOrConnectWithoutSecuredByMemberInput | LockupStatusCreateOrConnectWithoutSecuredByMemberInput[]
    upsert?: LockupStatusUpsertWithWhereUniqueWithoutSecuredByMemberInput | LockupStatusUpsertWithWhereUniqueWithoutSecuredByMemberInput[]
    createMany?: LockupStatusCreateManySecuredByMemberInputEnvelope
    set?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    disconnect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    delete?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    connect?: LockupStatusWhereUniqueInput | LockupStatusWhereUniqueInput[]
    update?: LockupStatusUpdateWithWhereUniqueWithoutSecuredByMemberInput | LockupStatusUpdateWithWhereUniqueWithoutSecuredByMemberInput[]
    updateMany?: LockupStatusUpdateManyWithWhereWithoutSecuredByMemberInput | LockupStatusUpdateManyWithWhereWithoutSecuredByMemberInput[]
    deleteMany?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
  }

  export type LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput = {
    create?: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput> | LockupTransferCreateWithoutFromMemberInput[] | LockupTransferUncheckedCreateWithoutFromMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutFromMemberInput | LockupTransferCreateOrConnectWithoutFromMemberInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutFromMemberInput | LockupTransferUpsertWithWhereUniqueWithoutFromMemberInput[]
    createMany?: LockupTransferCreateManyFromMemberInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutFromMemberInput | LockupTransferUpdateWithWhereUniqueWithoutFromMemberInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutFromMemberInput | LockupTransferUpdateManyWithWhereWithoutFromMemberInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput = {
    create?: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput> | LockupTransferCreateWithoutToMemberInput[] | LockupTransferUncheckedCreateWithoutToMemberInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutToMemberInput | LockupTransferCreateOrConnectWithoutToMemberInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutToMemberInput | LockupTransferUpsertWithWhereUniqueWithoutToMemberInput[]
    createMany?: LockupTransferCreateManyToMemberInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutToMemberInput | LockupTransferUpdateWithWhereUniqueWithoutToMemberInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutToMemberInput | LockupTransferUpdateManyWithWhereWithoutToMemberInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput = {
    create?: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput> | LockupExecutionCreateWithoutExecutedByMemberInput[] | LockupExecutionUncheckedCreateWithoutExecutedByMemberInput[]
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutExecutedByMemberInput | LockupExecutionCreateOrConnectWithoutExecutedByMemberInput[]
    upsert?: LockupExecutionUpsertWithWhereUniqueWithoutExecutedByMemberInput | LockupExecutionUpsertWithWhereUniqueWithoutExecutedByMemberInput[]
    createMany?: LockupExecutionCreateManyExecutedByMemberInputEnvelope
    set?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    disconnect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    delete?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    connect?: LockupExecutionWhereUniqueInput | LockupExecutionWhereUniqueInput[]
    update?: LockupExecutionUpdateWithWhereUniqueWithoutExecutedByMemberInput | LockupExecutionUpdateWithWhereUniqueWithoutExecutedByMemberInput[]
    updateMany?: LockupExecutionUpdateManyWithWhereWithoutExecutedByMemberInput | LockupExecutionUpdateManyWithWhereWithoutExecutedByMemberInput[]
    deleteMany?: LockupExecutionScalarWhereInput | LockupExecutionScalarWhereInput[]
  }

  export type MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput> | MissedCheckoutCreateWithoutMemberInput[] | MissedCheckoutUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MissedCheckoutCreateOrConnectWithoutMemberInput | MissedCheckoutCreateOrConnectWithoutMemberInput[]
    upsert?: MissedCheckoutUpsertWithWhereUniqueWithoutMemberInput | MissedCheckoutUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MissedCheckoutCreateManyMemberInputEnvelope
    set?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    disconnect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    delete?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    connect?: MissedCheckoutWhereUniqueInput | MissedCheckoutWhereUniqueInput[]
    update?: MissedCheckoutUpdateWithWhereUniqueWithoutMemberInput | MissedCheckoutUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MissedCheckoutUpdateManyWithWhereWithoutMemberInput | MissedCheckoutUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput> | UnitEventDutyAssignmentCreateWithoutMemberInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput | UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutMemberInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: UnitEventDutyAssignmentCreateManyMemberInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutMemberInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutMemberInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type MemberTagCreateNestedManyWithoutTagInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type QualificationTypeCreateNestedManyWithoutTagInput = {
    create?: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput> | QualificationTypeCreateWithoutTagInput[] | QualificationTypeUncheckedCreateWithoutTagInput[]
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutTagInput | QualificationTypeCreateOrConnectWithoutTagInput[]
    createMany?: QualificationTypeCreateManyTagInputEnvelope
    connect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
  }

  export type MemberTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type QualificationTypeUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput> | QualificationTypeCreateWithoutTagInput[] | QualificationTypeUncheckedCreateWithoutTagInput[]
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutTagInput | QualificationTypeCreateOrConnectWithoutTagInput[]
    createMany?: QualificationTypeCreateManyTagInputEnvelope
    connect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
  }

  export type MemberTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutTagInput | MemberTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutTagInput | MemberTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutTagInput | MemberTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type QualificationTypeUpdateManyWithoutTagNestedInput = {
    create?: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput> | QualificationTypeCreateWithoutTagInput[] | QualificationTypeUncheckedCreateWithoutTagInput[]
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutTagInput | QualificationTypeCreateOrConnectWithoutTagInput[]
    upsert?: QualificationTypeUpsertWithWhereUniqueWithoutTagInput | QualificationTypeUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: QualificationTypeCreateManyTagInputEnvelope
    set?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    disconnect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    delete?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    connect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    update?: QualificationTypeUpdateWithWhereUniqueWithoutTagInput | QualificationTypeUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: QualificationTypeUpdateManyWithWhereWithoutTagInput | QualificationTypeUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: QualificationTypeScalarWhereInput | QualificationTypeScalarWhereInput[]
  }

  export type MemberTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutTagInput | MemberTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutTagInput | MemberTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutTagInput | MemberTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type QualificationTypeUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput> | QualificationTypeCreateWithoutTagInput[] | QualificationTypeUncheckedCreateWithoutTagInput[]
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutTagInput | QualificationTypeCreateOrConnectWithoutTagInput[]
    upsert?: QualificationTypeUpsertWithWhereUniqueWithoutTagInput | QualificationTypeUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: QualificationTypeCreateManyTagInputEnvelope
    set?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    disconnect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    delete?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    connect?: QualificationTypeWhereUniqueInput | QualificationTypeWhereUniqueInput[]
    update?: QualificationTypeUpdateWithWhereUniqueWithoutTagInput | QualificationTypeUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: QualificationTypeUpdateManyWithWhereWithoutTagInput | QualificationTypeUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: QualificationTypeScalarWhereInput | QualificationTypeScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutMemberTagsInput = {
    create?: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTagsInput
    connect?: MemberWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutMemberTagsInput = {
    create?: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMemberTagsInput
    connect?: TagWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberTagsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTagsInput
    upsert?: MemberUpsertWithoutMemberTagsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberTagsInput, MemberUpdateWithoutMemberTagsInput>, MemberUncheckedUpdateWithoutMemberTagsInput>
  }

  export type TagUpdateOneRequiredWithoutMemberTagsNestedInput = {
    create?: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMemberTagsInput
    upsert?: TagUpsertWithoutMemberTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutMemberTagsInput, TagUpdateWithoutMemberTagsInput>, TagUncheckedUpdateWithoutMemberTagsInput>
  }

  export type AdminUserCreateNestedOneWithoutSecurityAlertsInput = {
    create?: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSecurityAlertsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutSecurityAlertsNestedInput = {
    create?: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSecurityAlertsInput
    upsert?: AdminUserUpsertWithoutSecurityAlertsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutSecurityAlertsInput, AdminUserUpdateWithoutSecurityAlertsInput>, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type AdminUserCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutVisitorsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutVisitorsInput
    connect?: EventWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutVisitorsInput
    connect?: MemberWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutVisitorsInput
    connect?: BadgeWhereUniqueInput
  }

  export type VisitTypeCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutVisitorsInput
    connect?: VisitTypeWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutVisitorsInput
    upsert?: AdminUserUpsertWithoutVisitorsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutVisitorsInput, AdminUserUpdateWithoutVisitorsInput>, AdminUserUncheckedUpdateWithoutVisitorsInput>
  }

  export type EventUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutVisitorsInput
    upsert?: EventUpsertWithoutVisitorsInput
    disconnect?: EventWhereInput | boolean
    delete?: EventWhereInput | boolean
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutVisitorsInput, EventUpdateWithoutVisitorsInput>, EventUncheckedUpdateWithoutVisitorsInput>
  }

  export type MemberUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutVisitorsInput
    upsert?: MemberUpsertWithoutVisitorsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutVisitorsInput, MemberUpdateWithoutVisitorsInput>, MemberUncheckedUpdateWithoutVisitorsInput>
  }

  export type BadgeUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutVisitorsInput
    upsert?: BadgeUpsertWithoutVisitorsInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutVisitorsInput, BadgeUpdateWithoutVisitorsInput>, BadgeUncheckedUpdateWithoutVisitorsInput>
  }

  export type VisitTypeUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutVisitorsInput
    upsert?: VisitTypeUpsertWithoutVisitorsInput
    disconnect?: VisitTypeWhereInput | boolean
    delete?: VisitTypeWhereInput | boolean
    connect?: VisitTypeWhereUniqueInput
    update?: XOR<XOR<VisitTypeUpdateToOneWithWhereWithoutVisitorsInput, VisitTypeUpdateWithoutVisitorsInput>, VisitTypeUncheckedUpdateWithoutVisitorsInput>
  }

  export type BmqCourseCreatetrainingDaysInput = {
    set: string[]
  }

  export type BmqEnrollmentCreateNestedManyWithoutBmqCourseInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type BmqEnrollmentUncheckedCreateNestedManyWithoutBmqCourseInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type BmqCourseUpdatetrainingDaysInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BmqEnrollmentUpdateManyWithoutBmqCourseNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput | BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput | BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput = {
    create?: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput
    connect?: BmqCourseWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutBmqEnrollmentsInput = {
    create?: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBmqEnrollmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput = {
    create?: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput
    upsert?: BmqCourseUpsertWithoutBmqEnrollmentsInput
    connect?: BmqCourseWhereUniqueInput
    update?: XOR<XOR<BmqCourseUpdateToOneWithWhereWithoutBmqEnrollmentsInput, BmqCourseUpdateWithoutBmqEnrollmentsInput>, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput = {
    create?: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBmqEnrollmentsInput
    upsert?: MemberUpsertWithoutBmqEnrollmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutBmqEnrollmentsInput, MemberUpdateWithoutBmqEnrollmentsInput>, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type AdminUserCreateNestedOneWithoutReport_audit_logInput = {
    create?: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutReport_audit_logInput
    connect?: AdminUserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUserUpdateOneWithoutReport_audit_logNestedInput = {
    create?: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutReport_audit_logInput
    upsert?: AdminUserUpsertWithoutReport_audit_logInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutReport_audit_logInput, AdminUserUpdateWithoutReport_audit_logInput>, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
  }

  export type MemberCreateNestedOneWithoutDdsAssignmentsInput = {
    create?: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsAssignmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutDdsTransfersInput = {
    create?: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsTransfersInput
    connect?: MemberWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutDdsAssignmentsInput = {
    create?: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDdsAssignmentsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput = {
    create?: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsAssignmentsInput
    upsert?: MemberUpsertWithoutDdsAssignmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutDdsAssignmentsInput, MemberUpdateWithoutDdsAssignmentsInput>, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberUpdateOneWithoutDdsTransfersNestedInput = {
    create?: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsTransfersInput
    upsert?: MemberUpsertWithoutDdsTransfersInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutDdsTransfersInput, MemberUpdateWithoutDdsTransfersInput>, MemberUncheckedUpdateWithoutDdsTransfersInput>
  }

  export type AdminUserUpdateOneWithoutDdsAssignmentsNestedInput = {
    create?: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDdsAssignmentsInput
    upsert?: AdminUserUpsertWithoutDdsAssignmentsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutDdsAssignmentsInput, AdminUserUpdateWithoutDdsAssignmentsInput>, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberCreateNestedManyWithoutMemberStatusRefInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutMemberStatusRefInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutMemberStatusRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput | MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput | MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberStatusRefInput | MemberUpdateManyWithWhereWithoutMemberStatusRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutMemberStatusRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput | MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput | MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberStatusRefInput | MemberUpdateManyWithWhereWithoutMemberStatusRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberCreateNestedManyWithoutMemberTypeRefInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutMemberTypeRefInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutMemberTypeRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput | MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput | MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberTypeRefInput | MemberUpdateManyWithWhereWithoutMemberTypeRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutMemberTypeRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput | MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput | MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberTypeRefInput | MemberUpdateManyWithWhereWithoutMemberTypeRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorCreateNestedManyWithoutVisitTypeRefInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutVisitTypeRefInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type VisitorUpdateManyWithoutVisitTypeRefNestedInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutVisitTypeRefInput | VisitorUpdateManyWithWhereWithoutVisitTypeRefInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutVisitTypeRefNestedInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutVisitTypeRefInput | VisitorUpdateManyWithWhereWithoutVisitTypeRefInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeCreateNestedManyWithoutBadgeStatusRefInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutBadgeStatusRefInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUpdateManyWithoutBadgeStatusRefNestedInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput | BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutBadgeStatusRefNestedInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput | BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type MemberCreateNestedManyWithoutRankRefInput = {
    create?: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput> | MemberCreateWithoutRankRefInput[] | MemberUncheckedCreateWithoutRankRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutRankRefInput | MemberCreateOrConnectWithoutRankRefInput[]
    createMany?: MemberCreateManyRankRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type RankCreateNestedOneWithoutReplacesRanksInput = {
    create?: XOR<RankCreateWithoutReplacesRanksInput, RankUncheckedCreateWithoutReplacesRanksInput>
    connectOrCreate?: RankCreateOrConnectWithoutReplacesRanksInput
    connect?: RankWhereUniqueInput
  }

  export type RankCreateNestedManyWithoutReplacedByRankInput = {
    create?: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput> | RankCreateWithoutReplacedByRankInput[] | RankUncheckedCreateWithoutReplacedByRankInput[]
    connectOrCreate?: RankCreateOrConnectWithoutReplacedByRankInput | RankCreateOrConnectWithoutReplacedByRankInput[]
    createMany?: RankCreateManyReplacedByRankInputEnvelope
    connect?: RankWhereUniqueInput | RankWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutRankRefInput = {
    create?: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput> | MemberCreateWithoutRankRefInput[] | MemberUncheckedCreateWithoutRankRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutRankRefInput | MemberCreateOrConnectWithoutRankRefInput[]
    createMany?: MemberCreateManyRankRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type RankUncheckedCreateNestedManyWithoutReplacedByRankInput = {
    create?: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput> | RankCreateWithoutReplacedByRankInput[] | RankUncheckedCreateWithoutReplacedByRankInput[]
    connectOrCreate?: RankCreateOrConnectWithoutReplacedByRankInput | RankCreateOrConnectWithoutReplacedByRankInput[]
    createMany?: RankCreateManyReplacedByRankInputEnvelope
    connect?: RankWhereUniqueInput | RankWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutRankRefNestedInput = {
    create?: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput> | MemberCreateWithoutRankRefInput[] | MemberUncheckedCreateWithoutRankRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutRankRefInput | MemberCreateOrConnectWithoutRankRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutRankRefInput | MemberUpsertWithWhereUniqueWithoutRankRefInput[]
    createMany?: MemberCreateManyRankRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutRankRefInput | MemberUpdateWithWhereUniqueWithoutRankRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutRankRefInput | MemberUpdateManyWithWhereWithoutRankRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type RankUpdateOneWithoutReplacesRanksNestedInput = {
    create?: XOR<RankCreateWithoutReplacesRanksInput, RankUncheckedCreateWithoutReplacesRanksInput>
    connectOrCreate?: RankCreateOrConnectWithoutReplacesRanksInput
    upsert?: RankUpsertWithoutReplacesRanksInput
    disconnect?: RankWhereInput | boolean
    delete?: RankWhereInput | boolean
    connect?: RankWhereUniqueInput
    update?: XOR<XOR<RankUpdateToOneWithWhereWithoutReplacesRanksInput, RankUpdateWithoutReplacesRanksInput>, RankUncheckedUpdateWithoutReplacesRanksInput>
  }

  export type RankUpdateManyWithoutReplacedByRankNestedInput = {
    create?: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput> | RankCreateWithoutReplacedByRankInput[] | RankUncheckedCreateWithoutReplacedByRankInput[]
    connectOrCreate?: RankCreateOrConnectWithoutReplacedByRankInput | RankCreateOrConnectWithoutReplacedByRankInput[]
    upsert?: RankUpsertWithWhereUniqueWithoutReplacedByRankInput | RankUpsertWithWhereUniqueWithoutReplacedByRankInput[]
    createMany?: RankCreateManyReplacedByRankInputEnvelope
    set?: RankWhereUniqueInput | RankWhereUniqueInput[]
    disconnect?: RankWhereUniqueInput | RankWhereUniqueInput[]
    delete?: RankWhereUniqueInput | RankWhereUniqueInput[]
    connect?: RankWhereUniqueInput | RankWhereUniqueInput[]
    update?: RankUpdateWithWhereUniqueWithoutReplacedByRankInput | RankUpdateWithWhereUniqueWithoutReplacedByRankInput[]
    updateMany?: RankUpdateManyWithWhereWithoutReplacedByRankInput | RankUpdateManyWithWhereWithoutReplacedByRankInput[]
    deleteMany?: RankScalarWhereInput | RankScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutRankRefNestedInput = {
    create?: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput> | MemberCreateWithoutRankRefInput[] | MemberUncheckedCreateWithoutRankRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutRankRefInput | MemberCreateOrConnectWithoutRankRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutRankRefInput | MemberUpsertWithWhereUniqueWithoutRankRefInput[]
    createMany?: MemberCreateManyRankRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutRankRefInput | MemberUpdateWithWhereUniqueWithoutRankRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutRankRefInput | MemberUpdateManyWithWhereWithoutRankRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type RankUncheckedUpdateManyWithoutReplacedByRankNestedInput = {
    create?: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput> | RankCreateWithoutReplacedByRankInput[] | RankUncheckedCreateWithoutReplacedByRankInput[]
    connectOrCreate?: RankCreateOrConnectWithoutReplacedByRankInput | RankCreateOrConnectWithoutReplacedByRankInput[]
    upsert?: RankUpsertWithWhereUniqueWithoutReplacedByRankInput | RankUpsertWithWhereUniqueWithoutReplacedByRankInput[]
    createMany?: RankCreateManyReplacedByRankInputEnvelope
    set?: RankWhereUniqueInput | RankWhereUniqueInput[]
    disconnect?: RankWhereUniqueInput | RankWhereUniqueInput[]
    delete?: RankWhereUniqueInput | RankWhereUniqueInput[]
    connect?: RankWhereUniqueInput | RankWhereUniqueInput[]
    update?: RankUpdateWithWhereUniqueWithoutReplacedByRankInput | RankUpdateWithWhereUniqueWithoutReplacedByRankInput[]
    updateMany?: RankUpdateManyWithWhereWithoutReplacedByRankInput | RankUpdateManyWithWhereWithoutReplacedByRankInput[]
    deleteMany?: RankScalarWhereInput | RankScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type MemberQualificationCreateNestedManyWithoutQualificationTypeInput = {
    create?: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput> | MemberQualificationCreateWithoutQualificationTypeInput[] | MemberQualificationUncheckedCreateWithoutQualificationTypeInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutQualificationTypeInput | MemberQualificationCreateOrConnectWithoutQualificationTypeInput[]
    createMany?: MemberQualificationCreateManyQualificationTypeInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type TagCreateNestedOneWithoutQualificationTypesInput = {
    create?: XOR<TagCreateWithoutQualificationTypesInput, TagUncheckedCreateWithoutQualificationTypesInput>
    connectOrCreate?: TagCreateOrConnectWithoutQualificationTypesInput
    connect?: TagWhereUniqueInput
  }

  export type MemberQualificationUncheckedCreateNestedManyWithoutQualificationTypeInput = {
    create?: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput> | MemberQualificationCreateWithoutQualificationTypeInput[] | MemberQualificationUncheckedCreateWithoutQualificationTypeInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutQualificationTypeInput | MemberQualificationCreateOrConnectWithoutQualificationTypeInput[]
    createMany?: MemberQualificationCreateManyQualificationTypeInputEnvelope
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
  }

  export type MemberQualificationUpdateManyWithoutQualificationTypeNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput> | MemberQualificationCreateWithoutQualificationTypeInput[] | MemberQualificationUncheckedCreateWithoutQualificationTypeInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutQualificationTypeInput | MemberQualificationCreateOrConnectWithoutQualificationTypeInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutQualificationTypeInput | MemberQualificationUpsertWithWhereUniqueWithoutQualificationTypeInput[]
    createMany?: MemberQualificationCreateManyQualificationTypeInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutQualificationTypeInput | MemberQualificationUpdateWithWhereUniqueWithoutQualificationTypeInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutQualificationTypeInput | MemberQualificationUpdateManyWithWhereWithoutQualificationTypeInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type TagUpdateOneWithoutQualificationTypesNestedInput = {
    create?: XOR<TagCreateWithoutQualificationTypesInput, TagUncheckedCreateWithoutQualificationTypesInput>
    connectOrCreate?: TagCreateOrConnectWithoutQualificationTypesInput
    upsert?: TagUpsertWithoutQualificationTypesInput
    disconnect?: TagWhereInput | boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutQualificationTypesInput, TagUpdateWithoutQualificationTypesInput>, TagUncheckedUpdateWithoutQualificationTypesInput>
  }

  export type MemberQualificationUncheckedUpdateManyWithoutQualificationTypeNestedInput = {
    create?: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput> | MemberQualificationCreateWithoutQualificationTypeInput[] | MemberQualificationUncheckedCreateWithoutQualificationTypeInput[]
    connectOrCreate?: MemberQualificationCreateOrConnectWithoutQualificationTypeInput | MemberQualificationCreateOrConnectWithoutQualificationTypeInput[]
    upsert?: MemberQualificationUpsertWithWhereUniqueWithoutQualificationTypeInput | MemberQualificationUpsertWithWhereUniqueWithoutQualificationTypeInput[]
    createMany?: MemberQualificationCreateManyQualificationTypeInputEnvelope
    set?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    disconnect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    delete?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    connect?: MemberQualificationWhereUniqueInput | MemberQualificationWhereUniqueInput[]
    update?: MemberQualificationUpdateWithWhereUniqueWithoutQualificationTypeInput | MemberQualificationUpdateWithWhereUniqueWithoutQualificationTypeInput[]
    updateMany?: MemberQualificationUpdateManyWithWhereWithoutQualificationTypeInput | MemberQualificationUpdateManyWithWhereWithoutQualificationTypeInput[]
    deleteMany?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutQualificationsInput = {
    create?: XOR<MemberCreateWithoutQualificationsInput, MemberUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutQualificationsInput
    connect?: MemberWhereUniqueInput
  }

  export type QualificationTypeCreateNestedOneWithoutMemberQualificationsInput = {
    create?: XOR<QualificationTypeCreateWithoutMemberQualificationsInput, QualificationTypeUncheckedCreateWithoutMemberQualificationsInput>
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutMemberQualificationsInput
    connect?: QualificationTypeWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutQualificationsGrantedInput = {
    create?: XOR<AdminUserCreateWithoutQualificationsGrantedInput, AdminUserUncheckedCreateWithoutQualificationsGrantedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutQualificationsGrantedInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutQualificationsRevokedInput = {
    create?: XOR<AdminUserCreateWithoutQualificationsRevokedInput, AdminUserUncheckedCreateWithoutQualificationsRevokedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutQualificationsRevokedInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutQualificationsNestedInput = {
    create?: XOR<MemberCreateWithoutQualificationsInput, MemberUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutQualificationsInput
    upsert?: MemberUpsertWithoutQualificationsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutQualificationsInput, MemberUpdateWithoutQualificationsInput>, MemberUncheckedUpdateWithoutQualificationsInput>
  }

  export type QualificationTypeUpdateOneRequiredWithoutMemberQualificationsNestedInput = {
    create?: XOR<QualificationTypeCreateWithoutMemberQualificationsInput, QualificationTypeUncheckedCreateWithoutMemberQualificationsInput>
    connectOrCreate?: QualificationTypeCreateOrConnectWithoutMemberQualificationsInput
    upsert?: QualificationTypeUpsertWithoutMemberQualificationsInput
    connect?: QualificationTypeWhereUniqueInput
    update?: XOR<XOR<QualificationTypeUpdateToOneWithWhereWithoutMemberQualificationsInput, QualificationTypeUpdateWithoutMemberQualificationsInput>, QualificationTypeUncheckedUpdateWithoutMemberQualificationsInput>
  }

  export type AdminUserUpdateOneWithoutQualificationsGrantedNestedInput = {
    create?: XOR<AdminUserCreateWithoutQualificationsGrantedInput, AdminUserUncheckedCreateWithoutQualificationsGrantedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutQualificationsGrantedInput
    upsert?: AdminUserUpsertWithoutQualificationsGrantedInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutQualificationsGrantedInput, AdminUserUpdateWithoutQualificationsGrantedInput>, AdminUserUncheckedUpdateWithoutQualificationsGrantedInput>
  }

  export type AdminUserUpdateOneWithoutQualificationsRevokedNestedInput = {
    create?: XOR<AdminUserCreateWithoutQualificationsRevokedInput, AdminUserUncheckedCreateWithoutQualificationsRevokedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutQualificationsRevokedInput
    upsert?: AdminUserUpsertWithoutQualificationsRevokedInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutQualificationsRevokedInput, AdminUserUpdateWithoutQualificationsRevokedInput>, AdminUserUncheckedUpdateWithoutQualificationsRevokedInput>
  }

  export type DutyRoleCreateactiveDaysInput = {
    set: number[]
  }

  export type DutyPositionCreateNestedManyWithoutDutyRoleInput = {
    create?: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput> | DutyPositionCreateWithoutDutyRoleInput[] | DutyPositionUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: DutyPositionCreateOrConnectWithoutDutyRoleInput | DutyPositionCreateOrConnectWithoutDutyRoleInput[]
    createMany?: DutyPositionCreateManyDutyRoleInputEnvelope
    connect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
  }

  export type WeeklyScheduleCreateNestedManyWithoutDutyRoleInput = {
    create?: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput> | WeeklyScheduleCreateWithoutDutyRoleInput[] | WeeklyScheduleUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutDutyRoleInput | WeeklyScheduleCreateOrConnectWithoutDutyRoleInput[]
    createMany?: WeeklyScheduleCreateManyDutyRoleInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type DutyPositionUncheckedCreateNestedManyWithoutDutyRoleInput = {
    create?: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput> | DutyPositionCreateWithoutDutyRoleInput[] | DutyPositionUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: DutyPositionCreateOrConnectWithoutDutyRoleInput | DutyPositionCreateOrConnectWithoutDutyRoleInput[]
    createMany?: DutyPositionCreateManyDutyRoleInputEnvelope
    connect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
  }

  export type WeeklyScheduleUncheckedCreateNestedManyWithoutDutyRoleInput = {
    create?: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput> | WeeklyScheduleCreateWithoutDutyRoleInput[] | WeeklyScheduleUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutDutyRoleInput | WeeklyScheduleCreateOrConnectWithoutDutyRoleInput[]
    createMany?: WeeklyScheduleCreateManyDutyRoleInputEnvelope
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
  }

  export type DutyRoleUpdateactiveDaysInput = {
    set?: number[]
    push?: number | number[]
  }

  export type DutyPositionUpdateManyWithoutDutyRoleNestedInput = {
    create?: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput> | DutyPositionCreateWithoutDutyRoleInput[] | DutyPositionUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: DutyPositionCreateOrConnectWithoutDutyRoleInput | DutyPositionCreateOrConnectWithoutDutyRoleInput[]
    upsert?: DutyPositionUpsertWithWhereUniqueWithoutDutyRoleInput | DutyPositionUpsertWithWhereUniqueWithoutDutyRoleInput[]
    createMany?: DutyPositionCreateManyDutyRoleInputEnvelope
    set?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    disconnect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    delete?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    connect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    update?: DutyPositionUpdateWithWhereUniqueWithoutDutyRoleInput | DutyPositionUpdateWithWhereUniqueWithoutDutyRoleInput[]
    updateMany?: DutyPositionUpdateManyWithWhereWithoutDutyRoleInput | DutyPositionUpdateManyWithWhereWithoutDutyRoleInput[]
    deleteMany?: DutyPositionScalarWhereInput | DutyPositionScalarWhereInput[]
  }

  export type WeeklyScheduleUpdateManyWithoutDutyRoleNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput> | WeeklyScheduleCreateWithoutDutyRoleInput[] | WeeklyScheduleUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutDutyRoleInput | WeeklyScheduleCreateOrConnectWithoutDutyRoleInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutDutyRoleInput | WeeklyScheduleUpsertWithWhereUniqueWithoutDutyRoleInput[]
    createMany?: WeeklyScheduleCreateManyDutyRoleInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutDutyRoleInput | WeeklyScheduleUpdateWithWhereUniqueWithoutDutyRoleInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutDutyRoleInput | WeeklyScheduleUpdateManyWithWhereWithoutDutyRoleInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type DutyPositionUncheckedUpdateManyWithoutDutyRoleNestedInput = {
    create?: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput> | DutyPositionCreateWithoutDutyRoleInput[] | DutyPositionUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: DutyPositionCreateOrConnectWithoutDutyRoleInput | DutyPositionCreateOrConnectWithoutDutyRoleInput[]
    upsert?: DutyPositionUpsertWithWhereUniqueWithoutDutyRoleInput | DutyPositionUpsertWithWhereUniqueWithoutDutyRoleInput[]
    createMany?: DutyPositionCreateManyDutyRoleInputEnvelope
    set?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    disconnect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    delete?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    connect?: DutyPositionWhereUniqueInput | DutyPositionWhereUniqueInput[]
    update?: DutyPositionUpdateWithWhereUniqueWithoutDutyRoleInput | DutyPositionUpdateWithWhereUniqueWithoutDutyRoleInput[]
    updateMany?: DutyPositionUpdateManyWithWhereWithoutDutyRoleInput | DutyPositionUpdateManyWithWhereWithoutDutyRoleInput[]
    deleteMany?: DutyPositionScalarWhereInput | DutyPositionScalarWhereInput[]
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutDutyRoleNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput> | WeeklyScheduleCreateWithoutDutyRoleInput[] | WeeklyScheduleUncheckedCreateWithoutDutyRoleInput[]
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutDutyRoleInput | WeeklyScheduleCreateOrConnectWithoutDutyRoleInput[]
    upsert?: WeeklyScheduleUpsertWithWhereUniqueWithoutDutyRoleInput | WeeklyScheduleUpsertWithWhereUniqueWithoutDutyRoleInput[]
    createMany?: WeeklyScheduleCreateManyDutyRoleInputEnvelope
    set?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    disconnect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    delete?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    connect?: WeeklyScheduleWhereUniqueInput | WeeklyScheduleWhereUniqueInput[]
    update?: WeeklyScheduleUpdateWithWhereUniqueWithoutDutyRoleInput | WeeklyScheduleUpdateWithWhereUniqueWithoutDutyRoleInput[]
    updateMany?: WeeklyScheduleUpdateManyWithWhereWithoutDutyRoleInput | WeeklyScheduleUpdateManyWithWhereWithoutDutyRoleInput[]
    deleteMany?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
  }

  export type DutyRoleCreateNestedOneWithoutPositionsInput = {
    create?: XOR<DutyRoleCreateWithoutPositionsInput, DutyRoleUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DutyRoleCreateOrConnectWithoutPositionsInput
    connect?: DutyRoleWhereUniqueInput
  }

  export type ScheduleAssignmentCreateNestedManyWithoutDutyPositionInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput> | ScheduleAssignmentCreateWithoutDutyPositionInput[] | ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput | ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput[]
    createMany?: ScheduleAssignmentCreateManyDutyPositionInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type ScheduleAssignmentUncheckedCreateNestedManyWithoutDutyPositionInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput> | ScheduleAssignmentCreateWithoutDutyPositionInput[] | ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput | ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput[]
    createMany?: ScheduleAssignmentCreateManyDutyPositionInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type DutyRoleUpdateOneRequiredWithoutPositionsNestedInput = {
    create?: XOR<DutyRoleCreateWithoutPositionsInput, DutyRoleUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DutyRoleCreateOrConnectWithoutPositionsInput
    upsert?: DutyRoleUpsertWithoutPositionsInput
    connect?: DutyRoleWhereUniqueInput
    update?: XOR<XOR<DutyRoleUpdateToOneWithWhereWithoutPositionsInput, DutyRoleUpdateWithoutPositionsInput>, DutyRoleUncheckedUpdateWithoutPositionsInput>
  }

  export type ScheduleAssignmentUpdateManyWithoutDutyPositionNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput> | ScheduleAssignmentCreateWithoutDutyPositionInput[] | ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput | ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutDutyPositionInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutDutyPositionInput[]
    createMany?: ScheduleAssignmentCreateManyDutyPositionInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutDutyPositionInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutDutyPositionInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutDutyPositionInput | ScheduleAssignmentUpdateManyWithWhereWithoutDutyPositionInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutDutyPositionNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput> | ScheduleAssignmentCreateWithoutDutyPositionInput[] | ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput | ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutDutyPositionInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutDutyPositionInput[]
    createMany?: ScheduleAssignmentCreateManyDutyPositionInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutDutyPositionInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutDutyPositionInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutDutyPositionInput | ScheduleAssignmentUpdateManyWithWhereWithoutDutyPositionInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type DutyRoleCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<DutyRoleCreateWithoutSchedulesInput, DutyRoleUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: DutyRoleCreateOrConnectWithoutSchedulesInput
    connect?: DutyRoleWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutSchedulesCreatedInput = {
    create?: XOR<AdminUserCreateWithoutSchedulesCreatedInput, AdminUserUncheckedCreateWithoutSchedulesCreatedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSchedulesCreatedInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutSchedulesPublishedInput = {
    create?: XOR<AdminUserCreateWithoutSchedulesPublishedInput, AdminUserUncheckedCreateWithoutSchedulesPublishedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSchedulesPublishedInput
    connect?: AdminUserWhereUniqueInput
  }

  export type ScheduleAssignmentCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput> | ScheduleAssignmentCreateWithoutScheduleInput[] | ScheduleAssignmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutScheduleInput | ScheduleAssignmentCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleAssignmentCreateManyScheduleInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type ScheduleAssignmentUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput> | ScheduleAssignmentCreateWithoutScheduleInput[] | ScheduleAssignmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutScheduleInput | ScheduleAssignmentCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleAssignmentCreateManyScheduleInputEnvelope
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
  }

  export type DutyRoleUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<DutyRoleCreateWithoutSchedulesInput, DutyRoleUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: DutyRoleCreateOrConnectWithoutSchedulesInput
    upsert?: DutyRoleUpsertWithoutSchedulesInput
    connect?: DutyRoleWhereUniqueInput
    update?: XOR<XOR<DutyRoleUpdateToOneWithWhereWithoutSchedulesInput, DutyRoleUpdateWithoutSchedulesInput>, DutyRoleUncheckedUpdateWithoutSchedulesInput>
  }

  export type AdminUserUpdateOneWithoutSchedulesCreatedNestedInput = {
    create?: XOR<AdminUserCreateWithoutSchedulesCreatedInput, AdminUserUncheckedCreateWithoutSchedulesCreatedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSchedulesCreatedInput
    upsert?: AdminUserUpsertWithoutSchedulesCreatedInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutSchedulesCreatedInput, AdminUserUpdateWithoutSchedulesCreatedInput>, AdminUserUncheckedUpdateWithoutSchedulesCreatedInput>
  }

  export type AdminUserUpdateOneWithoutSchedulesPublishedNestedInput = {
    create?: XOR<AdminUserCreateWithoutSchedulesPublishedInput, AdminUserUncheckedCreateWithoutSchedulesPublishedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSchedulesPublishedInput
    upsert?: AdminUserUpsertWithoutSchedulesPublishedInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutSchedulesPublishedInput, AdminUserUpdateWithoutSchedulesPublishedInput>, AdminUserUncheckedUpdateWithoutSchedulesPublishedInput>
  }

  export type ScheduleAssignmentUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput> | ScheduleAssignmentCreateWithoutScheduleInput[] | ScheduleAssignmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutScheduleInput | ScheduleAssignmentCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutScheduleInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleAssignmentCreateManyScheduleInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutScheduleInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutScheduleInput | ScheduleAssignmentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput> | ScheduleAssignmentCreateWithoutScheduleInput[] | ScheduleAssignmentUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAssignmentCreateOrConnectWithoutScheduleInput | ScheduleAssignmentCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleAssignmentUpsertWithWhereUniqueWithoutScheduleInput | ScheduleAssignmentUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleAssignmentCreateManyScheduleInputEnvelope
    set?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    disconnect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    delete?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    connect?: ScheduleAssignmentWhereUniqueInput | ScheduleAssignmentWhereUniqueInput[]
    update?: ScheduleAssignmentUpdateWithWhereUniqueWithoutScheduleInput | ScheduleAssignmentUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleAssignmentUpdateManyWithWhereWithoutScheduleInput | ScheduleAssignmentUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
  }

  export type WeeklyScheduleCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<WeeklyScheduleCreateWithoutAssignmentsInput, WeeklyScheduleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutAssignmentsInput
    connect?: WeeklyScheduleWhereUniqueInput
  }

  export type DutyPositionCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<DutyPositionCreateWithoutAssignmentsInput, DutyPositionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: DutyPositionCreateOrConnectWithoutAssignmentsInput
    connect?: DutyPositionWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutScheduleAssignmentsInput = {
    create?: XOR<MemberCreateWithoutScheduleAssignmentsInput, MemberUncheckedCreateWithoutScheduleAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutScheduleAssignmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type WeeklyScheduleUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<WeeklyScheduleCreateWithoutAssignmentsInput, WeeklyScheduleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WeeklyScheduleCreateOrConnectWithoutAssignmentsInput
    upsert?: WeeklyScheduleUpsertWithoutAssignmentsInput
    connect?: WeeklyScheduleWhereUniqueInput
    update?: XOR<XOR<WeeklyScheduleUpdateToOneWithWhereWithoutAssignmentsInput, WeeklyScheduleUpdateWithoutAssignmentsInput>, WeeklyScheduleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type DutyPositionUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<DutyPositionCreateWithoutAssignmentsInput, DutyPositionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: DutyPositionCreateOrConnectWithoutAssignmentsInput
    upsert?: DutyPositionUpsertWithoutAssignmentsInput
    disconnect?: DutyPositionWhereInput | boolean
    delete?: DutyPositionWhereInput | boolean
    connect?: DutyPositionWhereUniqueInput
    update?: XOR<XOR<DutyPositionUpdateToOneWithWhereWithoutAssignmentsInput, DutyPositionUpdateWithoutAssignmentsInput>, DutyPositionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type MemberUpdateOneRequiredWithoutScheduleAssignmentsNestedInput = {
    create?: XOR<MemberCreateWithoutScheduleAssignmentsInput, MemberUncheckedCreateWithoutScheduleAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutScheduleAssignmentsInput
    upsert?: MemberUpsertWithoutScheduleAssignmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutScheduleAssignmentsInput, MemberUpdateWithoutScheduleAssignmentsInput>, MemberUncheckedUpdateWithoutScheduleAssignmentsInput>
  }

  export type MemberCreateNestedOneWithoutLockupHoldingInput = {
    create?: XOR<MemberCreateWithoutLockupHoldingInput, MemberUncheckedCreateWithoutLockupHoldingInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupHoldingInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutLockupSecuredInput = {
    create?: XOR<MemberCreateWithoutLockupSecuredInput, MemberUncheckedCreateWithoutLockupSecuredInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupSecuredInput
    connect?: MemberWhereUniqueInput
  }

  export type LockupTransferCreateNestedManyWithoutLockupStatusInput = {
    create?: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput> | LockupTransferCreateWithoutLockupStatusInput[] | LockupTransferUncheckedCreateWithoutLockupStatusInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutLockupStatusInput | LockupTransferCreateOrConnectWithoutLockupStatusInput[]
    createMany?: LockupTransferCreateManyLockupStatusInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupExecutionCreateNestedOneWithoutLockupStatusInput = {
    create?: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutLockupStatusInput
    connect?: LockupExecutionWhereUniqueInput
  }

  export type LockupTransferUncheckedCreateNestedManyWithoutLockupStatusInput = {
    create?: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput> | LockupTransferCreateWithoutLockupStatusInput[] | LockupTransferUncheckedCreateWithoutLockupStatusInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutLockupStatusInput | LockupTransferCreateOrConnectWithoutLockupStatusInput[]
    createMany?: LockupTransferCreateManyLockupStatusInputEnvelope
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
  }

  export type LockupExecutionUncheckedCreateNestedOneWithoutLockupStatusInput = {
    create?: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutLockupStatusInput
    connect?: LockupExecutionWhereUniqueInput
  }

  export type MemberUpdateOneWithoutLockupHoldingNestedInput = {
    create?: XOR<MemberCreateWithoutLockupHoldingInput, MemberUncheckedCreateWithoutLockupHoldingInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupHoldingInput
    upsert?: MemberUpsertWithoutLockupHoldingInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLockupHoldingInput, MemberUpdateWithoutLockupHoldingInput>, MemberUncheckedUpdateWithoutLockupHoldingInput>
  }

  export type MemberUpdateOneWithoutLockupSecuredNestedInput = {
    create?: XOR<MemberCreateWithoutLockupSecuredInput, MemberUncheckedCreateWithoutLockupSecuredInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupSecuredInput
    upsert?: MemberUpsertWithoutLockupSecuredInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLockupSecuredInput, MemberUpdateWithoutLockupSecuredInput>, MemberUncheckedUpdateWithoutLockupSecuredInput>
  }

  export type LockupTransferUpdateManyWithoutLockupStatusNestedInput = {
    create?: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput> | LockupTransferCreateWithoutLockupStatusInput[] | LockupTransferUncheckedCreateWithoutLockupStatusInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutLockupStatusInput | LockupTransferCreateOrConnectWithoutLockupStatusInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutLockupStatusInput | LockupTransferUpsertWithWhereUniqueWithoutLockupStatusInput[]
    createMany?: LockupTransferCreateManyLockupStatusInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutLockupStatusInput | LockupTransferUpdateWithWhereUniqueWithoutLockupStatusInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutLockupStatusInput | LockupTransferUpdateManyWithWhereWithoutLockupStatusInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupExecutionUpdateOneWithoutLockupStatusNestedInput = {
    create?: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutLockupStatusInput
    upsert?: LockupExecutionUpsertWithoutLockupStatusInput
    disconnect?: LockupExecutionWhereInput | boolean
    delete?: LockupExecutionWhereInput | boolean
    connect?: LockupExecutionWhereUniqueInput
    update?: XOR<XOR<LockupExecutionUpdateToOneWithWhereWithoutLockupStatusInput, LockupExecutionUpdateWithoutLockupStatusInput>, LockupExecutionUncheckedUpdateWithoutLockupStatusInput>
  }

  export type LockupTransferUncheckedUpdateManyWithoutLockupStatusNestedInput = {
    create?: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput> | LockupTransferCreateWithoutLockupStatusInput[] | LockupTransferUncheckedCreateWithoutLockupStatusInput[]
    connectOrCreate?: LockupTransferCreateOrConnectWithoutLockupStatusInput | LockupTransferCreateOrConnectWithoutLockupStatusInput[]
    upsert?: LockupTransferUpsertWithWhereUniqueWithoutLockupStatusInput | LockupTransferUpsertWithWhereUniqueWithoutLockupStatusInput[]
    createMany?: LockupTransferCreateManyLockupStatusInputEnvelope
    set?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    disconnect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    delete?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    connect?: LockupTransferWhereUniqueInput | LockupTransferWhereUniqueInput[]
    update?: LockupTransferUpdateWithWhereUniqueWithoutLockupStatusInput | LockupTransferUpdateWithWhereUniqueWithoutLockupStatusInput[]
    updateMany?: LockupTransferUpdateManyWithWhereWithoutLockupStatusInput | LockupTransferUpdateManyWithWhereWithoutLockupStatusInput[]
    deleteMany?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
  }

  export type LockupExecutionUncheckedUpdateOneWithoutLockupStatusNestedInput = {
    create?: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
    connectOrCreate?: LockupExecutionCreateOrConnectWithoutLockupStatusInput
    upsert?: LockupExecutionUpsertWithoutLockupStatusInput
    disconnect?: LockupExecutionWhereInput | boolean
    delete?: LockupExecutionWhereInput | boolean
    connect?: LockupExecutionWhereUniqueInput
    update?: XOR<XOR<LockupExecutionUpdateToOneWithWhereWithoutLockupStatusInput, LockupExecutionUpdateWithoutLockupStatusInput>, LockupExecutionUncheckedUpdateWithoutLockupStatusInput>
  }

  export type LockupStatusCreateNestedOneWithoutTransfersInput = {
    create?: XOR<LockupStatusCreateWithoutTransfersInput, LockupStatusUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LockupStatusCreateOrConnectWithoutTransfersInput
    connect?: LockupStatusWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutLockupTransfersFromInput = {
    create?: XOR<MemberCreateWithoutLockupTransfersFromInput, MemberUncheckedCreateWithoutLockupTransfersFromInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupTransfersFromInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutLockupTransfersToInput = {
    create?: XOR<MemberCreateWithoutLockupTransfersToInput, MemberUncheckedCreateWithoutLockupTransfersToInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupTransfersToInput
    connect?: MemberWhereUniqueInput
  }

  export type LockupStatusUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<LockupStatusCreateWithoutTransfersInput, LockupStatusUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LockupStatusCreateOrConnectWithoutTransfersInput
    upsert?: LockupStatusUpsertWithoutTransfersInput
    connect?: LockupStatusWhereUniqueInput
    update?: XOR<XOR<LockupStatusUpdateToOneWithWhereWithoutTransfersInput, LockupStatusUpdateWithoutTransfersInput>, LockupStatusUncheckedUpdateWithoutTransfersInput>
  }

  export type MemberUpdateOneRequiredWithoutLockupTransfersFromNestedInput = {
    create?: XOR<MemberCreateWithoutLockupTransfersFromInput, MemberUncheckedCreateWithoutLockupTransfersFromInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupTransfersFromInput
    upsert?: MemberUpsertWithoutLockupTransfersFromInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLockupTransfersFromInput, MemberUpdateWithoutLockupTransfersFromInput>, MemberUncheckedUpdateWithoutLockupTransfersFromInput>
  }

  export type MemberUpdateOneRequiredWithoutLockupTransfersToNestedInput = {
    create?: XOR<MemberCreateWithoutLockupTransfersToInput, MemberUncheckedCreateWithoutLockupTransfersToInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupTransfersToInput
    upsert?: MemberUpsertWithoutLockupTransfersToInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLockupTransfersToInput, MemberUpdateWithoutLockupTransfersToInput>, MemberUncheckedUpdateWithoutLockupTransfersToInput>
  }

  export type LockupStatusCreateNestedOneWithoutExecutionInput = {
    create?: XOR<LockupStatusCreateWithoutExecutionInput, LockupStatusUncheckedCreateWithoutExecutionInput>
    connectOrCreate?: LockupStatusCreateOrConnectWithoutExecutionInput
    connect?: LockupStatusWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutLockupExecutionsInput = {
    create?: XOR<MemberCreateWithoutLockupExecutionsInput, MemberUncheckedCreateWithoutLockupExecutionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupExecutionsInput
    connect?: MemberWhereUniqueInput
  }

  export type LockupStatusUpdateOneRequiredWithoutExecutionNestedInput = {
    create?: XOR<LockupStatusCreateWithoutExecutionInput, LockupStatusUncheckedCreateWithoutExecutionInput>
    connectOrCreate?: LockupStatusCreateOrConnectWithoutExecutionInput
    upsert?: LockupStatusUpsertWithoutExecutionInput
    connect?: LockupStatusWhereUniqueInput
    update?: XOR<XOR<LockupStatusUpdateToOneWithWhereWithoutExecutionInput, LockupStatusUpdateWithoutExecutionInput>, LockupStatusUncheckedUpdateWithoutExecutionInput>
  }

  export type MemberUpdateOneRequiredWithoutLockupExecutionsNestedInput = {
    create?: XOR<MemberCreateWithoutLockupExecutionsInput, MemberUncheckedCreateWithoutLockupExecutionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLockupExecutionsInput
    upsert?: MemberUpsertWithoutLockupExecutionsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLockupExecutionsInput, MemberUpdateWithoutLockupExecutionsInput>, MemberUncheckedUpdateWithoutLockupExecutionsInput>
  }

  export type MemberCreateNestedOneWithoutMissedCheckoutsInput = {
    create?: XOR<MemberCreateWithoutMissedCheckoutsInput, MemberUncheckedCreateWithoutMissedCheckoutsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMissedCheckoutsInput
    connect?: MemberWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutMissedCheckoutsResolvedInput = {
    create?: XOR<AdminUserCreateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedCreateWithoutMissedCheckoutsResolvedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutMissedCheckoutsResolvedInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMissedCheckoutsNestedInput = {
    create?: XOR<MemberCreateWithoutMissedCheckoutsInput, MemberUncheckedCreateWithoutMissedCheckoutsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMissedCheckoutsInput
    upsert?: MemberUpsertWithoutMissedCheckoutsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMissedCheckoutsInput, MemberUpdateWithoutMissedCheckoutsInput>, MemberUncheckedUpdateWithoutMissedCheckoutsInput>
  }

  export type AdminUserUpdateOneWithoutMissedCheckoutsResolvedNestedInput = {
    create?: XOR<AdminUserCreateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedCreateWithoutMissedCheckoutsResolvedInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutMissedCheckoutsResolvedInput
    upsert?: AdminUserUpsertWithoutMissedCheckoutsResolvedInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutMissedCheckoutsResolvedInput, AdminUserUpdateWithoutMissedCheckoutsResolvedInput>, AdminUserUncheckedUpdateWithoutMissedCheckoutsResolvedInput>
  }

  export type UnitEventCreateNestedManyWithoutEventTypeInput = {
    create?: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput> | UnitEventCreateWithoutEventTypeInput[] | UnitEventUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: UnitEventCreateOrConnectWithoutEventTypeInput | UnitEventCreateOrConnectWithoutEventTypeInput[]
    createMany?: UnitEventCreateManyEventTypeInputEnvelope
    connect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
  }

  export type UnitEventUncheckedCreateNestedManyWithoutEventTypeInput = {
    create?: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput> | UnitEventCreateWithoutEventTypeInput[] | UnitEventUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: UnitEventCreateOrConnectWithoutEventTypeInput | UnitEventCreateOrConnectWithoutEventTypeInput[]
    createMany?: UnitEventCreateManyEventTypeInputEnvelope
    connect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
  }

  export type UnitEventUpdateManyWithoutEventTypeNestedInput = {
    create?: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput> | UnitEventCreateWithoutEventTypeInput[] | UnitEventUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: UnitEventCreateOrConnectWithoutEventTypeInput | UnitEventCreateOrConnectWithoutEventTypeInput[]
    upsert?: UnitEventUpsertWithWhereUniqueWithoutEventTypeInput | UnitEventUpsertWithWhereUniqueWithoutEventTypeInput[]
    createMany?: UnitEventCreateManyEventTypeInputEnvelope
    set?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    disconnect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    delete?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    connect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    update?: UnitEventUpdateWithWhereUniqueWithoutEventTypeInput | UnitEventUpdateWithWhereUniqueWithoutEventTypeInput[]
    updateMany?: UnitEventUpdateManyWithWhereWithoutEventTypeInput | UnitEventUpdateManyWithWhereWithoutEventTypeInput[]
    deleteMany?: UnitEventScalarWhereInput | UnitEventScalarWhereInput[]
  }

  export type UnitEventUncheckedUpdateManyWithoutEventTypeNestedInput = {
    create?: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput> | UnitEventCreateWithoutEventTypeInput[] | UnitEventUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: UnitEventCreateOrConnectWithoutEventTypeInput | UnitEventCreateOrConnectWithoutEventTypeInput[]
    upsert?: UnitEventUpsertWithWhereUniqueWithoutEventTypeInput | UnitEventUpsertWithWhereUniqueWithoutEventTypeInput[]
    createMany?: UnitEventCreateManyEventTypeInputEnvelope
    set?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    disconnect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    delete?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    connect?: UnitEventWhereUniqueInput | UnitEventWhereUniqueInput[]
    update?: UnitEventUpdateWithWhereUniqueWithoutEventTypeInput | UnitEventUpdateWithWhereUniqueWithoutEventTypeInput[]
    updateMany?: UnitEventUpdateManyWithWhereWithoutEventTypeInput | UnitEventUpdateManyWithWhereWithoutEventTypeInput[]
    deleteMany?: UnitEventScalarWhereInput | UnitEventScalarWhereInput[]
  }

  export type UnitEventTypeCreateNestedOneWithoutUnitEventsInput = {
    create?: XOR<UnitEventTypeCreateWithoutUnitEventsInput, UnitEventTypeUncheckedCreateWithoutUnitEventsInput>
    connectOrCreate?: UnitEventTypeCreateOrConnectWithoutUnitEventsInput
    connect?: UnitEventTypeWhereUniqueInput
  }

  export type UnitEventDutyPositionCreateNestedManyWithoutEventInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput> | UnitEventDutyPositionCreateWithoutEventInput[] | UnitEventDutyPositionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutEventInput | UnitEventDutyPositionCreateOrConnectWithoutEventInput[]
    createMany?: UnitEventDutyPositionCreateManyEventInputEnvelope
    connect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
  }

  export type UnitEventDutyAssignmentCreateNestedManyWithoutEventInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput> | UnitEventDutyAssignmentCreateWithoutEventInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type UnitEventDutyPositionUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput> | UnitEventDutyPositionCreateWithoutEventInput[] | UnitEventDutyPositionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutEventInput | UnitEventDutyPositionCreateOrConnectWithoutEventInput[]
    createMany?: UnitEventDutyPositionCreateManyEventInputEnvelope
    connect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
  }

  export type UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput> | UnitEventDutyAssignmentCreateWithoutEventInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type UnitEventTypeUpdateOneWithoutUnitEventsNestedInput = {
    create?: XOR<UnitEventTypeCreateWithoutUnitEventsInput, UnitEventTypeUncheckedCreateWithoutUnitEventsInput>
    connectOrCreate?: UnitEventTypeCreateOrConnectWithoutUnitEventsInput
    upsert?: UnitEventTypeUpsertWithoutUnitEventsInput
    disconnect?: UnitEventTypeWhereInput | boolean
    delete?: UnitEventTypeWhereInput | boolean
    connect?: UnitEventTypeWhereUniqueInput
    update?: XOR<XOR<UnitEventTypeUpdateToOneWithWhereWithoutUnitEventsInput, UnitEventTypeUpdateWithoutUnitEventsInput>, UnitEventTypeUncheckedUpdateWithoutUnitEventsInput>
  }

  export type UnitEventDutyPositionUpdateManyWithoutEventNestedInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput> | UnitEventDutyPositionCreateWithoutEventInput[] | UnitEventDutyPositionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutEventInput | UnitEventDutyPositionCreateOrConnectWithoutEventInput[]
    upsert?: UnitEventDutyPositionUpsertWithWhereUniqueWithoutEventInput | UnitEventDutyPositionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: UnitEventDutyPositionCreateManyEventInputEnvelope
    set?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    disconnect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    delete?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    connect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    update?: UnitEventDutyPositionUpdateWithWhereUniqueWithoutEventInput | UnitEventDutyPositionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: UnitEventDutyPositionUpdateManyWithWhereWithoutEventInput | UnitEventDutyPositionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: UnitEventDutyPositionScalarWhereInput | UnitEventDutyPositionScalarWhereInput[]
  }

  export type UnitEventDutyAssignmentUpdateManyWithoutEventNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput> | UnitEventDutyAssignmentCreateWithoutEventInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type UnitEventDutyPositionUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput> | UnitEventDutyPositionCreateWithoutEventInput[] | UnitEventDutyPositionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutEventInput | UnitEventDutyPositionCreateOrConnectWithoutEventInput[]
    upsert?: UnitEventDutyPositionUpsertWithWhereUniqueWithoutEventInput | UnitEventDutyPositionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: UnitEventDutyPositionCreateManyEventInputEnvelope
    set?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    disconnect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    delete?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    connect?: UnitEventDutyPositionWhereUniqueInput | UnitEventDutyPositionWhereUniqueInput[]
    update?: UnitEventDutyPositionUpdateWithWhereUniqueWithoutEventInput | UnitEventDutyPositionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: UnitEventDutyPositionUpdateManyWithWhereWithoutEventInput | UnitEventDutyPositionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: UnitEventDutyPositionScalarWhereInput | UnitEventDutyPositionScalarWhereInput[]
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput> | UnitEventDutyAssignmentCreateWithoutEventInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type UnitEventCreateNestedOneWithoutDutyPositionsInput = {
    create?: XOR<UnitEventCreateWithoutDutyPositionsInput, UnitEventUncheckedCreateWithoutDutyPositionsInput>
    connectOrCreate?: UnitEventCreateOrConnectWithoutDutyPositionsInput
    connect?: UnitEventWhereUniqueInput
  }

  export type UnitEventDutyAssignmentCreateNestedManyWithoutEventDutyPositionInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput> | UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventDutyPositionInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventDutyPositionInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput> | UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventDutyPositionInputEnvelope
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
  }

  export type UnitEventUpdateOneRequiredWithoutDutyPositionsNestedInput = {
    create?: XOR<UnitEventCreateWithoutDutyPositionsInput, UnitEventUncheckedCreateWithoutDutyPositionsInput>
    connectOrCreate?: UnitEventCreateOrConnectWithoutDutyPositionsInput
    upsert?: UnitEventUpsertWithoutDutyPositionsInput
    connect?: UnitEventWhereUniqueInput
    update?: XOR<XOR<UnitEventUpdateToOneWithWhereWithoutDutyPositionsInput, UnitEventUpdateWithoutDutyPositionsInput>, UnitEventUncheckedUpdateWithoutDutyPositionsInput>
  }

  export type UnitEventDutyAssignmentUpdateManyWithoutEventDutyPositionNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput> | UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventDutyPositionInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventDutyPositionInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventDutyPositionInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventDutyPositionInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventDutyPositionNestedInput = {
    create?: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput> | UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput[] | UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput[]
    connectOrCreate?: UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput | UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput[]
    upsert?: UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventDutyPositionInput[]
    createMany?: UnitEventDutyAssignmentCreateManyEventDutyPositionInputEnvelope
    set?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    disconnect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    delete?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    connect?: UnitEventDutyAssignmentWhereUniqueInput | UnitEventDutyAssignmentWhereUniqueInput[]
    update?: UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventDutyPositionInput[]
    updateMany?: UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventDutyPositionInput | UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventDutyPositionInput[]
    deleteMany?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
  }

  export type UnitEventCreateNestedOneWithoutDutyAssignmentsInput = {
    create?: XOR<UnitEventCreateWithoutDutyAssignmentsInput, UnitEventUncheckedCreateWithoutDutyAssignmentsInput>
    connectOrCreate?: UnitEventCreateOrConnectWithoutDutyAssignmentsInput
    connect?: UnitEventWhereUniqueInput
  }

  export type UnitEventDutyPositionCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutAssignmentsInput
    connect?: UnitEventDutyPositionWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutUnitEventDutyAssignmentsInput = {
    create?: XOR<MemberCreateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedCreateWithoutUnitEventDutyAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUnitEventDutyAssignmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type UnitEventUpdateOneRequiredWithoutDutyAssignmentsNestedInput = {
    create?: XOR<UnitEventCreateWithoutDutyAssignmentsInput, UnitEventUncheckedCreateWithoutDutyAssignmentsInput>
    connectOrCreate?: UnitEventCreateOrConnectWithoutDutyAssignmentsInput
    upsert?: UnitEventUpsertWithoutDutyAssignmentsInput
    connect?: UnitEventWhereUniqueInput
    update?: XOR<XOR<UnitEventUpdateToOneWithWhereWithoutDutyAssignmentsInput, UnitEventUpdateWithoutDutyAssignmentsInput>, UnitEventUncheckedUpdateWithoutDutyAssignmentsInput>
  }

  export type UnitEventDutyPositionUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<UnitEventDutyPositionCreateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UnitEventDutyPositionCreateOrConnectWithoutAssignmentsInput
    upsert?: UnitEventDutyPositionUpsertWithoutAssignmentsInput
    disconnect?: UnitEventDutyPositionWhereInput | boolean
    delete?: UnitEventDutyPositionWhereInput | boolean
    connect?: UnitEventDutyPositionWhereUniqueInput
    update?: XOR<XOR<UnitEventDutyPositionUpdateToOneWithWhereWithoutAssignmentsInput, UnitEventDutyPositionUpdateWithoutAssignmentsInput>, UnitEventDutyPositionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type MemberUpdateOneRequiredWithoutUnitEventDutyAssignmentsNestedInput = {
    create?: XOR<MemberCreateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedCreateWithoutUnitEventDutyAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUnitEventDutyAssignmentsInput
    upsert?: MemberUpsertWithoutUnitEventDutyAssignmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutUnitEventDutyAssignmentsInput, MemberUpdateWithoutUnitEventDutyAssignmentsInput>, MemberUncheckedUpdateWithoutUnitEventDutyAssignmentsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AuditLogCreateWithoutAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUncheckedCreateWithoutAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogCreateOrConnectWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AuditLogCreateManyAdminUserInputEnvelope = {
    data: AuditLogCreateManyAdminUserInput | AuditLogCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type CheckinCreateWithoutAdmin_usersInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
  }

  export type CheckinCreateOrConnectWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput>
  }

  export type CheckinCreateManyAdmin_usersInputEnvelope = {
    data: CheckinCreateManyAdmin_usersInput | CheckinCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type report_audit_logCreateWithoutAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logCreateOrConnectWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    create: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput>
  }

  export type report_audit_logCreateManyAdmin_usersInputEnvelope = {
    data: report_audit_logCreateManyAdmin_usersInput | report_audit_logCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type SecurityAlertCreateWithoutAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    create: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope = {
    data: SecurityAlertCreateManyAcknowledgedByAdminInput | SecurityAlertCreateManyAcknowledgedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
  }

  export type VisitorCreateOrConnectWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput>
  }

  export type VisitorCreateManyAdmin_usersInputEnvelope = {
    data: VisitorCreateManyAdmin_usersInput | VisitorCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutAssignedByAdminInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
  }

  export type DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentCreateManyAssignedByAdminInputEnvelope = {
    data: DdsAssignmentCreateManyAssignedByAdminInput | DdsAssignmentCreateManyAssignedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserCreateWithoutDisabledUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDisabledUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDisabledUsersInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
  }

  export type AdminUserCreateWithoutUpdatedUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutUpdatedUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutUpdatedUsersInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
  }

  export type AdminUserCreateWithoutDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput>
  }

  export type AdminUserCreateManyDisabledByAdminInputEnvelope = {
    data: AdminUserCreateManyDisabledByAdminInput | AdminUserCreateManyDisabledByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserCreateWithoutUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput>
  }

  export type AdminUserCreateManyUpdatedByAdminInputEnvelope = {
    data: AdminUserCreateManyUpdatedByAdminInput | AdminUserCreateManyUpdatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type MemberQualificationCreateWithoutGrantedByAdminInput = {
    id?: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutQualificationsInput
    qualificationType: QualificationTypeCreateNestedOneWithoutMemberQualificationsInput
    revokedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsRevokedInput
  }

  export type MemberQualificationUncheckedCreateWithoutGrantedByAdminInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateOrConnectWithoutGrantedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    create: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput>
  }

  export type MemberQualificationCreateManyGrantedByAdminInputEnvelope = {
    data: MemberQualificationCreateManyGrantedByAdminInput | MemberQualificationCreateManyGrantedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type MemberQualificationCreateWithoutRevokedByAdminInput = {
    id?: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutQualificationsInput
    qualificationType: QualificationTypeCreateNestedOneWithoutMemberQualificationsInput
    grantedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsGrantedInput
  }

  export type MemberQualificationUncheckedCreateWithoutRevokedByAdminInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateOrConnectWithoutRevokedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    create: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput>
  }

  export type MemberQualificationCreateManyRevokedByAdminInputEnvelope = {
    data: MemberQualificationCreateManyRevokedByAdminInput | MemberQualificationCreateManyRevokedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyScheduleCreateWithoutCreatedByAdminInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutSchedulesInput
    publishedByAdmin?: AdminUserCreateNestedOneWithoutSchedulesPublishedInput
    assignments?: ScheduleAssignmentCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleCreateOrConnectWithoutCreatedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    create: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type WeeklyScheduleCreateManyCreatedByAdminInputEnvelope = {
    data: WeeklyScheduleCreateManyCreatedByAdminInput | WeeklyScheduleCreateManyCreatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyScheduleCreateWithoutPublishedByAdminInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutSchedulesInput
    createdByAdmin?: AdminUserCreateNestedOneWithoutSchedulesCreatedInput
    assignments?: ScheduleAssignmentCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleCreateOrConnectWithoutPublishedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    create: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput>
  }

  export type WeeklyScheduleCreateManyPublishedByAdminInputEnvelope = {
    data: WeeklyScheduleCreateManyPublishedByAdminInput | WeeklyScheduleCreateManyPublishedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type MissedCheckoutCreateWithoutResolvedByAdminInput = {
    id?: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    member: MemberCreateNestedOneWithoutMissedCheckoutsInput
  }

  export type MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput = {
    id?: string
    memberId: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MissedCheckoutCreateOrConnectWithoutResolvedByAdminInput = {
    where: MissedCheckoutWhereUniqueInput
    create: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput>
  }

  export type MissedCheckoutCreateManyResolvedByAdminInputEnvelope = {
    data: MissedCheckoutCreateManyResolvedByAdminInput | MissedCheckoutCreateManyResolvedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutAdminUserInput, AuditLogUncheckedUpdateWithoutAdminUserInput>
    create: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutAdminUserInput, AuditLogUncheckedUpdateWithoutAdminUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutAdminUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
  }

  export type CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutAdmin_usersInput, CheckinUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutAdmin_usersInput, CheckinUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type CheckinUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type CheckinScalarWhereInput = {
    AND?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
    OR?: CheckinScalarWhereInput[]
    NOT?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
    id?: UuidFilter<"Checkin"> | string
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
  }

  export type report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    update: XOR<report_audit_logUpdateWithoutAdmin_usersInput, report_audit_logUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput>
  }

  export type report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    data: XOR<report_audit_logUpdateWithoutAdmin_usersInput, report_audit_logUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: report_audit_logScalarWhereInput
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type report_audit_logScalarWhereInput = {
    AND?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
    OR?: report_audit_logScalarWhereInput[]
    NOT?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
    id?: UuidFilter<"report_audit_log"> | string
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
  }

  export type SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    update: XOR<SecurityAlertUpdateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput>
    create: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    data: XOR<SecurityAlertUpdateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertScalarWhereInput
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertScalarWhereInput = {
    AND?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    OR?: SecurityAlertScalarWhereInput[]
    NOT?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    id?: UuidFilter<"SecurityAlert"> | string
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
  }

  export type VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutAdmin_usersInput, VisitorUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutAdmin_usersInput, VisitorUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type VisitorUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type VisitorScalarWhereInput = {
    AND?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    OR?: VisitorScalarWhereInput[]
    NOT?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    id?: UuidFilter<"Visitor"> | string
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutAssignedByAdminInput, DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput>
    create: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutAssignedByAdminInput, DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentScalarWhereInput = {
    AND?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
    OR?: DdsAssignmentScalarWhereInput[]
    NOT?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
    id?: UuidFilter<"DdsAssignment"> | string
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
  }

  export type AdminUserUpsertWithoutDisabledUsersInput = {
    update: XOR<AdminUserUpdateWithoutDisabledUsersInput, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
    create: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutDisabledUsersInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutDisabledUsersInput, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
  }

  export type AdminUserUpdateWithoutDisabledUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDisabledUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUpsertWithoutUpdatedUsersInput = {
    update: XOR<AdminUserUpdateWithoutUpdatedUsersInput, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
    create: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutUpdatedUsersInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutUpdatedUsersInput, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type AdminUserUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    update: XOR<AdminUserUpdateWithoutDisabledByAdminInput, AdminUserUncheckedUpdateWithoutDisabledByAdminInput>
    create: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput>
  }

  export type AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    data: XOR<AdminUserUpdateWithoutDisabledByAdminInput, AdminUserUncheckedUpdateWithoutDisabledByAdminInput>
  }

  export type AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput = {
    where: AdminUserScalarWhereInput
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyWithoutDisabledByAdminInput>
  }

  export type AdminUserScalarWhereInput = {
    AND?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
    OR?: AdminUserScalarWhereInput[]
    NOT?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
    id?: UuidFilter<"AdminUser"> | string
    username?: StringFilter<"AdminUser"> | string
    email?: StringNullableFilter<"AdminUser"> | string | null
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
  }

  export type AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    update: XOR<AdminUserUpdateWithoutUpdatedByAdminInput, AdminUserUncheckedUpdateWithoutUpdatedByAdminInput>
    create: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput>
  }

  export type AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    data: XOR<AdminUserUpdateWithoutUpdatedByAdminInput, AdminUserUncheckedUpdateWithoutUpdatedByAdminInput>
  }

  export type AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput = {
    where: AdminUserScalarWhereInput
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyWithoutUpdatedByAdminInput>
  }

  export type MemberQualificationUpsertWithWhereUniqueWithoutGrantedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    update: XOR<MemberQualificationUpdateWithoutGrantedByAdminInput, MemberQualificationUncheckedUpdateWithoutGrantedByAdminInput>
    create: XOR<MemberQualificationCreateWithoutGrantedByAdminInput, MemberQualificationUncheckedCreateWithoutGrantedByAdminInput>
  }

  export type MemberQualificationUpdateWithWhereUniqueWithoutGrantedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    data: XOR<MemberQualificationUpdateWithoutGrantedByAdminInput, MemberQualificationUncheckedUpdateWithoutGrantedByAdminInput>
  }

  export type MemberQualificationUpdateManyWithWhereWithoutGrantedByAdminInput = {
    where: MemberQualificationScalarWhereInput
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminInput>
  }

  export type MemberQualificationScalarWhereInput = {
    AND?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
    OR?: MemberQualificationScalarWhereInput[]
    NOT?: MemberQualificationScalarWhereInput | MemberQualificationScalarWhereInput[]
    id?: UuidFilter<"MemberQualification"> | string
    memberId?: UuidFilter<"MemberQualification"> | string
    qualificationTypeId?: UuidFilter<"MemberQualification"> | string
    status?: StringFilter<"MemberQualification"> | string
    grantedAt?: DateTimeFilter<"MemberQualification"> | Date | string
    grantedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    expiresAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"MemberQualification"> | Date | string | null
    revokedBy?: UuidNullableFilter<"MemberQualification"> | string | null
    revokeReason?: StringNullableFilter<"MemberQualification"> | string | null
    notes?: StringNullableFilter<"MemberQualification"> | string | null
    createdAt?: DateTimeFilter<"MemberQualification"> | Date | string
    updatedAt?: DateTimeFilter<"MemberQualification"> | Date | string
  }

  export type MemberQualificationUpsertWithWhereUniqueWithoutRevokedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    update: XOR<MemberQualificationUpdateWithoutRevokedByAdminInput, MemberQualificationUncheckedUpdateWithoutRevokedByAdminInput>
    create: XOR<MemberQualificationCreateWithoutRevokedByAdminInput, MemberQualificationUncheckedCreateWithoutRevokedByAdminInput>
  }

  export type MemberQualificationUpdateWithWhereUniqueWithoutRevokedByAdminInput = {
    where: MemberQualificationWhereUniqueInput
    data: XOR<MemberQualificationUpdateWithoutRevokedByAdminInput, MemberQualificationUncheckedUpdateWithoutRevokedByAdminInput>
  }

  export type MemberQualificationUpdateManyWithWhereWithoutRevokedByAdminInput = {
    where: MemberQualificationScalarWhereInput
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminInput>
  }

  export type WeeklyScheduleUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    update: XOR<WeeklyScheduleUpdateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedUpdateWithoutCreatedByAdminInput>
    create: XOR<WeeklyScheduleCreateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type WeeklyScheduleUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    data: XOR<WeeklyScheduleUpdateWithoutCreatedByAdminInput, WeeklyScheduleUncheckedUpdateWithoutCreatedByAdminInput>
  }

  export type WeeklyScheduleUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: WeeklyScheduleScalarWhereInput
    data: XOR<WeeklyScheduleUpdateManyMutationInput, WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminInput>
  }

  export type WeeklyScheduleScalarWhereInput = {
    AND?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
    OR?: WeeklyScheduleScalarWhereInput[]
    NOT?: WeeklyScheduleScalarWhereInput | WeeklyScheduleScalarWhereInput[]
    id?: UuidFilter<"WeeklySchedule"> | string
    dutyRoleId?: UuidFilter<"WeeklySchedule"> | string
    weekStartDate?: DateTimeFilter<"WeeklySchedule"> | Date | string
    status?: StringFilter<"WeeklySchedule"> | string
    createdBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    publishedAt?: DateTimeNullableFilter<"WeeklySchedule"> | Date | string | null
    publishedBy?: UuidNullableFilter<"WeeklySchedule"> | string | null
    notes?: StringNullableFilter<"WeeklySchedule"> | string | null
    createdAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklySchedule"> | Date | string
  }

  export type WeeklyScheduleUpsertWithWhereUniqueWithoutPublishedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    update: XOR<WeeklyScheduleUpdateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedUpdateWithoutPublishedByAdminInput>
    create: XOR<WeeklyScheduleCreateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedCreateWithoutPublishedByAdminInput>
  }

  export type WeeklyScheduleUpdateWithWhereUniqueWithoutPublishedByAdminInput = {
    where: WeeklyScheduleWhereUniqueInput
    data: XOR<WeeklyScheduleUpdateWithoutPublishedByAdminInput, WeeklyScheduleUncheckedUpdateWithoutPublishedByAdminInput>
  }

  export type WeeklyScheduleUpdateManyWithWhereWithoutPublishedByAdminInput = {
    where: WeeklyScheduleScalarWhereInput
    data: XOR<WeeklyScheduleUpdateManyMutationInput, WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminInput>
  }

  export type MissedCheckoutUpsertWithWhereUniqueWithoutResolvedByAdminInput = {
    where: MissedCheckoutWhereUniqueInput
    update: XOR<MissedCheckoutUpdateWithoutResolvedByAdminInput, MissedCheckoutUncheckedUpdateWithoutResolvedByAdminInput>
    create: XOR<MissedCheckoutCreateWithoutResolvedByAdminInput, MissedCheckoutUncheckedCreateWithoutResolvedByAdminInput>
  }

  export type MissedCheckoutUpdateWithWhereUniqueWithoutResolvedByAdminInput = {
    where: MissedCheckoutWhereUniqueInput
    data: XOR<MissedCheckoutUpdateWithoutResolvedByAdminInput, MissedCheckoutUncheckedUpdateWithoutResolvedByAdminInput>
  }

  export type MissedCheckoutUpdateManyWithWhereWithoutResolvedByAdminInput = {
    where: MissedCheckoutScalarWhereInput
    data: XOR<MissedCheckoutUpdateManyMutationInput, MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminInput>
  }

  export type MissedCheckoutScalarWhereInput = {
    AND?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
    OR?: MissedCheckoutScalarWhereInput[]
    NOT?: MissedCheckoutScalarWhereInput | MissedCheckoutScalarWhereInput[]
    id?: UuidFilter<"MissedCheckout"> | string
    memberId?: UuidFilter<"MissedCheckout"> | string
    date?: DateTimeFilter<"MissedCheckout"> | Date | string
    originalCheckinAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    forcedCheckoutAt?: DateTimeFilter<"MissedCheckout"> | Date | string
    resolvedBy?: StringFilter<"MissedCheckout"> | string
    resolvedByAdminId?: UuidNullableFilter<"MissedCheckout"> | string | null
    lockupExecutionId?: UuidNullableFilter<"MissedCheckout"> | string | null
    notes?: StringNullableFilter<"MissedCheckout"> | string | null
    createdAt?: DateTimeFilter<"MissedCheckout"> | Date | string
  }

  export type AdminUserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutAuditLogsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminUserUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type CheckinCreateWithoutBadgeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutBadgeInput = {
    id?: string
    memberId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinCreateOrConnectWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput>
  }

  export type CheckinCreateManyBadgeInputEnvelope = {
    data: CheckinCreateManyBadgeInput | CheckinCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type EventAttendeeCreateWithoutBadgeInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    event: EventCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateWithoutBadgeInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeCreateOrConnectWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput>
  }

  export type EventAttendeeCreateManyBadgeInputEnvelope = {
    data: EventAttendeeCreateManyBadgeInput | EventAttendeeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type EventCheckinCreateWithoutBadgeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    eventAttendee: EventAttendeeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateWithoutBadgeInput = {
    id?: string
    eventAttendeeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinCreateOrConnectWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    create: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput>
  }

  export type EventCheckinCreateManyBadgeInputEnvelope = {
    data: EventCheckinCreateManyBadgeInput | EventCheckinCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutBadgeInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutBadgeInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput>
  }

  export type MemberCreateManyBadgeInputEnvelope = {
    data: MemberCreateManyBadgeInput | MemberCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput>
  }

  export type VisitorCreateManyBadgeInputEnvelope = {
    data: VisitorCreateManyBadgeInput | VisitorCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeStatusCreateWithoutBadgesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusUncheckedCreateWithoutBadgesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusCreateOrConnectWithoutBadgesInput = {
    where: BadgeStatusWhereUniqueInput
    create: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
  }

  export type CheckinUpsertWithWhereUniqueWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutBadgeInput, CheckinUncheckedUpdateWithoutBadgeInput>
    create: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutBadgeInput, CheckinUncheckedUpdateWithoutBadgeInput>
  }

  export type CheckinUpdateManyWithWhereWithoutBadgeInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutBadgeInput, EventAttendeeUncheckedUpdateWithoutBadgeInput>
    create: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutBadgeInput, EventAttendeeUncheckedUpdateWithoutBadgeInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutBadgeInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventAttendeeScalarWhereInput = {
    AND?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    OR?: EventAttendeeScalarWhereInput[]
    NOT?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    id?: UuidFilter<"EventAttendee"> | string
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
  }

  export type EventCheckinUpsertWithWhereUniqueWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    update: XOR<EventCheckinUpdateWithoutBadgeInput, EventCheckinUncheckedUpdateWithoutBadgeInput>
    create: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput>
  }

  export type EventCheckinUpdateWithWhereUniqueWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    data: XOR<EventCheckinUpdateWithoutBadgeInput, EventCheckinUncheckedUpdateWithoutBadgeInput>
  }

  export type EventCheckinUpdateManyWithWhereWithoutBadgeInput = {
    where: EventCheckinScalarWhereInput
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventCheckinScalarWhereInput = {
    AND?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
    OR?: EventCheckinScalarWhereInput[]
    NOT?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
    id?: UuidFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutBadgeInput, MemberUncheckedUpdateWithoutBadgeInput>
    create: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutBadgeInput, MemberUncheckedUpdateWithoutBadgeInput>
  }

  export type MemberUpdateManyWithWhereWithoutBadgeInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutBadgeInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: UuidFilter<"Member"> | string
    serviceNumber?: StringFilter<"Member"> | string
    rankId?: UuidFilter<"Member"> | string
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
    missedCheckoutCount?: IntFilter<"Member"> | number
    lastMissedCheckout?: DateTimeNullableFilter<"Member"> | Date | string | null
  }

  export type VisitorUpsertWithWhereUniqueWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutBadgeInput, VisitorUncheckedUpdateWithoutBadgeInput>
    create: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutBadgeInput, VisitorUncheckedUpdateWithoutBadgeInput>
  }

  export type VisitorUpdateManyWithWhereWithoutBadgeInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutBadgeInput>
  }

  export type BadgeStatusUpsertWithoutBadgesInput = {
    update: XOR<BadgeStatusUpdateWithoutBadgesInput, BadgeStatusUncheckedUpdateWithoutBadgesInput>
    create: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    where?: BadgeStatusWhereInput
  }

  export type BadgeStatusUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BadgeStatusWhereInput
    data: XOR<BadgeStatusUpdateWithoutBadgesInput, BadgeStatusUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeStatusUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeCreateWithoutCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutCheckinsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
  }

  export type AdminUserCreateWithoutCheckinsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutCheckinsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutCheckinsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
  }

  export type MemberCreateWithoutCheckinsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutCheckinsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutCheckinsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
  }

  export type BadgeUpsertWithoutCheckinsInput = {
    update: XOR<BadgeUpdateWithoutCheckinsInput, BadgeUncheckedUpdateWithoutCheckinsInput>
    create: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutCheckinsInput, BadgeUncheckedUpdateWithoutCheckinsInput>
  }

  export type BadgeUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type AdminUserUpsertWithoutCheckinsInput = {
    update: XOR<AdminUserUpdateWithoutCheckinsInput, AdminUserUncheckedUpdateWithoutCheckinsInput>
    create: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutCheckinsInput, AdminUserUncheckedUpdateWithoutCheckinsInput>
  }

  export type AdminUserUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type MemberUpsertWithoutCheckinsInput = {
    update: XOR<MemberUpdateWithoutCheckinsInput, MemberUncheckedUpdateWithoutCheckinsInput>
    create: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCheckinsInput, MemberUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutDivisionInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutDivisionInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput>
  }

  export type MemberCreateManyDivisionInputEnvelope = {
    data: MemberCreateManyDivisionInput | MemberCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutDivisionInput, MemberUncheckedUpdateWithoutDivisionInput>
    create: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutDivisionInput, MemberUncheckedUpdateWithoutDivisionInput>
  }

  export type MemberUpdateManyWithWhereWithoutDivisionInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutDivisionInput>
  }

  export type BadgeCreateWithoutEventAttendeesInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutEventAttendeesInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutEventAttendeesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
  }

  export type EventCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventAttendeesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
  }

  export type EventCheckinCreateWithoutEventAttendeeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    badge: BadgeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateWithoutEventAttendeeInput = {
    id?: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinCreateOrConnectWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    create: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput>
  }

  export type EventCheckinCreateManyEventAttendeeInputEnvelope = {
    data: EventCheckinCreateManyEventAttendeeInput | EventCheckinCreateManyEventAttendeeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithoutEventAttendeesInput = {
    update: XOR<BadgeUpdateWithoutEventAttendeesInput, BadgeUncheckedUpdateWithoutEventAttendeesInput>
    create: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutEventAttendeesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutEventAttendeesInput, BadgeUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type BadgeUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type EventUpsertWithoutEventAttendeesInput = {
    update: XOR<EventUpdateWithoutEventAttendeesInput, EventUncheckedUpdateWithoutEventAttendeesInput>
    create: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventAttendeesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventAttendeesInput, EventUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    update: XOR<EventCheckinUpdateWithoutEventAttendeeInput, EventCheckinUncheckedUpdateWithoutEventAttendeeInput>
    create: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput>
  }

  export type EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    data: XOR<EventCheckinUpdateWithoutEventAttendeeInput, EventCheckinUncheckedUpdateWithoutEventAttendeeInput>
  }

  export type EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput = {
    where: EventCheckinScalarWhereInput
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyWithoutEventAttendeeInput>
  }

  export type BadgeCreateWithoutEventCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutEventCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutEventCheckinsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
  }

  export type EventAttendeeCreateWithoutEventCheckinsInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    event: EventCreateNestedOneWithoutEventAttendeesInput
  }

  export type EventAttendeeUncheckedCreateWithoutEventCheckinsInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventAttendeeCreateOrConnectWithoutEventCheckinsInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
  }

  export type BadgeUpsertWithoutEventCheckinsInput = {
    update: XOR<BadgeUpdateWithoutEventCheckinsInput, BadgeUncheckedUpdateWithoutEventCheckinsInput>
    create: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutEventCheckinsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutEventCheckinsInput, BadgeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type BadgeUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type EventAttendeeUpsertWithoutEventCheckinsInput = {
    update: XOR<EventAttendeeUpdateWithoutEventCheckinsInput, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
    create: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    where?: EventAttendeeWhereInput
  }

  export type EventAttendeeUpdateToOneWithWhereWithoutEventCheckinsInput = {
    where?: EventAttendeeWhereInput
    data: XOR<EventAttendeeUpdateWithoutEventCheckinsInput, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateWithoutEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeCreateOrConnectWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeCreateManyEventInputEnvelope = {
    data: EventAttendeeCreateManyEventInput | EventAttendeeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutEventInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput>
  }

  export type VisitorCreateManyEventInputEnvelope = {
    data: VisitorCreateManyEventInput | VisitorCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutEventInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutEventInput>
  }

  export type VisitorUpsertWithWhereUniqueWithoutEventInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutEventInput, VisitorUncheckedUpdateWithoutEventInput>
    create: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutEventInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutEventInput, VisitorUncheckedUpdateWithoutEventInput>
  }

  export type VisitorUpdateManyWithWhereWithoutEventInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutEventInput>
  }

  export type RankCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    replacedByRank?: RankCreateNestedOneWithoutReplacesRanksInput
    replacesRanks?: RankCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankUncheckedCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    replacedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    replacesRanks?: RankUncheckedCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankCreateOrConnectWithoutMembersInput = {
    where: RankWhereUniqueInput
    create: XOR<RankCreateWithoutMembersInput, RankUncheckedCreateWithoutMembersInput>
  }

  export type BadgeCreateWithoutMembersInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutMembersInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutMembersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
  }

  export type BmqEnrollmentCreateWithoutMemberInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    bmqCourse: BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateWithoutMemberInput = {
    id?: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentCreateOrConnectWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    create: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput>
  }

  export type BmqEnrollmentCreateManyMemberInputEnvelope = {
    data: BmqEnrollmentCreateManyMemberInput | BmqEnrollmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type CheckinCreateWithoutMemberInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutMemberInput = {
    id?: string
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinCreateOrConnectWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput>
  }

  export type CheckinCreateManyMemberInputEnvelope = {
    data: CheckinCreateManyMemberInput | CheckinCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DivisionCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionCreateOrConnectWithoutMembersInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
  }

  export type VisitorCreateWithoutHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput>
  }

  export type VisitorCreateManyHostMemberInputEnvelope = {
    data: VisitorCreateManyHostMemberInput | VisitorCreateManyHostMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberTagCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string | null
    tag: TagCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateWithoutMemberInput = {
    id?: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagCreateOrConnectWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    create: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput>
  }

  export type MemberTagCreateManyMemberInputEnvelope = {
    data: MemberTagCreateManyMemberInput | MemberTagCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateWithoutMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type DdsAssignmentCreateManyMemberInputEnvelope = {
    data: DdsAssignmentCreateManyMemberInput | DdsAssignmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutTransferredToMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentCreateManyTransferredToMemberInputEnvelope = {
    data: DdsAssignmentCreateManyTransferredToMemberInput | DdsAssignmentCreateManyTransferredToMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberTypeCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeUncheckedCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeCreateOrConnectWithoutMembersInput = {
    where: MemberTypeWhereUniqueInput
    create: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
  }

  export type MemberStatusCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusUncheckedCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusCreateOrConnectWithoutMembersInput = {
    where: MemberStatusWhereUniqueInput
    create: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
  }

  export type MemberQualificationCreateWithoutMemberInput = {
    id?: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualificationType: QualificationTypeCreateNestedOneWithoutMemberQualificationsInput
    grantedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsGrantedInput
    revokedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsRevokedInput
  }

  export type MemberQualificationUncheckedCreateWithoutMemberInput = {
    id?: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateOrConnectWithoutMemberInput = {
    where: MemberQualificationWhereUniqueInput
    create: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput>
  }

  export type MemberQualificationCreateManyMemberInputEnvelope = {
    data: MemberQualificationCreateManyMemberInput | MemberQualificationCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleAssignmentCreateWithoutMemberInput = {
    id?: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: WeeklyScheduleCreateNestedOneWithoutAssignmentsInput
    dutyPosition?: DutyPositionCreateNestedOneWithoutAssignmentsInput
  }

  export type ScheduleAssignmentUncheckedCreateWithoutMemberInput = {
    id?: string
    scheduleId: string
    dutyPositionId?: string | null
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentCreateOrConnectWithoutMemberInput = {
    where: ScheduleAssignmentWhereUniqueInput
    create: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type ScheduleAssignmentCreateManyMemberInputEnvelope = {
    data: ScheduleAssignmentCreateManyMemberInput | ScheduleAssignmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type LockupStatusCreateWithoutCurrentHolderInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    securedByMember?: MemberCreateNestedOneWithoutLockupSecuredInput
    transfers?: LockupTransferCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusUncheckedCreateWithoutCurrentHolderInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transfers?: LockupTransferUncheckedCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionUncheckedCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusCreateOrConnectWithoutCurrentHolderInput = {
    where: LockupStatusWhereUniqueInput
    create: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput>
  }

  export type LockupStatusCreateManyCurrentHolderInputEnvelope = {
    data: LockupStatusCreateManyCurrentHolderInput | LockupStatusCreateManyCurrentHolderInput[]
    skipDuplicates?: boolean
  }

  export type LockupStatusCreateWithoutSecuredByMemberInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHolder?: MemberCreateNestedOneWithoutLockupHoldingInput
    transfers?: LockupTransferCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusUncheckedCreateWithoutSecuredByMemberInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transfers?: LockupTransferUncheckedCreateNestedManyWithoutLockupStatusInput
    execution?: LockupExecutionUncheckedCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusCreateOrConnectWithoutSecuredByMemberInput = {
    where: LockupStatusWhereUniqueInput
    create: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput>
  }

  export type LockupStatusCreateManySecuredByMemberInputEnvelope = {
    data: LockupStatusCreateManySecuredByMemberInput | LockupStatusCreateManySecuredByMemberInput[]
    skipDuplicates?: boolean
  }

  export type LockupTransferCreateWithoutFromMemberInput = {
    id?: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
    lockupStatus: LockupStatusCreateNestedOneWithoutTransfersInput
    toMember: MemberCreateNestedOneWithoutLockupTransfersToInput
  }

  export type LockupTransferUncheckedCreateWithoutFromMemberInput = {
    id?: string
    lockupStatusId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferCreateOrConnectWithoutFromMemberInput = {
    where: LockupTransferWhereUniqueInput
    create: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput>
  }

  export type LockupTransferCreateManyFromMemberInputEnvelope = {
    data: LockupTransferCreateManyFromMemberInput | LockupTransferCreateManyFromMemberInput[]
    skipDuplicates?: boolean
  }

  export type LockupTransferCreateWithoutToMemberInput = {
    id?: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
    lockupStatus: LockupStatusCreateNestedOneWithoutTransfersInput
    fromMember: MemberCreateNestedOneWithoutLockupTransfersFromInput
  }

  export type LockupTransferUncheckedCreateWithoutToMemberInput = {
    id?: string
    lockupStatusId: string
    fromMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferCreateOrConnectWithoutToMemberInput = {
    where: LockupTransferWhereUniqueInput
    create: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput>
  }

  export type LockupTransferCreateManyToMemberInputEnvelope = {
    data: LockupTransferCreateManyToMemberInput | LockupTransferCreateManyToMemberInput[]
    skipDuplicates?: boolean
  }

  export type LockupExecutionCreateWithoutExecutedByMemberInput = {
    id?: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
    lockupStatus: LockupStatusCreateNestedOneWithoutExecutionInput
  }

  export type LockupExecutionUncheckedCreateWithoutExecutedByMemberInput = {
    id?: string
    lockupStatusId: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupExecutionCreateOrConnectWithoutExecutedByMemberInput = {
    where: LockupExecutionWhereUniqueInput
    create: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput>
  }

  export type LockupExecutionCreateManyExecutedByMemberInputEnvelope = {
    data: LockupExecutionCreateManyExecutedByMemberInput | LockupExecutionCreateManyExecutedByMemberInput[]
    skipDuplicates?: boolean
  }

  export type MissedCheckoutCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    resolvedByAdmin?: AdminUserCreateNestedOneWithoutMissedCheckoutsResolvedInput
  }

  export type MissedCheckoutUncheckedCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    resolvedByAdminId?: string | null
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MissedCheckoutCreateOrConnectWithoutMemberInput = {
    where: MissedCheckoutWhereUniqueInput
    create: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput>
  }

  export type MissedCheckoutCreateManyMemberInputEnvelope = {
    data: MissedCheckoutCreateManyMemberInput | MissedCheckoutCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type UnitEventDutyAssignmentCreateWithoutMemberInput = {
    id?: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: UnitEventCreateNestedOneWithoutDutyAssignmentsInput
    eventDutyPosition?: UnitEventDutyPositionCreateNestedOneWithoutAssignmentsInput
  }

  export type UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput = {
    id?: string
    eventId: string
    eventDutyPositionId?: string | null
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentCreateOrConnectWithoutMemberInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    create: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type UnitEventDutyAssignmentCreateManyMemberInputEnvelope = {
    data: UnitEventDutyAssignmentCreateManyMemberInput | UnitEventDutyAssignmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type RankUpsertWithoutMembersInput = {
    update: XOR<RankUpdateWithoutMembersInput, RankUncheckedUpdateWithoutMembersInput>
    create: XOR<RankCreateWithoutMembersInput, RankUncheckedCreateWithoutMembersInput>
    where?: RankWhereInput
  }

  export type RankUpdateToOneWithWhereWithoutMembersInput = {
    where?: RankWhereInput
    data: XOR<RankUpdateWithoutMembersInput, RankUncheckedUpdateWithoutMembersInput>
  }

  export type RankUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByRank?: RankUpdateOneWithoutReplacesRanksNestedInput
    replacesRanks?: RankUpdateManyWithoutReplacedByRankNestedInput
  }

  export type RankUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    replacedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacesRanks?: RankUncheckedUpdateManyWithoutReplacedByRankNestedInput
  }

  export type BadgeUpsertWithoutMembersInput = {
    update: XOR<BadgeUpdateWithoutMembersInput, BadgeUncheckedUpdateWithoutMembersInput>
    create: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutMembersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutMembersInput, BadgeUncheckedUpdateWithoutMembersInput>
  }

  export type BadgeUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    update: XOR<BmqEnrollmentUpdateWithoutMemberInput, BmqEnrollmentUncheckedUpdateWithoutMemberInput>
    create: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput>
  }

  export type BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    data: XOR<BmqEnrollmentUpdateWithoutMemberInput, BmqEnrollmentUncheckedUpdateWithoutMemberInput>
  }

  export type BmqEnrollmentUpdateManyWithWhereWithoutMemberInput = {
    where: BmqEnrollmentScalarWhereInput
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type BmqEnrollmentScalarWhereInput = {
    AND?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
    OR?: BmqEnrollmentScalarWhereInput[]
    NOT?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
    id?: UuidFilter<"BmqEnrollment"> | string
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
  }

  export type CheckinUpsertWithWhereUniqueWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutMemberInput, CheckinUncheckedUpdateWithoutMemberInput>
    create: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutMemberInput, CheckinUncheckedUpdateWithoutMemberInput>
  }

  export type CheckinUpdateManyWithWhereWithoutMemberInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutMemberInput>
  }

  export type DivisionUpsertWithoutMembersInput = {
    update: XOR<DivisionUpdateWithoutMembersInput, DivisionUncheckedUpdateWithoutMembersInput>
    create: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    where?: DivisionWhereInput
  }

  export type DivisionUpdateToOneWithWhereWithoutMembersInput = {
    where?: DivisionWhereInput
    data: XOR<DivisionUpdateWithoutMembersInput, DivisionUncheckedUpdateWithoutMembersInput>
  }

  export type DivisionUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DivisionUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpsertWithWhereUniqueWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutHostMemberInput, VisitorUncheckedUpdateWithoutHostMemberInput>
    create: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutHostMemberInput, VisitorUncheckedUpdateWithoutHostMemberInput>
  }

  export type VisitorUpdateManyWithWhereWithoutHostMemberInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutHostMemberInput>
  }

  export type MemberTagUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    update: XOR<MemberTagUpdateWithoutMemberInput, MemberTagUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput>
  }

  export type MemberTagUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    data: XOR<MemberTagUpdateWithoutMemberInput, MemberTagUncheckedUpdateWithoutMemberInput>
  }

  export type MemberTagUpdateManyWithWhereWithoutMemberInput = {
    where: MemberTagScalarWhereInput
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberTagScalarWhereInput = {
    AND?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
    OR?: MemberTagScalarWhereInput[]
    NOT?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
    id?: UuidFilter<"MemberTag"> | string
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutMemberInput, DdsAssignmentUncheckedUpdateWithoutMemberInput>
    create: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutMemberInput, DdsAssignmentUncheckedUpdateWithoutMemberInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutMemberInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutTransferredToMemberInput, DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput>
    create: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutTransferredToMemberInput, DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberInput>
  }

  export type MemberTypeUpsertWithoutMembersInput = {
    update: XOR<MemberTypeUpdateWithoutMembersInput, MemberTypeUncheckedUpdateWithoutMembersInput>
    create: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    where?: MemberTypeWhereInput
  }

  export type MemberTypeUpdateToOneWithWhereWithoutMembersInput = {
    where?: MemberTypeWhereInput
    data: XOR<MemberTypeUpdateWithoutMembersInput, MemberTypeUncheckedUpdateWithoutMembersInput>
  }

  export type MemberTypeUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUpsertWithoutMembersInput = {
    update: XOR<MemberStatusUpdateWithoutMembersInput, MemberStatusUncheckedUpdateWithoutMembersInput>
    create: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    where?: MemberStatusWhereInput
  }

  export type MemberStatusUpdateToOneWithWhereWithoutMembersInput = {
    where?: MemberStatusWhereInput
    data: XOR<MemberStatusUpdateWithoutMembersInput, MemberStatusUncheckedUpdateWithoutMembersInput>
  }

  export type MemberStatusUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberQualificationUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberQualificationWhereUniqueInput
    update: XOR<MemberQualificationUpdateWithoutMemberInput, MemberQualificationUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberQualificationCreateWithoutMemberInput, MemberQualificationUncheckedCreateWithoutMemberInput>
  }

  export type MemberQualificationUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberQualificationWhereUniqueInput
    data: XOR<MemberQualificationUpdateWithoutMemberInput, MemberQualificationUncheckedUpdateWithoutMemberInput>
  }

  export type MemberQualificationUpdateManyWithWhereWithoutMemberInput = {
    where: MemberQualificationScalarWhereInput
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyWithoutMemberInput>
  }

  export type ScheduleAssignmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: ScheduleAssignmentWhereUniqueInput
    update: XOR<ScheduleAssignmentUpdateWithoutMemberInput, ScheduleAssignmentUncheckedUpdateWithoutMemberInput>
    create: XOR<ScheduleAssignmentCreateWithoutMemberInput, ScheduleAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type ScheduleAssignmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: ScheduleAssignmentWhereUniqueInput
    data: XOR<ScheduleAssignmentUpdateWithoutMemberInput, ScheduleAssignmentUncheckedUpdateWithoutMemberInput>
  }

  export type ScheduleAssignmentUpdateManyWithWhereWithoutMemberInput = {
    where: ScheduleAssignmentScalarWhereInput
    data: XOR<ScheduleAssignmentUpdateManyMutationInput, ScheduleAssignmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type ScheduleAssignmentScalarWhereInput = {
    AND?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
    OR?: ScheduleAssignmentScalarWhereInput[]
    NOT?: ScheduleAssignmentScalarWhereInput | ScheduleAssignmentScalarWhereInput[]
    id?: UuidFilter<"ScheduleAssignment"> | string
    scheduleId?: UuidFilter<"ScheduleAssignment"> | string
    dutyPositionId?: UuidNullableFilter<"ScheduleAssignment"> | string | null
    memberId?: UuidFilter<"ScheduleAssignment"> | string
    status?: StringFilter<"ScheduleAssignment"> | string
    confirmedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"ScheduleAssignment"> | Date | string | null
    notes?: StringNullableFilter<"ScheduleAssignment"> | string | null
    createdAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleAssignment"> | Date | string
  }

  export type LockupStatusUpsertWithWhereUniqueWithoutCurrentHolderInput = {
    where: LockupStatusWhereUniqueInput
    update: XOR<LockupStatusUpdateWithoutCurrentHolderInput, LockupStatusUncheckedUpdateWithoutCurrentHolderInput>
    create: XOR<LockupStatusCreateWithoutCurrentHolderInput, LockupStatusUncheckedCreateWithoutCurrentHolderInput>
  }

  export type LockupStatusUpdateWithWhereUniqueWithoutCurrentHolderInput = {
    where: LockupStatusWhereUniqueInput
    data: XOR<LockupStatusUpdateWithoutCurrentHolderInput, LockupStatusUncheckedUpdateWithoutCurrentHolderInput>
  }

  export type LockupStatusUpdateManyWithWhereWithoutCurrentHolderInput = {
    where: LockupStatusScalarWhereInput
    data: XOR<LockupStatusUpdateManyMutationInput, LockupStatusUncheckedUpdateManyWithoutCurrentHolderInput>
  }

  export type LockupStatusScalarWhereInput = {
    AND?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
    OR?: LockupStatusScalarWhereInput[]
    NOT?: LockupStatusScalarWhereInput | LockupStatusScalarWhereInput[]
    id?: UuidFilter<"LockupStatus"> | string
    date?: DateTimeFilter<"LockupStatus"> | Date | string
    currentHolderId?: UuidNullableFilter<"LockupStatus"> | string | null
    acquiredAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    buildingStatus?: StringFilter<"LockupStatus"> | string
    securedAt?: DateTimeNullableFilter<"LockupStatus"> | Date | string | null
    securedBy?: UuidNullableFilter<"LockupStatus"> | string | null
    isActive?: BoolFilter<"LockupStatus"> | boolean
    createdAt?: DateTimeFilter<"LockupStatus"> | Date | string
    updatedAt?: DateTimeFilter<"LockupStatus"> | Date | string
  }

  export type LockupStatusUpsertWithWhereUniqueWithoutSecuredByMemberInput = {
    where: LockupStatusWhereUniqueInput
    update: XOR<LockupStatusUpdateWithoutSecuredByMemberInput, LockupStatusUncheckedUpdateWithoutSecuredByMemberInput>
    create: XOR<LockupStatusCreateWithoutSecuredByMemberInput, LockupStatusUncheckedCreateWithoutSecuredByMemberInput>
  }

  export type LockupStatusUpdateWithWhereUniqueWithoutSecuredByMemberInput = {
    where: LockupStatusWhereUniqueInput
    data: XOR<LockupStatusUpdateWithoutSecuredByMemberInput, LockupStatusUncheckedUpdateWithoutSecuredByMemberInput>
  }

  export type LockupStatusUpdateManyWithWhereWithoutSecuredByMemberInput = {
    where: LockupStatusScalarWhereInput
    data: XOR<LockupStatusUpdateManyMutationInput, LockupStatusUncheckedUpdateManyWithoutSecuredByMemberInput>
  }

  export type LockupTransferUpsertWithWhereUniqueWithoutFromMemberInput = {
    where: LockupTransferWhereUniqueInput
    update: XOR<LockupTransferUpdateWithoutFromMemberInput, LockupTransferUncheckedUpdateWithoutFromMemberInput>
    create: XOR<LockupTransferCreateWithoutFromMemberInput, LockupTransferUncheckedCreateWithoutFromMemberInput>
  }

  export type LockupTransferUpdateWithWhereUniqueWithoutFromMemberInput = {
    where: LockupTransferWhereUniqueInput
    data: XOR<LockupTransferUpdateWithoutFromMemberInput, LockupTransferUncheckedUpdateWithoutFromMemberInput>
  }

  export type LockupTransferUpdateManyWithWhereWithoutFromMemberInput = {
    where: LockupTransferScalarWhereInput
    data: XOR<LockupTransferUpdateManyMutationInput, LockupTransferUncheckedUpdateManyWithoutFromMemberInput>
  }

  export type LockupTransferScalarWhereInput = {
    AND?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
    OR?: LockupTransferScalarWhereInput[]
    NOT?: LockupTransferScalarWhereInput | LockupTransferScalarWhereInput[]
    id?: UuidFilter<"LockupTransfer"> | string
    lockupStatusId?: UuidFilter<"LockupTransfer"> | string
    fromMemberId?: UuidFilter<"LockupTransfer"> | string
    toMemberId?: UuidFilter<"LockupTransfer"> | string
    transferredAt?: DateTimeFilter<"LockupTransfer"> | Date | string
    reason?: StringFilter<"LockupTransfer"> | string
    notes?: StringNullableFilter<"LockupTransfer"> | string | null
    createdAt?: DateTimeFilter<"LockupTransfer"> | Date | string
  }

  export type LockupTransferUpsertWithWhereUniqueWithoutToMemberInput = {
    where: LockupTransferWhereUniqueInput
    update: XOR<LockupTransferUpdateWithoutToMemberInput, LockupTransferUncheckedUpdateWithoutToMemberInput>
    create: XOR<LockupTransferCreateWithoutToMemberInput, LockupTransferUncheckedCreateWithoutToMemberInput>
  }

  export type LockupTransferUpdateWithWhereUniqueWithoutToMemberInput = {
    where: LockupTransferWhereUniqueInput
    data: XOR<LockupTransferUpdateWithoutToMemberInput, LockupTransferUncheckedUpdateWithoutToMemberInput>
  }

  export type LockupTransferUpdateManyWithWhereWithoutToMemberInput = {
    where: LockupTransferScalarWhereInput
    data: XOR<LockupTransferUpdateManyMutationInput, LockupTransferUncheckedUpdateManyWithoutToMemberInput>
  }

  export type LockupExecutionUpsertWithWhereUniqueWithoutExecutedByMemberInput = {
    where: LockupExecutionWhereUniqueInput
    update: XOR<LockupExecutionUpdateWithoutExecutedByMemberInput, LockupExecutionUncheckedUpdateWithoutExecutedByMemberInput>
    create: XOR<LockupExecutionCreateWithoutExecutedByMemberInput, LockupExecutionUncheckedCreateWithoutExecutedByMemberInput>
  }

  export type LockupExecutionUpdateWithWhereUniqueWithoutExecutedByMemberInput = {
    where: LockupExecutionWhereUniqueInput
    data: XOR<LockupExecutionUpdateWithoutExecutedByMemberInput, LockupExecutionUncheckedUpdateWithoutExecutedByMemberInput>
  }

  export type LockupExecutionUpdateManyWithWhereWithoutExecutedByMemberInput = {
    where: LockupExecutionScalarWhereInput
    data: XOR<LockupExecutionUpdateManyMutationInput, LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberInput>
  }

  export type LockupExecutionScalarWhereInput = {
    AND?: LockupExecutionScalarWhereInput | LockupExecutionScalarWhereInput[]
    OR?: LockupExecutionScalarWhereInput[]
    NOT?: LockupExecutionScalarWhereInput | LockupExecutionScalarWhereInput[]
    id?: UuidFilter<"LockupExecution"> | string
    lockupStatusId?: UuidFilter<"LockupExecution"> | string
    executedBy?: UuidFilter<"LockupExecution"> | string
    executedAt?: DateTimeFilter<"LockupExecution"> | Date | string
    membersCheckedOut?: JsonFilter<"LockupExecution">
    visitorsCheckedOut?: JsonFilter<"LockupExecution">
    totalCheckedOut?: IntFilter<"LockupExecution"> | number
    notes?: StringNullableFilter<"LockupExecution"> | string | null
    createdAt?: DateTimeFilter<"LockupExecution"> | Date | string
  }

  export type MissedCheckoutUpsertWithWhereUniqueWithoutMemberInput = {
    where: MissedCheckoutWhereUniqueInput
    update: XOR<MissedCheckoutUpdateWithoutMemberInput, MissedCheckoutUncheckedUpdateWithoutMemberInput>
    create: XOR<MissedCheckoutCreateWithoutMemberInput, MissedCheckoutUncheckedCreateWithoutMemberInput>
  }

  export type MissedCheckoutUpdateWithWhereUniqueWithoutMemberInput = {
    where: MissedCheckoutWhereUniqueInput
    data: XOR<MissedCheckoutUpdateWithoutMemberInput, MissedCheckoutUncheckedUpdateWithoutMemberInput>
  }

  export type MissedCheckoutUpdateManyWithWhereWithoutMemberInput = {
    where: MissedCheckoutScalarWhereInput
    data: XOR<MissedCheckoutUpdateManyMutationInput, MissedCheckoutUncheckedUpdateManyWithoutMemberInput>
  }

  export type UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    update: XOR<UnitEventDutyAssignmentUpdateWithoutMemberInput, UnitEventDutyAssignmentUncheckedUpdateWithoutMemberInput>
    create: XOR<UnitEventDutyAssignmentCreateWithoutMemberInput, UnitEventDutyAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    data: XOR<UnitEventDutyAssignmentUpdateWithoutMemberInput, UnitEventDutyAssignmentUncheckedUpdateWithoutMemberInput>
  }

  export type UnitEventDutyAssignmentUpdateManyWithWhereWithoutMemberInput = {
    where: UnitEventDutyAssignmentScalarWhereInput
    data: XOR<UnitEventDutyAssignmentUpdateManyMutationInput, UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type UnitEventDutyAssignmentScalarWhereInput = {
    AND?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
    OR?: UnitEventDutyAssignmentScalarWhereInput[]
    NOT?: UnitEventDutyAssignmentScalarWhereInput | UnitEventDutyAssignmentScalarWhereInput[]
    id?: UuidFilter<"UnitEventDutyAssignment"> | string
    eventId?: UuidFilter<"UnitEventDutyAssignment"> | string
    eventDutyPositionId?: UuidNullableFilter<"UnitEventDutyAssignment"> | string | null
    memberId?: UuidFilter<"UnitEventDutyAssignment"> | string
    status?: StringFilter<"UnitEventDutyAssignment"> | string
    isVolunteer?: BoolFilter<"UnitEventDutyAssignment"> | boolean
    confirmedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"UnitEventDutyAssignment"> | Date | string | null
    notes?: StringNullableFilter<"UnitEventDutyAssignment"> | string | null
    createdAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyAssignment"> | Date | string
  }

  export type MemberTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateWithoutTagInput = {
    id?: string
    memberId: string
    createdAt?: Date | string | null
  }

  export type MemberTagCreateOrConnectWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    create: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput>
  }

  export type MemberTagCreateManyTagInputEnvelope = {
    data: MemberTagCreateManyTagInput | MemberTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type QualificationTypeCreateWithoutTagInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberQualifications?: MemberQualificationCreateNestedManyWithoutQualificationTypeInput
  }

  export type QualificationTypeUncheckedCreateWithoutTagInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberQualifications?: MemberQualificationUncheckedCreateNestedManyWithoutQualificationTypeInput
  }

  export type QualificationTypeCreateOrConnectWithoutTagInput = {
    where: QualificationTypeWhereUniqueInput
    create: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput>
  }

  export type QualificationTypeCreateManyTagInputEnvelope = {
    data: QualificationTypeCreateManyTagInput | QualificationTypeCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type MemberTagUpsertWithWhereUniqueWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    update: XOR<MemberTagUpdateWithoutTagInput, MemberTagUncheckedUpdateWithoutTagInput>
    create: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput>
  }

  export type MemberTagUpdateWithWhereUniqueWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    data: XOR<MemberTagUpdateWithoutTagInput, MemberTagUncheckedUpdateWithoutTagInput>
  }

  export type MemberTagUpdateManyWithWhereWithoutTagInput = {
    where: MemberTagScalarWhereInput
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyWithoutTagInput>
  }

  export type QualificationTypeUpsertWithWhereUniqueWithoutTagInput = {
    where: QualificationTypeWhereUniqueInput
    update: XOR<QualificationTypeUpdateWithoutTagInput, QualificationTypeUncheckedUpdateWithoutTagInput>
    create: XOR<QualificationTypeCreateWithoutTagInput, QualificationTypeUncheckedCreateWithoutTagInput>
  }

  export type QualificationTypeUpdateWithWhereUniqueWithoutTagInput = {
    where: QualificationTypeWhereUniqueInput
    data: XOR<QualificationTypeUpdateWithoutTagInput, QualificationTypeUncheckedUpdateWithoutTagInput>
  }

  export type QualificationTypeUpdateManyWithWhereWithoutTagInput = {
    where: QualificationTypeScalarWhereInput
    data: XOR<QualificationTypeUpdateManyMutationInput, QualificationTypeUncheckedUpdateManyWithoutTagInput>
  }

  export type QualificationTypeScalarWhereInput = {
    AND?: QualificationTypeScalarWhereInput | QualificationTypeScalarWhereInput[]
    OR?: QualificationTypeScalarWhereInput[]
    NOT?: QualificationTypeScalarWhereInput | QualificationTypeScalarWhereInput[]
    id?: UuidFilter<"QualificationType"> | string
    code?: StringFilter<"QualificationType"> | string
    name?: StringFilter<"QualificationType"> | string
    description?: StringNullableFilter<"QualificationType"> | string | null
    canReceiveLockup?: BoolFilter<"QualificationType"> | boolean
    displayOrder?: IntFilter<"QualificationType"> | number
    tagId?: UuidNullableFilter<"QualificationType"> | string | null
    createdAt?: DateTimeFilter<"QualificationType"> | Date | string
    updatedAt?: DateTimeFilter<"QualificationType"> | Date | string
  }

  export type MemberCreateWithoutMemberTagsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberTagsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberTagsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
  }

  export type TagCreateWithoutMemberTagsInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    qualificationTypes?: QualificationTypeCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutMemberTagsInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    qualificationTypes?: QualificationTypeUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutMemberTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
  }

  export type MemberUpsertWithoutMemberTagsInput = {
    update: XOR<MemberUpdateWithoutMemberTagsInput, MemberUncheckedUpdateWithoutMemberTagsInput>
    create: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberTagsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberTagsInput, MemberUncheckedUpdateWithoutMemberTagsInput>
  }

  export type MemberUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type TagUpsertWithoutMemberTagsInput = {
    update: XOR<TagUpdateWithoutMemberTagsInput, TagUncheckedUpdateWithoutMemberTagsInput>
    create: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutMemberTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutMemberTagsInput, TagUncheckedUpdateWithoutMemberTagsInput>
  }

  export type TagUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualificationTypes?: QualificationTypeUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualificationTypes?: QualificationTypeUncheckedUpdateManyWithoutTagNestedInput
  }

  export type AdminUserCreateWithoutSecurityAlertsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutSecurityAlertsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutSecurityAlertsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
  }

  export type AdminUserUpsertWithoutSecurityAlertsInput = {
    update: XOR<AdminUserUpdateWithoutSecurityAlertsInput, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
    create: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutSecurityAlertsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutSecurityAlertsInput, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type AdminUserUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserCreateWithoutVisitorsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutVisitorsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutVisitorsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
  }

  export type EventCreateWithoutVisitorsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutVisitorsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutVisitorsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
  }

  export type MemberCreateWithoutVisitorsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutVisitorsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutVisitorsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
  }

  export type BadgeCreateWithoutVisitorsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutVisitorsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutVisitorsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
  }

  export type VisitTypeCreateWithoutVisitorsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeUncheckedCreateWithoutVisitorsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeCreateOrConnectWithoutVisitorsInput = {
    where: VisitTypeWhereUniqueInput
    create: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
  }

  export type AdminUserUpsertWithoutVisitorsInput = {
    update: XOR<AdminUserUpdateWithoutVisitorsInput, AdminUserUncheckedUpdateWithoutVisitorsInput>
    create: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutVisitorsInput, AdminUserUncheckedUpdateWithoutVisitorsInput>
  }

  export type AdminUserUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type EventUpsertWithoutVisitorsInput = {
    update: XOR<EventUpdateWithoutVisitorsInput, EventUncheckedUpdateWithoutVisitorsInput>
    create: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutVisitorsInput, EventUncheckedUpdateWithoutVisitorsInput>
  }

  export type EventUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type MemberUpsertWithoutVisitorsInput = {
    update: XOR<MemberUpdateWithoutVisitorsInput, MemberUncheckedUpdateWithoutVisitorsInput>
    create: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutVisitorsInput, MemberUncheckedUpdateWithoutVisitorsInput>
  }

  export type MemberUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BadgeUpsertWithoutVisitorsInput = {
    update: XOR<BadgeUpdateWithoutVisitorsInput, BadgeUncheckedUpdateWithoutVisitorsInput>
    create: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutVisitorsInput, BadgeUncheckedUpdateWithoutVisitorsInput>
  }

  export type BadgeUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type VisitTypeUpsertWithoutVisitorsInput = {
    update: XOR<VisitTypeUpdateWithoutVisitorsInput, VisitTypeUncheckedUpdateWithoutVisitorsInput>
    create: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    where?: VisitTypeWhereInput
  }

  export type VisitTypeUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: VisitTypeWhereInput
    data: XOR<VisitTypeUpdateWithoutVisitorsInput, VisitTypeUncheckedUpdateWithoutVisitorsInput>
  }

  export type VisitTypeUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BmqEnrollmentCreateWithoutBmqCourseInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    member: MemberCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateWithoutBmqCourseInput = {
    id?: string
    memberId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentCreateOrConnectWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    create: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentCreateManyBmqCourseInputEnvelope = {
    data: BmqEnrollmentCreateManyBmqCourseInput | BmqEnrollmentCreateManyBmqCourseInput[]
    skipDuplicates?: boolean
  }

  export type BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    update: XOR<BmqEnrollmentUpdateWithoutBmqCourseInput, BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput>
    create: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    data: XOR<BmqEnrollmentUpdateWithoutBmqCourseInput, BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput = {
    where: BmqEnrollmentScalarWhereInput
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseInput>
  }

  export type BmqCourseCreateWithoutBmqEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput = {
    where: BmqCourseWhereUniqueInput
    create: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
  }

  export type MemberCreateWithoutBmqEnrollmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutBmqEnrollmentsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutBmqEnrollmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
  }

  export type BmqCourseUpsertWithoutBmqEnrollmentsInput = {
    update: XOR<BmqCourseUpdateWithoutBmqEnrollmentsInput, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
    create: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    where?: BmqCourseWhereInput
  }

  export type BmqCourseUpdateToOneWithWhereWithoutBmqEnrollmentsInput = {
    where?: BmqCourseWhereInput
    data: XOR<BmqCourseUpdateWithoutBmqEnrollmentsInput, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type BmqCourseUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type MemberUpsertWithoutBmqEnrollmentsInput = {
    update: XOR<MemberUpdateWithoutBmqEnrollmentsInput, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
    create: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutBmqEnrollmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutBmqEnrollmentsInput, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type MemberUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AdminUserCreateWithoutReport_audit_logInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutReport_audit_logInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutReport_audit_logInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
  }

  export type AdminUserUpsertWithoutReport_audit_logInput = {
    update: XOR<AdminUserUpdateWithoutReport_audit_logInput, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
    create: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutReport_audit_logInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutReport_audit_logInput, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
  }

  export type AdminUserUpdateWithoutReport_audit_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutReport_audit_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type MemberCreateWithoutDdsAssignmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutDdsAssignmentsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutDdsAssignmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
  }

  export type MemberCreateWithoutDdsTransfersInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutDdsTransfersInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutDdsTransfersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
  }

  export type AdminUserCreateWithoutDdsAssignmentsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDdsAssignmentsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDdsAssignmentsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
  }

  export type MemberUpsertWithoutDdsAssignmentsInput = {
    update: XOR<MemberUpdateWithoutDdsAssignmentsInput, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
    create: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutDdsAssignmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutDdsAssignmentsInput, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUpsertWithoutDdsTransfersInput = {
    update: XOR<MemberUpdateWithoutDdsTransfersInput, MemberUncheckedUpdateWithoutDdsTransfersInput>
    create: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutDdsTransfersInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutDdsTransfersInput, MemberUncheckedUpdateWithoutDdsTransfersInput>
  }

  export type MemberUpdateWithoutDdsTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutDdsTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AdminUserUpsertWithoutDdsAssignmentsInput = {
    update: XOR<AdminUserUpdateWithoutDdsAssignmentsInput, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
    create: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutDdsAssignmentsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutDdsAssignmentsInput, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type AdminUserUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type MemberCreateWithoutMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput>
  }

  export type MemberCreateManyMemberStatusRefInputEnvelope = {
    data: MemberCreateManyMemberStatusRefInput | MemberCreateManyMemberStatusRefInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutMemberStatusRefInput, MemberUncheckedUpdateWithoutMemberStatusRefInput>
    create: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutMemberStatusRefInput, MemberUncheckedUpdateWithoutMemberStatusRefInput>
  }

  export type MemberUpdateManyWithWhereWithoutMemberStatusRefInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberStatusRefInput>
  }

  export type MemberCreateWithoutMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput>
  }

  export type MemberCreateManyMemberTypeRefInputEnvelope = {
    data: MemberCreateManyMemberTypeRefInput | MemberCreateManyMemberTypeRefInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutMemberTypeRefInput, MemberUncheckedUpdateWithoutMemberTypeRefInput>
    create: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutMemberTypeRefInput, MemberUncheckedUpdateWithoutMemberTypeRefInput>
  }

  export type MemberUpdateManyWithWhereWithoutMemberTypeRefInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberTypeRefInput>
  }

  export type VisitorCreateWithoutVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput>
  }

  export type VisitorCreateManyVisitTypeRefInputEnvelope = {
    data: VisitorCreateManyVisitTypeRefInput | VisitorCreateManyVisitTypeRefInput[]
    skipDuplicates?: boolean
  }

  export type VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutVisitTypeRefInput, VisitorUncheckedUpdateWithoutVisitTypeRefInput>
    create: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutVisitTypeRefInput, VisitorUncheckedUpdateWithoutVisitTypeRefInput>
  }

  export type VisitorUpdateManyWithWhereWithoutVisitTypeRefInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutVisitTypeRefInput>
  }

  export type BadgeCreateWithoutBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateWithoutBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput>
  }

  export type BadgeCreateManyBadgeStatusRefInputEnvelope = {
    data: BadgeCreateManyBadgeStatusRefInput | BadgeCreateManyBadgeStatusRefInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutBadgeStatusRefInput, BadgeUncheckedUpdateWithoutBadgeStatusRefInput>
    create: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutBadgeStatusRefInput, BadgeUncheckedUpdateWithoutBadgeStatusRefInput>
  }

  export type BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutBadgeStatusRefInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: UuidFilter<"Badge"> | string
    serialNumber?: StringFilter<"Badge"> | string
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
  }

  export type MemberCreateWithoutRankRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutRankRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutRankRefInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput>
  }

  export type MemberCreateManyRankRefInputEnvelope = {
    data: MemberCreateManyRankRefInput | MemberCreateManyRankRefInput[]
    skipDuplicates?: boolean
  }

  export type RankCreateWithoutReplacesRanksInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutRankRefInput
    replacedByRank?: RankCreateNestedOneWithoutReplacesRanksInput
  }

  export type RankUncheckedCreateWithoutReplacesRanksInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    replacedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutRankRefInput
  }

  export type RankCreateOrConnectWithoutReplacesRanksInput = {
    where: RankWhereUniqueInput
    create: XOR<RankCreateWithoutReplacesRanksInput, RankUncheckedCreateWithoutReplacesRanksInput>
  }

  export type RankCreateWithoutReplacedByRankInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutRankRefInput
    replacesRanks?: RankCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankUncheckedCreateWithoutReplacedByRankInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutRankRefInput
    replacesRanks?: RankUncheckedCreateNestedManyWithoutReplacedByRankInput
  }

  export type RankCreateOrConnectWithoutReplacedByRankInput = {
    where: RankWhereUniqueInput
    create: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput>
  }

  export type RankCreateManyReplacedByRankInputEnvelope = {
    data: RankCreateManyReplacedByRankInput | RankCreateManyReplacedByRankInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutRankRefInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutRankRefInput, MemberUncheckedUpdateWithoutRankRefInput>
    create: XOR<MemberCreateWithoutRankRefInput, MemberUncheckedCreateWithoutRankRefInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutRankRefInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutRankRefInput, MemberUncheckedUpdateWithoutRankRefInput>
  }

  export type MemberUpdateManyWithWhereWithoutRankRefInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutRankRefInput>
  }

  export type RankUpsertWithoutReplacesRanksInput = {
    update: XOR<RankUpdateWithoutReplacesRanksInput, RankUncheckedUpdateWithoutReplacesRanksInput>
    create: XOR<RankCreateWithoutReplacesRanksInput, RankUncheckedCreateWithoutReplacesRanksInput>
    where?: RankWhereInput
  }

  export type RankUpdateToOneWithWhereWithoutReplacesRanksInput = {
    where?: RankWhereInput
    data: XOR<RankUpdateWithoutReplacesRanksInput, RankUncheckedUpdateWithoutReplacesRanksInput>
  }

  export type RankUpdateWithoutReplacesRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutRankRefNestedInput
    replacedByRank?: RankUpdateOneWithoutReplacesRanksNestedInput
  }

  export type RankUncheckedUpdateWithoutReplacesRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    replacedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutRankRefNestedInput
  }

  export type RankUpsertWithWhereUniqueWithoutReplacedByRankInput = {
    where: RankWhereUniqueInput
    update: XOR<RankUpdateWithoutReplacedByRankInput, RankUncheckedUpdateWithoutReplacedByRankInput>
    create: XOR<RankCreateWithoutReplacedByRankInput, RankUncheckedCreateWithoutReplacedByRankInput>
  }

  export type RankUpdateWithWhereUniqueWithoutReplacedByRankInput = {
    where: RankWhereUniqueInput
    data: XOR<RankUpdateWithoutReplacedByRankInput, RankUncheckedUpdateWithoutReplacedByRankInput>
  }

  export type RankUpdateManyWithWhereWithoutReplacedByRankInput = {
    where: RankScalarWhereInput
    data: XOR<RankUpdateManyMutationInput, RankUncheckedUpdateManyWithoutReplacedByRankInput>
  }

  export type RankScalarWhereInput = {
    AND?: RankScalarWhereInput | RankScalarWhereInput[]
    OR?: RankScalarWhereInput[]
    NOT?: RankScalarWhereInput | RankScalarWhereInput[]
    id?: UuidFilter<"Rank"> | string
    code?: StringFilter<"Rank"> | string
    name?: StringFilter<"Rank"> | string
    branch?: StringFilter<"Rank"> | string
    category?: StringFilter<"Rank"> | string
    displayOrder?: IntFilter<"Rank"> | number
    isActive?: BoolFilter<"Rank"> | boolean
    replacedBy?: UuidNullableFilter<"Rank"> | string | null
    createdAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Rank"> | Date | string | null
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MemberQualificationCreateWithoutQualificationTypeInput = {
    id?: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutQualificationsInput
    grantedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsGrantedInput
    revokedByAdmin?: AdminUserCreateNestedOneWithoutQualificationsRevokedInput
  }

  export type MemberQualificationUncheckedCreateWithoutQualificationTypeInput = {
    id?: string
    memberId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateOrConnectWithoutQualificationTypeInput = {
    where: MemberQualificationWhereUniqueInput
    create: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput>
  }

  export type MemberQualificationCreateManyQualificationTypeInputEnvelope = {
    data: MemberQualificationCreateManyQualificationTypeInput | MemberQualificationCreateManyQualificationTypeInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutQualificationTypesInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutQualificationTypesInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    chipVariant?: string
    chipColor?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutQualificationTypesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutQualificationTypesInput, TagUncheckedCreateWithoutQualificationTypesInput>
  }

  export type MemberQualificationUpsertWithWhereUniqueWithoutQualificationTypeInput = {
    where: MemberQualificationWhereUniqueInput
    update: XOR<MemberQualificationUpdateWithoutQualificationTypeInput, MemberQualificationUncheckedUpdateWithoutQualificationTypeInput>
    create: XOR<MemberQualificationCreateWithoutQualificationTypeInput, MemberQualificationUncheckedCreateWithoutQualificationTypeInput>
  }

  export type MemberQualificationUpdateWithWhereUniqueWithoutQualificationTypeInput = {
    where: MemberQualificationWhereUniqueInput
    data: XOR<MemberQualificationUpdateWithoutQualificationTypeInput, MemberQualificationUncheckedUpdateWithoutQualificationTypeInput>
  }

  export type MemberQualificationUpdateManyWithWhereWithoutQualificationTypeInput = {
    where: MemberQualificationScalarWhereInput
    data: XOR<MemberQualificationUpdateManyMutationInput, MemberQualificationUncheckedUpdateManyWithoutQualificationTypeInput>
  }

  export type TagUpsertWithoutQualificationTypesInput = {
    update: XOR<TagUpdateWithoutQualificationTypesInput, TagUncheckedUpdateWithoutQualificationTypesInput>
    create: XOR<TagCreateWithoutQualificationTypesInput, TagUncheckedCreateWithoutQualificationTypesInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutQualificationTypesInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutQualificationTypesInput, TagUncheckedUpdateWithoutQualificationTypesInput>
  }

  export type TagUpdateWithoutQualificationTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutQualificationTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    chipVariant?: StringFieldUpdateOperationsInput | string
    chipColor?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type MemberCreateWithoutQualificationsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutQualificationsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutQualificationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutQualificationsInput, MemberUncheckedCreateWithoutQualificationsInput>
  }

  export type QualificationTypeCreateWithoutMemberQualificationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tag?: TagCreateNestedOneWithoutQualificationTypesInput
  }

  export type QualificationTypeUncheckedCreateWithoutMemberQualificationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    tagId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualificationTypeCreateOrConnectWithoutMemberQualificationsInput = {
    where: QualificationTypeWhereUniqueInput
    create: XOR<QualificationTypeCreateWithoutMemberQualificationsInput, QualificationTypeUncheckedCreateWithoutMemberQualificationsInput>
  }

  export type AdminUserCreateWithoutQualificationsGrantedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutQualificationsGrantedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutQualificationsGrantedInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutQualificationsGrantedInput, AdminUserUncheckedCreateWithoutQualificationsGrantedInput>
  }

  export type AdminUserCreateWithoutQualificationsRevokedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutQualificationsRevokedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutQualificationsRevokedInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutQualificationsRevokedInput, AdminUserUncheckedCreateWithoutQualificationsRevokedInput>
  }

  export type MemberUpsertWithoutQualificationsInput = {
    update: XOR<MemberUpdateWithoutQualificationsInput, MemberUncheckedUpdateWithoutQualificationsInput>
    create: XOR<MemberCreateWithoutQualificationsInput, MemberUncheckedCreateWithoutQualificationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutQualificationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutQualificationsInput, MemberUncheckedUpdateWithoutQualificationsInput>
  }

  export type MemberUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type QualificationTypeUpsertWithoutMemberQualificationsInput = {
    update: XOR<QualificationTypeUpdateWithoutMemberQualificationsInput, QualificationTypeUncheckedUpdateWithoutMemberQualificationsInput>
    create: XOR<QualificationTypeCreateWithoutMemberQualificationsInput, QualificationTypeUncheckedCreateWithoutMemberQualificationsInput>
    where?: QualificationTypeWhereInput
  }

  export type QualificationTypeUpdateToOneWithWhereWithoutMemberQualificationsInput = {
    where?: QualificationTypeWhereInput
    data: XOR<QualificationTypeUpdateWithoutMemberQualificationsInput, QualificationTypeUncheckedUpdateWithoutMemberQualificationsInput>
  }

  export type QualificationTypeUpdateWithoutMemberQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneWithoutQualificationTypesNestedInput
  }

  export type QualificationTypeUncheckedUpdateWithoutMemberQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUpsertWithoutQualificationsGrantedInput = {
    update: XOR<AdminUserUpdateWithoutQualificationsGrantedInput, AdminUserUncheckedUpdateWithoutQualificationsGrantedInput>
    create: XOR<AdminUserCreateWithoutQualificationsGrantedInput, AdminUserUncheckedCreateWithoutQualificationsGrantedInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutQualificationsGrantedInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutQualificationsGrantedInput, AdminUserUncheckedUpdateWithoutQualificationsGrantedInput>
  }

  export type AdminUserUpdateWithoutQualificationsGrantedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutQualificationsGrantedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUpsertWithoutQualificationsRevokedInput = {
    update: XOR<AdminUserUpdateWithoutQualificationsRevokedInput, AdminUserUncheckedUpdateWithoutQualificationsRevokedInput>
    create: XOR<AdminUserCreateWithoutQualificationsRevokedInput, AdminUserUncheckedCreateWithoutQualificationsRevokedInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutQualificationsRevokedInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutQualificationsRevokedInput, AdminUserUncheckedUpdateWithoutQualificationsRevokedInput>
  }

  export type AdminUserUpdateWithoutQualificationsRevokedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutQualificationsRevokedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type DutyPositionCreateWithoutDutyRoleInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentCreateNestedManyWithoutDutyPositionInput
  }

  export type DutyPositionUncheckedCreateWithoutDutyRoleInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutDutyPositionInput
  }

  export type DutyPositionCreateOrConnectWithoutDutyRoleInput = {
    where: DutyPositionWhereUniqueInput
    create: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput>
  }

  export type DutyPositionCreateManyDutyRoleInputEnvelope = {
    data: DutyPositionCreateManyDutyRoleInput | DutyPositionCreateManyDutyRoleInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyScheduleCreateWithoutDutyRoleInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin?: AdminUserCreateNestedOneWithoutSchedulesCreatedInput
    publishedByAdmin?: AdminUserCreateNestedOneWithoutSchedulesPublishedInput
    assignments?: ScheduleAssignmentCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleUncheckedCreateWithoutDutyRoleInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type WeeklyScheduleCreateOrConnectWithoutDutyRoleInput = {
    where: WeeklyScheduleWhereUniqueInput
    create: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput>
  }

  export type WeeklyScheduleCreateManyDutyRoleInputEnvelope = {
    data: WeeklyScheduleCreateManyDutyRoleInput | WeeklyScheduleCreateManyDutyRoleInput[]
    skipDuplicates?: boolean
  }

  export type DutyPositionUpsertWithWhereUniqueWithoutDutyRoleInput = {
    where: DutyPositionWhereUniqueInput
    update: XOR<DutyPositionUpdateWithoutDutyRoleInput, DutyPositionUncheckedUpdateWithoutDutyRoleInput>
    create: XOR<DutyPositionCreateWithoutDutyRoleInput, DutyPositionUncheckedCreateWithoutDutyRoleInput>
  }

  export type DutyPositionUpdateWithWhereUniqueWithoutDutyRoleInput = {
    where: DutyPositionWhereUniqueInput
    data: XOR<DutyPositionUpdateWithoutDutyRoleInput, DutyPositionUncheckedUpdateWithoutDutyRoleInput>
  }

  export type DutyPositionUpdateManyWithWhereWithoutDutyRoleInput = {
    where: DutyPositionScalarWhereInput
    data: XOR<DutyPositionUpdateManyMutationInput, DutyPositionUncheckedUpdateManyWithoutDutyRoleInput>
  }

  export type DutyPositionScalarWhereInput = {
    AND?: DutyPositionScalarWhereInput | DutyPositionScalarWhereInput[]
    OR?: DutyPositionScalarWhereInput[]
    NOT?: DutyPositionScalarWhereInput | DutyPositionScalarWhereInput[]
    id?: UuidFilter<"DutyPosition"> | string
    dutyRoleId?: UuidFilter<"DutyPosition"> | string
    code?: StringFilter<"DutyPosition"> | string
    name?: StringFilter<"DutyPosition"> | string
    description?: StringNullableFilter<"DutyPosition"> | string | null
    maxSlots?: IntFilter<"DutyPosition"> | number
    displayOrder?: IntFilter<"DutyPosition"> | number
    createdAt?: DateTimeFilter<"DutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"DutyPosition"> | Date | string
  }

  export type WeeklyScheduleUpsertWithWhereUniqueWithoutDutyRoleInput = {
    where: WeeklyScheduleWhereUniqueInput
    update: XOR<WeeklyScheduleUpdateWithoutDutyRoleInput, WeeklyScheduleUncheckedUpdateWithoutDutyRoleInput>
    create: XOR<WeeklyScheduleCreateWithoutDutyRoleInput, WeeklyScheduleUncheckedCreateWithoutDutyRoleInput>
  }

  export type WeeklyScheduleUpdateWithWhereUniqueWithoutDutyRoleInput = {
    where: WeeklyScheduleWhereUniqueInput
    data: XOR<WeeklyScheduleUpdateWithoutDutyRoleInput, WeeklyScheduleUncheckedUpdateWithoutDutyRoleInput>
  }

  export type WeeklyScheduleUpdateManyWithWhereWithoutDutyRoleInput = {
    where: WeeklyScheduleScalarWhereInput
    data: XOR<WeeklyScheduleUpdateManyMutationInput, WeeklyScheduleUncheckedUpdateManyWithoutDutyRoleInput>
  }

  export type DutyRoleCreateWithoutPositionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: WeeklyScheduleCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleUncheckedCreateWithoutPositionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: WeeklyScheduleUncheckedCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleCreateOrConnectWithoutPositionsInput = {
    where: DutyRoleWhereUniqueInput
    create: XOR<DutyRoleCreateWithoutPositionsInput, DutyRoleUncheckedCreateWithoutPositionsInput>
  }

  export type ScheduleAssignmentCreateWithoutDutyPositionInput = {
    id?: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: WeeklyScheduleCreateNestedOneWithoutAssignmentsInput
    member: MemberCreateNestedOneWithoutScheduleAssignmentsInput
  }

  export type ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput = {
    id?: string
    scheduleId: string
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentCreateOrConnectWithoutDutyPositionInput = {
    where: ScheduleAssignmentWhereUniqueInput
    create: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput>
  }

  export type ScheduleAssignmentCreateManyDutyPositionInputEnvelope = {
    data: ScheduleAssignmentCreateManyDutyPositionInput | ScheduleAssignmentCreateManyDutyPositionInput[]
    skipDuplicates?: boolean
  }

  export type DutyRoleUpsertWithoutPositionsInput = {
    update: XOR<DutyRoleUpdateWithoutPositionsInput, DutyRoleUncheckedUpdateWithoutPositionsInput>
    create: XOR<DutyRoleCreateWithoutPositionsInput, DutyRoleUncheckedCreateWithoutPositionsInput>
    where?: DutyRoleWhereInput
  }

  export type DutyRoleUpdateToOneWithWhereWithoutPositionsInput = {
    where?: DutyRoleWhereInput
    data: XOR<DutyRoleUpdateWithoutPositionsInput, DutyRoleUncheckedUpdateWithoutPositionsInput>
  }

  export type DutyRoleUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: WeeklyScheduleUpdateManyWithoutDutyRoleNestedInput
  }

  export type DutyRoleUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: WeeklyScheduleUncheckedUpdateManyWithoutDutyRoleNestedInput
  }

  export type ScheduleAssignmentUpsertWithWhereUniqueWithoutDutyPositionInput = {
    where: ScheduleAssignmentWhereUniqueInput
    update: XOR<ScheduleAssignmentUpdateWithoutDutyPositionInput, ScheduleAssignmentUncheckedUpdateWithoutDutyPositionInput>
    create: XOR<ScheduleAssignmentCreateWithoutDutyPositionInput, ScheduleAssignmentUncheckedCreateWithoutDutyPositionInput>
  }

  export type ScheduleAssignmentUpdateWithWhereUniqueWithoutDutyPositionInput = {
    where: ScheduleAssignmentWhereUniqueInput
    data: XOR<ScheduleAssignmentUpdateWithoutDutyPositionInput, ScheduleAssignmentUncheckedUpdateWithoutDutyPositionInput>
  }

  export type ScheduleAssignmentUpdateManyWithWhereWithoutDutyPositionInput = {
    where: ScheduleAssignmentScalarWhereInput
    data: XOR<ScheduleAssignmentUpdateManyMutationInput, ScheduleAssignmentUncheckedUpdateManyWithoutDutyPositionInput>
  }

  export type DutyRoleCreateWithoutSchedulesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: DutyPositionCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleUncheckedCreateWithoutSchedulesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    roleType: string
    scheduleType: string
    activeDays?: DutyRoleCreateactiveDaysInput | number[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: DutyPositionUncheckedCreateNestedManyWithoutDutyRoleInput
  }

  export type DutyRoleCreateOrConnectWithoutSchedulesInput = {
    where: DutyRoleWhereUniqueInput
    create: XOR<DutyRoleCreateWithoutSchedulesInput, DutyRoleUncheckedCreateWithoutSchedulesInput>
  }

  export type AdminUserCreateWithoutSchedulesCreatedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutSchedulesCreatedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutSchedulesCreatedInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutSchedulesCreatedInput, AdminUserUncheckedCreateWithoutSchedulesCreatedInput>
  }

  export type AdminUserCreateWithoutSchedulesPublishedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutSchedulesPublishedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedCreateNestedManyWithoutResolvedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutSchedulesPublishedInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutSchedulesPublishedInput, AdminUserUncheckedCreateWithoutSchedulesPublishedInput>
  }

  export type ScheduleAssignmentCreateWithoutScheduleInput = {
    id?: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyPosition?: DutyPositionCreateNestedOneWithoutAssignmentsInput
    member: MemberCreateNestedOneWithoutScheduleAssignmentsInput
  }

  export type ScheduleAssignmentUncheckedCreateWithoutScheduleInput = {
    id?: string
    dutyPositionId?: string | null
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentCreateOrConnectWithoutScheduleInput = {
    where: ScheduleAssignmentWhereUniqueInput
    create: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleAssignmentCreateManyScheduleInputEnvelope = {
    data: ScheduleAssignmentCreateManyScheduleInput | ScheduleAssignmentCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type DutyRoleUpsertWithoutSchedulesInput = {
    update: XOR<DutyRoleUpdateWithoutSchedulesInput, DutyRoleUncheckedUpdateWithoutSchedulesInput>
    create: XOR<DutyRoleCreateWithoutSchedulesInput, DutyRoleUncheckedCreateWithoutSchedulesInput>
    where?: DutyRoleWhereInput
  }

  export type DutyRoleUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: DutyRoleWhereInput
    data: XOR<DutyRoleUpdateWithoutSchedulesInput, DutyRoleUncheckedUpdateWithoutSchedulesInput>
  }

  export type DutyRoleUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: DutyPositionUpdateManyWithoutDutyRoleNestedInput
  }

  export type DutyRoleUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roleType?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    activeDays?: DutyRoleUpdateactiveDaysInput | number[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: DutyPositionUncheckedUpdateManyWithoutDutyRoleNestedInput
  }

  export type AdminUserUpsertWithoutSchedulesCreatedInput = {
    update: XOR<AdminUserUpdateWithoutSchedulesCreatedInput, AdminUserUncheckedUpdateWithoutSchedulesCreatedInput>
    create: XOR<AdminUserCreateWithoutSchedulesCreatedInput, AdminUserUncheckedCreateWithoutSchedulesCreatedInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutSchedulesCreatedInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutSchedulesCreatedInput, AdminUserUncheckedUpdateWithoutSchedulesCreatedInput>
  }

  export type AdminUserUpdateWithoutSchedulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutSchedulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUpsertWithoutSchedulesPublishedInput = {
    update: XOR<AdminUserUpdateWithoutSchedulesPublishedInput, AdminUserUncheckedUpdateWithoutSchedulesPublishedInput>
    create: XOR<AdminUserCreateWithoutSchedulesPublishedInput, AdminUserUncheckedCreateWithoutSchedulesPublishedInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutSchedulesPublishedInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutSchedulesPublishedInput, AdminUserUncheckedUpdateWithoutSchedulesPublishedInput>
  }

  export type AdminUserUpdateWithoutSchedulesPublishedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutSchedulesPublishedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type ScheduleAssignmentUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleAssignmentWhereUniqueInput
    update: XOR<ScheduleAssignmentUpdateWithoutScheduleInput, ScheduleAssignmentUncheckedUpdateWithoutScheduleInput>
    create: XOR<ScheduleAssignmentCreateWithoutScheduleInput, ScheduleAssignmentUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleAssignmentUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleAssignmentWhereUniqueInput
    data: XOR<ScheduleAssignmentUpdateWithoutScheduleInput, ScheduleAssignmentUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduleAssignmentUpdateManyWithWhereWithoutScheduleInput = {
    where: ScheduleAssignmentScalarWhereInput
    data: XOR<ScheduleAssignmentUpdateManyMutationInput, ScheduleAssignmentUncheckedUpdateManyWithoutScheduleInput>
  }

  export type WeeklyScheduleCreateWithoutAssignmentsInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutSchedulesInput
    createdByAdmin?: AdminUserCreateNestedOneWithoutSchedulesCreatedInput
    publishedByAdmin?: AdminUserCreateNestedOneWithoutSchedulesPublishedInput
  }

  export type WeeklyScheduleUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyScheduleCreateOrConnectWithoutAssignmentsInput = {
    where: WeeklyScheduleWhereUniqueInput
    create: XOR<WeeklyScheduleCreateWithoutAssignmentsInput, WeeklyScheduleUncheckedCreateWithoutAssignmentsInput>
  }

  export type DutyPositionCreateWithoutAssignmentsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyRole: DutyRoleCreateNestedOneWithoutPositionsInput
  }

  export type DutyPositionUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    dutyRoleId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyPositionCreateOrConnectWithoutAssignmentsInput = {
    where: DutyPositionWhereUniqueInput
    create: XOR<DutyPositionCreateWithoutAssignmentsInput, DutyPositionUncheckedCreateWithoutAssignmentsInput>
  }

  export type MemberCreateWithoutScheduleAssignmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutScheduleAssignmentsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutScheduleAssignmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutScheduleAssignmentsInput, MemberUncheckedCreateWithoutScheduleAssignmentsInput>
  }

  export type WeeklyScheduleUpsertWithoutAssignmentsInput = {
    update: XOR<WeeklyScheduleUpdateWithoutAssignmentsInput, WeeklyScheduleUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<WeeklyScheduleCreateWithoutAssignmentsInput, WeeklyScheduleUncheckedCreateWithoutAssignmentsInput>
    where?: WeeklyScheduleWhereInput
  }

  export type WeeklyScheduleUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: WeeklyScheduleWhereInput
    data: XOR<WeeklyScheduleUpdateWithoutAssignmentsInput, WeeklyScheduleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type WeeklyScheduleUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutSchedulesNestedInput
    createdByAdmin?: AdminUserUpdateOneWithoutSchedulesCreatedNestedInput
    publishedByAdmin?: AdminUserUpdateOneWithoutSchedulesPublishedNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyPositionUpsertWithoutAssignmentsInput = {
    update: XOR<DutyPositionUpdateWithoutAssignmentsInput, DutyPositionUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<DutyPositionCreateWithoutAssignmentsInput, DutyPositionUncheckedCreateWithoutAssignmentsInput>
    where?: DutyPositionWhereInput
  }

  export type DutyPositionUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: DutyPositionWhereInput
    data: XOR<DutyPositionUpdateWithoutAssignmentsInput, DutyPositionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type DutyPositionUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutPositionsNestedInput
  }

  export type DutyPositionUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpsertWithoutScheduleAssignmentsInput = {
    update: XOR<MemberUpdateWithoutScheduleAssignmentsInput, MemberUncheckedUpdateWithoutScheduleAssignmentsInput>
    create: XOR<MemberCreateWithoutScheduleAssignmentsInput, MemberUncheckedCreateWithoutScheduleAssignmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutScheduleAssignmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutScheduleAssignmentsInput, MemberUncheckedUpdateWithoutScheduleAssignmentsInput>
  }

  export type MemberUpdateWithoutScheduleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutScheduleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutLockupHoldingInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutLockupHoldingInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLockupHoldingInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLockupHoldingInput, MemberUncheckedCreateWithoutLockupHoldingInput>
  }

  export type MemberCreateWithoutLockupSecuredInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutLockupSecuredInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLockupSecuredInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLockupSecuredInput, MemberUncheckedCreateWithoutLockupSecuredInput>
  }

  export type LockupTransferCreateWithoutLockupStatusInput = {
    id?: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
    fromMember: MemberCreateNestedOneWithoutLockupTransfersFromInput
    toMember: MemberCreateNestedOneWithoutLockupTransfersToInput
  }

  export type LockupTransferUncheckedCreateWithoutLockupStatusInput = {
    id?: string
    fromMemberId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferCreateOrConnectWithoutLockupStatusInput = {
    where: LockupTransferWhereUniqueInput
    create: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput>
  }

  export type LockupTransferCreateManyLockupStatusInputEnvelope = {
    data: LockupTransferCreateManyLockupStatusInput | LockupTransferCreateManyLockupStatusInput[]
    skipDuplicates?: boolean
  }

  export type LockupExecutionCreateWithoutLockupStatusInput = {
    id?: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
    executedByMember: MemberCreateNestedOneWithoutLockupExecutionsInput
  }

  export type LockupExecutionUncheckedCreateWithoutLockupStatusInput = {
    id?: string
    executedBy: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupExecutionCreateOrConnectWithoutLockupStatusInput = {
    where: LockupExecutionWhereUniqueInput
    create: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
  }

  export type MemberUpsertWithoutLockupHoldingInput = {
    update: XOR<MemberUpdateWithoutLockupHoldingInput, MemberUncheckedUpdateWithoutLockupHoldingInput>
    create: XOR<MemberCreateWithoutLockupHoldingInput, MemberUncheckedCreateWithoutLockupHoldingInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLockupHoldingInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLockupHoldingInput, MemberUncheckedUpdateWithoutLockupHoldingInput>
  }

  export type MemberUpdateWithoutLockupHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutLockupHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUpsertWithoutLockupSecuredInput = {
    update: XOR<MemberUpdateWithoutLockupSecuredInput, MemberUncheckedUpdateWithoutLockupSecuredInput>
    create: XOR<MemberCreateWithoutLockupSecuredInput, MemberUncheckedCreateWithoutLockupSecuredInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLockupSecuredInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLockupSecuredInput, MemberUncheckedUpdateWithoutLockupSecuredInput>
  }

  export type MemberUpdateWithoutLockupSecuredInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutLockupSecuredInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type LockupTransferUpsertWithWhereUniqueWithoutLockupStatusInput = {
    where: LockupTransferWhereUniqueInput
    update: XOR<LockupTransferUpdateWithoutLockupStatusInput, LockupTransferUncheckedUpdateWithoutLockupStatusInput>
    create: XOR<LockupTransferCreateWithoutLockupStatusInput, LockupTransferUncheckedCreateWithoutLockupStatusInput>
  }

  export type LockupTransferUpdateWithWhereUniqueWithoutLockupStatusInput = {
    where: LockupTransferWhereUniqueInput
    data: XOR<LockupTransferUpdateWithoutLockupStatusInput, LockupTransferUncheckedUpdateWithoutLockupStatusInput>
  }

  export type LockupTransferUpdateManyWithWhereWithoutLockupStatusInput = {
    where: LockupTransferScalarWhereInput
    data: XOR<LockupTransferUpdateManyMutationInput, LockupTransferUncheckedUpdateManyWithoutLockupStatusInput>
  }

  export type LockupExecutionUpsertWithoutLockupStatusInput = {
    update: XOR<LockupExecutionUpdateWithoutLockupStatusInput, LockupExecutionUncheckedUpdateWithoutLockupStatusInput>
    create: XOR<LockupExecutionCreateWithoutLockupStatusInput, LockupExecutionUncheckedCreateWithoutLockupStatusInput>
    where?: LockupExecutionWhereInput
  }

  export type LockupExecutionUpdateToOneWithWhereWithoutLockupStatusInput = {
    where?: LockupExecutionWhereInput
    data: XOR<LockupExecutionUpdateWithoutLockupStatusInput, LockupExecutionUncheckedUpdateWithoutLockupStatusInput>
  }

  export type LockupExecutionUpdateWithoutLockupStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedByMember?: MemberUpdateOneRequiredWithoutLockupExecutionsNestedInput
  }

  export type LockupExecutionUncheckedUpdateWithoutLockupStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupStatusCreateWithoutTransfersInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHolder?: MemberCreateNestedOneWithoutLockupHoldingInput
    securedByMember?: MemberCreateNestedOneWithoutLockupSecuredInput
    execution?: LockupExecutionCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusUncheckedCreateWithoutTransfersInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    execution?: LockupExecutionUncheckedCreateNestedOneWithoutLockupStatusInput
  }

  export type LockupStatusCreateOrConnectWithoutTransfersInput = {
    where: LockupStatusWhereUniqueInput
    create: XOR<LockupStatusCreateWithoutTransfersInput, LockupStatusUncheckedCreateWithoutTransfersInput>
  }

  export type MemberCreateWithoutLockupTransfersFromInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutLockupTransfersFromInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLockupTransfersFromInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLockupTransfersFromInput, MemberUncheckedCreateWithoutLockupTransfersFromInput>
  }

  export type MemberCreateWithoutLockupTransfersToInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutLockupTransfersToInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLockupTransfersToInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLockupTransfersToInput, MemberUncheckedCreateWithoutLockupTransfersToInput>
  }

  export type LockupStatusUpsertWithoutTransfersInput = {
    update: XOR<LockupStatusUpdateWithoutTransfersInput, LockupStatusUncheckedUpdateWithoutTransfersInput>
    create: XOR<LockupStatusCreateWithoutTransfersInput, LockupStatusUncheckedCreateWithoutTransfersInput>
    where?: LockupStatusWhereInput
  }

  export type LockupStatusUpdateToOneWithWhereWithoutTransfersInput = {
    where?: LockupStatusWhereInput
    data: XOR<LockupStatusUpdateWithoutTransfersInput, LockupStatusUncheckedUpdateWithoutTransfersInput>
  }

  export type LockupStatusUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolder?: MemberUpdateOneWithoutLockupHoldingNestedInput
    securedByMember?: MemberUpdateOneWithoutLockupSecuredNestedInput
    execution?: LockupExecutionUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: LockupExecutionUncheckedUpdateOneWithoutLockupStatusNestedInput
  }

  export type MemberUpsertWithoutLockupTransfersFromInput = {
    update: XOR<MemberUpdateWithoutLockupTransfersFromInput, MemberUncheckedUpdateWithoutLockupTransfersFromInput>
    create: XOR<MemberCreateWithoutLockupTransfersFromInput, MemberUncheckedCreateWithoutLockupTransfersFromInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLockupTransfersFromInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLockupTransfersFromInput, MemberUncheckedUpdateWithoutLockupTransfersFromInput>
  }

  export type MemberUpdateWithoutLockupTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutLockupTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUpsertWithoutLockupTransfersToInput = {
    update: XOR<MemberUpdateWithoutLockupTransfersToInput, MemberUncheckedUpdateWithoutLockupTransfersToInput>
    create: XOR<MemberCreateWithoutLockupTransfersToInput, MemberUncheckedCreateWithoutLockupTransfersToInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLockupTransfersToInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLockupTransfersToInput, MemberUncheckedUpdateWithoutLockupTransfersToInput>
  }

  export type MemberUpdateWithoutLockupTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutLockupTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type LockupStatusCreateWithoutExecutionInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHolder?: MemberCreateNestedOneWithoutLockupHoldingInput
    securedByMember?: MemberCreateNestedOneWithoutLockupSecuredInput
    transfers?: LockupTransferCreateNestedManyWithoutLockupStatusInput
  }

  export type LockupStatusUncheckedCreateWithoutExecutionInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transfers?: LockupTransferUncheckedCreateNestedManyWithoutLockupStatusInput
  }

  export type LockupStatusCreateOrConnectWithoutExecutionInput = {
    where: LockupStatusWhereUniqueInput
    create: XOR<LockupStatusCreateWithoutExecutionInput, LockupStatusUncheckedCreateWithoutExecutionInput>
  }

  export type MemberCreateWithoutLockupExecutionsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutLockupExecutionsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLockupExecutionsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLockupExecutionsInput, MemberUncheckedCreateWithoutLockupExecutionsInput>
  }

  export type LockupStatusUpsertWithoutExecutionInput = {
    update: XOR<LockupStatusUpdateWithoutExecutionInput, LockupStatusUncheckedUpdateWithoutExecutionInput>
    create: XOR<LockupStatusCreateWithoutExecutionInput, LockupStatusUncheckedCreateWithoutExecutionInput>
    where?: LockupStatusWhereInput
  }

  export type LockupStatusUpdateToOneWithWhereWithoutExecutionInput = {
    where?: LockupStatusWhereInput
    data: XOR<LockupStatusUpdateWithoutExecutionInput, LockupStatusUncheckedUpdateWithoutExecutionInput>
  }

  export type LockupStatusUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolder?: MemberUpdateOneWithoutLockupHoldingNestedInput
    securedByMember?: MemberUpdateOneWithoutLockupSecuredNestedInput
    transfers?: LockupTransferUpdateManyWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfers?: LockupTransferUncheckedUpdateManyWithoutLockupStatusNestedInput
  }

  export type MemberUpsertWithoutLockupExecutionsInput = {
    update: XOR<MemberUpdateWithoutLockupExecutionsInput, MemberUncheckedUpdateWithoutLockupExecutionsInput>
    create: XOR<MemberCreateWithoutLockupExecutionsInput, MemberUncheckedCreateWithoutLockupExecutionsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLockupExecutionsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLockupExecutionsInput, MemberUncheckedUpdateWithoutLockupExecutionsInput>
  }

  export type MemberUpdateWithoutLockupExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutLockupExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutMissedCheckoutsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMissedCheckoutsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMissedCheckoutsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMissedCheckoutsInput, MemberUncheckedCreateWithoutMissedCheckoutsInput>
  }

  export type AdminUserCreateWithoutMissedCheckoutsResolvedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleCreateNestedManyWithoutPublishedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutMissedCheckoutsResolvedInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
    qualificationsGranted?: MemberQualificationUncheckedCreateNestedManyWithoutGrantedByAdminInput
    qualificationsRevoked?: MemberQualificationUncheckedCreateNestedManyWithoutRevokedByAdminInput
    schedulesCreated?: WeeklyScheduleUncheckedCreateNestedManyWithoutCreatedByAdminInput
    schedulesPublished?: WeeklyScheduleUncheckedCreateNestedManyWithoutPublishedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutMissedCheckoutsResolvedInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedCreateWithoutMissedCheckoutsResolvedInput>
  }

  export type MemberUpsertWithoutMissedCheckoutsInput = {
    update: XOR<MemberUpdateWithoutMissedCheckoutsInput, MemberUncheckedUpdateWithoutMissedCheckoutsInput>
    create: XOR<MemberCreateWithoutMissedCheckoutsInput, MemberUncheckedCreateWithoutMissedCheckoutsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMissedCheckoutsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMissedCheckoutsInput, MemberUncheckedUpdateWithoutMissedCheckoutsInput>
  }

  export type MemberUpdateWithoutMissedCheckoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMissedCheckoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AdminUserUpsertWithoutMissedCheckoutsResolvedInput = {
    update: XOR<AdminUserUpdateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedUpdateWithoutMissedCheckoutsResolvedInput>
    create: XOR<AdminUserCreateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedCreateWithoutMissedCheckoutsResolvedInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutMissedCheckoutsResolvedInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutMissedCheckoutsResolvedInput, AdminUserUncheckedUpdateWithoutMissedCheckoutsResolvedInput>
  }

  export type AdminUserUpdateWithoutMissedCheckoutsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutMissedCheckoutsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
  }

  export type UnitEventCreateWithoutEventTypeInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyPositions?: UnitEventDutyPositionCreateNestedManyWithoutEventInput
    dutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutEventInput
  }

  export type UnitEventUncheckedCreateWithoutEventTypeInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedCreateNestedManyWithoutEventInput
    dutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventInput
  }

  export type UnitEventCreateOrConnectWithoutEventTypeInput = {
    where: UnitEventWhereUniqueInput
    create: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput>
  }

  export type UnitEventCreateManyEventTypeInputEnvelope = {
    data: UnitEventCreateManyEventTypeInput | UnitEventCreateManyEventTypeInput[]
    skipDuplicates?: boolean
  }

  export type UnitEventUpsertWithWhereUniqueWithoutEventTypeInput = {
    where: UnitEventWhereUniqueInput
    update: XOR<UnitEventUpdateWithoutEventTypeInput, UnitEventUncheckedUpdateWithoutEventTypeInput>
    create: XOR<UnitEventCreateWithoutEventTypeInput, UnitEventUncheckedCreateWithoutEventTypeInput>
  }

  export type UnitEventUpdateWithWhereUniqueWithoutEventTypeInput = {
    where: UnitEventWhereUniqueInput
    data: XOR<UnitEventUpdateWithoutEventTypeInput, UnitEventUncheckedUpdateWithoutEventTypeInput>
  }

  export type UnitEventUpdateManyWithWhereWithoutEventTypeInput = {
    where: UnitEventScalarWhereInput
    data: XOR<UnitEventUpdateManyMutationInput, UnitEventUncheckedUpdateManyWithoutEventTypeInput>
  }

  export type UnitEventScalarWhereInput = {
    AND?: UnitEventScalarWhereInput | UnitEventScalarWhereInput[]
    OR?: UnitEventScalarWhereInput[]
    NOT?: UnitEventScalarWhereInput | UnitEventScalarWhereInput[]
    id?: UuidFilter<"UnitEvent"> | string
    title?: StringFilter<"UnitEvent"> | string
    eventTypeId?: UuidNullableFilter<"UnitEvent"> | string | null
    eventDate?: DateTimeFilter<"UnitEvent"> | Date | string
    startTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    endTime?: DateTimeNullableFilter<"UnitEvent"> | Date | string | null
    location?: StringNullableFilter<"UnitEvent"> | string | null
    description?: StringNullableFilter<"UnitEvent"> | string | null
    organizer?: StringNullableFilter<"UnitEvent"> | string | null
    requiresDutyWatch?: BoolFilter<"UnitEvent"> | boolean
    status?: StringFilter<"UnitEvent"> | string
    metadata?: JsonNullableFilter<"UnitEvent">
    notes?: StringNullableFilter<"UnitEvent"> | string | null
    createdBy?: UuidNullableFilter<"UnitEvent"> | string | null
    createdAt?: DateTimeFilter<"UnitEvent"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEvent"> | Date | string
  }

  export type UnitEventTypeCreateWithoutUnitEventsInput = {
    id?: string
    name: string
    category: string
    defaultDurationMinutes?: number
    requiresDutyWatch?: boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventTypeUncheckedCreateWithoutUnitEventsInput = {
    id?: string
    name: string
    category: string
    defaultDurationMinutes?: number
    requiresDutyWatch?: boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventTypeCreateOrConnectWithoutUnitEventsInput = {
    where: UnitEventTypeWhereUniqueInput
    create: XOR<UnitEventTypeCreateWithoutUnitEventsInput, UnitEventTypeUncheckedCreateWithoutUnitEventsInput>
  }

  export type UnitEventDutyPositionCreateWithoutEventInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: UnitEventDutyAssignmentCreateNestedManyWithoutEventDutyPositionInput
  }

  export type UnitEventDutyPositionUncheckedCreateWithoutEventInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventDutyPositionInput
  }

  export type UnitEventDutyPositionCreateOrConnectWithoutEventInput = {
    where: UnitEventDutyPositionWhereUniqueInput
    create: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput>
  }

  export type UnitEventDutyPositionCreateManyEventInputEnvelope = {
    data: UnitEventDutyPositionCreateManyEventInput | UnitEventDutyPositionCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UnitEventDutyAssignmentCreateWithoutEventInput = {
    id?: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventDutyPosition?: UnitEventDutyPositionCreateNestedOneWithoutAssignmentsInput
    member: MemberCreateNestedOneWithoutUnitEventDutyAssignmentsInput
  }

  export type UnitEventDutyAssignmentUncheckedCreateWithoutEventInput = {
    id?: string
    eventDutyPositionId?: string | null
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentCreateOrConnectWithoutEventInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    create: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput>
  }

  export type UnitEventDutyAssignmentCreateManyEventInputEnvelope = {
    data: UnitEventDutyAssignmentCreateManyEventInput | UnitEventDutyAssignmentCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UnitEventTypeUpsertWithoutUnitEventsInput = {
    update: XOR<UnitEventTypeUpdateWithoutUnitEventsInput, UnitEventTypeUncheckedUpdateWithoutUnitEventsInput>
    create: XOR<UnitEventTypeCreateWithoutUnitEventsInput, UnitEventTypeUncheckedCreateWithoutUnitEventsInput>
    where?: UnitEventTypeWhereInput
  }

  export type UnitEventTypeUpdateToOneWithWhereWithoutUnitEventsInput = {
    where?: UnitEventTypeWhereInput
    data: XOR<UnitEventTypeUpdateWithoutUnitEventsInput, UnitEventTypeUncheckedUpdateWithoutUnitEventsInput>
  }

  export type UnitEventTypeUpdateWithoutUnitEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventTypeUncheckedUpdateWithoutUnitEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    defaultDurationMinutes?: IntFieldUpdateOperationsInput | number
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    defaultMetadata?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyPositionUpsertWithWhereUniqueWithoutEventInput = {
    where: UnitEventDutyPositionWhereUniqueInput
    update: XOR<UnitEventDutyPositionUpdateWithoutEventInput, UnitEventDutyPositionUncheckedUpdateWithoutEventInput>
    create: XOR<UnitEventDutyPositionCreateWithoutEventInput, UnitEventDutyPositionUncheckedCreateWithoutEventInput>
  }

  export type UnitEventDutyPositionUpdateWithWhereUniqueWithoutEventInput = {
    where: UnitEventDutyPositionWhereUniqueInput
    data: XOR<UnitEventDutyPositionUpdateWithoutEventInput, UnitEventDutyPositionUncheckedUpdateWithoutEventInput>
  }

  export type UnitEventDutyPositionUpdateManyWithWhereWithoutEventInput = {
    where: UnitEventDutyPositionScalarWhereInput
    data: XOR<UnitEventDutyPositionUpdateManyMutationInput, UnitEventDutyPositionUncheckedUpdateManyWithoutEventInput>
  }

  export type UnitEventDutyPositionScalarWhereInput = {
    AND?: UnitEventDutyPositionScalarWhereInput | UnitEventDutyPositionScalarWhereInput[]
    OR?: UnitEventDutyPositionScalarWhereInput[]
    NOT?: UnitEventDutyPositionScalarWhereInput | UnitEventDutyPositionScalarWhereInput[]
    id?: UuidFilter<"UnitEventDutyPosition"> | string
    eventId?: UuidFilter<"UnitEventDutyPosition"> | string
    code?: StringFilter<"UnitEventDutyPosition"> | string
    name?: StringFilter<"UnitEventDutyPosition"> | string
    description?: StringNullableFilter<"UnitEventDutyPosition"> | string | null
    maxSlots?: IntFilter<"UnitEventDutyPosition"> | number
    isStandard?: BoolFilter<"UnitEventDutyPosition"> | boolean
    displayOrder?: IntFilter<"UnitEventDutyPosition"> | number
    createdAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
    updatedAt?: DateTimeFilter<"UnitEventDutyPosition"> | Date | string
  }

  export type UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    update: XOR<UnitEventDutyAssignmentUpdateWithoutEventInput, UnitEventDutyAssignmentUncheckedUpdateWithoutEventInput>
    create: XOR<UnitEventDutyAssignmentCreateWithoutEventInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventInput>
  }

  export type UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    data: XOR<UnitEventDutyAssignmentUpdateWithoutEventInput, UnitEventDutyAssignmentUncheckedUpdateWithoutEventInput>
  }

  export type UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventInput = {
    where: UnitEventDutyAssignmentScalarWhereInput
    data: XOR<UnitEventDutyAssignmentUpdateManyMutationInput, UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventInput>
  }

  export type UnitEventCreateWithoutDutyPositionsInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: UnitEventTypeCreateNestedOneWithoutUnitEventsInput
    dutyAssignments?: UnitEventDutyAssignmentCreateNestedManyWithoutEventInput
  }

  export type UnitEventUncheckedCreateWithoutDutyPositionsInput = {
    id?: string
    title: string
    eventTypeId?: string | null
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyAssignments?: UnitEventDutyAssignmentUncheckedCreateNestedManyWithoutEventInput
  }

  export type UnitEventCreateOrConnectWithoutDutyPositionsInput = {
    where: UnitEventWhereUniqueInput
    create: XOR<UnitEventCreateWithoutDutyPositionsInput, UnitEventUncheckedCreateWithoutDutyPositionsInput>
  }

  export type UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput = {
    id?: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: UnitEventCreateNestedOneWithoutDutyAssignmentsInput
    member: MemberCreateNestedOneWithoutUnitEventDutyAssignmentsInput
  }

  export type UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput = {
    id?: string
    eventId: string
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentCreateOrConnectWithoutEventDutyPositionInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    create: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput>
  }

  export type UnitEventDutyAssignmentCreateManyEventDutyPositionInputEnvelope = {
    data: UnitEventDutyAssignmentCreateManyEventDutyPositionInput | UnitEventDutyAssignmentCreateManyEventDutyPositionInput[]
    skipDuplicates?: boolean
  }

  export type UnitEventUpsertWithoutDutyPositionsInput = {
    update: XOR<UnitEventUpdateWithoutDutyPositionsInput, UnitEventUncheckedUpdateWithoutDutyPositionsInput>
    create: XOR<UnitEventCreateWithoutDutyPositionsInput, UnitEventUncheckedCreateWithoutDutyPositionsInput>
    where?: UnitEventWhereInput
  }

  export type UnitEventUpdateToOneWithWhereWithoutDutyPositionsInput = {
    where?: UnitEventWhereInput
    data: XOR<UnitEventUpdateWithoutDutyPositionsInput, UnitEventUncheckedUpdateWithoutDutyPositionsInput>
  }

  export type UnitEventUpdateWithoutDutyPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: UnitEventTypeUpdateOneWithoutUnitEventsNestedInput
    dutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutEventNestedInput
  }

  export type UnitEventUncheckedUpdateWithoutDutyPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UnitEventDutyAssignmentUpsertWithWhereUniqueWithoutEventDutyPositionInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    update: XOR<UnitEventDutyAssignmentUpdateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedUpdateWithoutEventDutyPositionInput>
    create: XOR<UnitEventDutyAssignmentCreateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedCreateWithoutEventDutyPositionInput>
  }

  export type UnitEventDutyAssignmentUpdateWithWhereUniqueWithoutEventDutyPositionInput = {
    where: UnitEventDutyAssignmentWhereUniqueInput
    data: XOR<UnitEventDutyAssignmentUpdateWithoutEventDutyPositionInput, UnitEventDutyAssignmentUncheckedUpdateWithoutEventDutyPositionInput>
  }

  export type UnitEventDutyAssignmentUpdateManyWithWhereWithoutEventDutyPositionInput = {
    where: UnitEventDutyAssignmentScalarWhereInput
    data: XOR<UnitEventDutyAssignmentUpdateManyMutationInput, UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventDutyPositionInput>
  }

  export type UnitEventCreateWithoutDutyAssignmentsInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: UnitEventTypeCreateNestedOneWithoutUnitEventsInput
    dutyPositions?: UnitEventDutyPositionCreateNestedManyWithoutEventInput
  }

  export type UnitEventUncheckedCreateWithoutDutyAssignmentsInput = {
    id?: string
    title: string
    eventTypeId?: string | null
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedCreateNestedManyWithoutEventInput
  }

  export type UnitEventCreateOrConnectWithoutDutyAssignmentsInput = {
    where: UnitEventWhereUniqueInput
    create: XOR<UnitEventCreateWithoutDutyAssignmentsInput, UnitEventUncheckedCreateWithoutDutyAssignmentsInput>
  }

  export type UnitEventDutyPositionCreateWithoutAssignmentsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    event: UnitEventCreateNestedOneWithoutDutyPositionsInput
  }

  export type UnitEventDutyPositionUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    eventId: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyPositionCreateOrConnectWithoutAssignmentsInput = {
    where: UnitEventDutyPositionWhereUniqueInput
    create: XOR<UnitEventDutyPositionCreateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedCreateWithoutAssignmentsInput>
  }

  export type MemberCreateWithoutUnitEventDutyAssignmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    rankRef?: RankCreateNestedOneWithoutMembersInput
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
    qualifications?: MemberQualificationCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutUnitEventDutyAssignmentsInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
    qualifications?: MemberQualificationUncheckedCreateNestedManyWithoutMemberInput
    scheduleAssignments?: ScheduleAssignmentUncheckedCreateNestedManyWithoutMemberInput
    lockupHolding?: LockupStatusUncheckedCreateNestedManyWithoutCurrentHolderInput
    lockupSecured?: LockupStatusUncheckedCreateNestedManyWithoutSecuredByMemberInput
    lockupTransfersFrom?: LockupTransferUncheckedCreateNestedManyWithoutFromMemberInput
    lockupTransfersTo?: LockupTransferUncheckedCreateNestedManyWithoutToMemberInput
    lockupExecutions?: LockupExecutionUncheckedCreateNestedManyWithoutExecutedByMemberInput
    missedCheckouts?: MissedCheckoutUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutUnitEventDutyAssignmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedCreateWithoutUnitEventDutyAssignmentsInput>
  }

  export type UnitEventUpsertWithoutDutyAssignmentsInput = {
    update: XOR<UnitEventUpdateWithoutDutyAssignmentsInput, UnitEventUncheckedUpdateWithoutDutyAssignmentsInput>
    create: XOR<UnitEventCreateWithoutDutyAssignmentsInput, UnitEventUncheckedCreateWithoutDutyAssignmentsInput>
    where?: UnitEventWhereInput
  }

  export type UnitEventUpdateToOneWithWhereWithoutDutyAssignmentsInput = {
    where?: UnitEventWhereInput
    data: XOR<UnitEventUpdateWithoutDutyAssignmentsInput, UnitEventUncheckedUpdateWithoutDutyAssignmentsInput>
  }

  export type UnitEventUpdateWithoutDutyAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: UnitEventTypeUpdateOneWithoutUnitEventsNestedInput
    dutyPositions?: UnitEventDutyPositionUpdateManyWithoutEventNestedInput
  }

  export type UnitEventUncheckedUpdateWithoutDutyAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UnitEventDutyPositionUpsertWithoutAssignmentsInput = {
    update: XOR<UnitEventDutyPositionUpdateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<UnitEventDutyPositionCreateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedCreateWithoutAssignmentsInput>
    where?: UnitEventDutyPositionWhereInput
  }

  export type UnitEventDutyPositionUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: UnitEventDutyPositionWhereInput
    data: XOR<UnitEventDutyPositionUpdateWithoutAssignmentsInput, UnitEventDutyPositionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UnitEventDutyPositionUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: UnitEventUpdateOneRequiredWithoutDutyPositionsNestedInput
  }

  export type UnitEventDutyPositionUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpsertWithoutUnitEventDutyAssignmentsInput = {
    update: XOR<MemberUpdateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedUpdateWithoutUnitEventDutyAssignmentsInput>
    create: XOR<MemberCreateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedCreateWithoutUnitEventDutyAssignmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutUnitEventDutyAssignmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutUnitEventDutyAssignmentsInput, MemberUncheckedUpdateWithoutUnitEventDutyAssignmentsInput>
  }

  export type MemberUpdateWithoutUnitEventDutyAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutUnitEventDutyAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AuditLogCreateManyAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type CheckinCreateManyAdmin_usersInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
  }

  export type report_audit_logCreateManyAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type SecurityAlertCreateManyAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type VisitorCreateManyAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
  }

  export type DdsAssignmentCreateManyAssignedByAdminInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserCreateManyDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    updatedBy?: string | null
  }

  export type AdminUserCreateManyUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
  }

  export type MemberQualificationCreateManyGrantedByAdminInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateManyRevokedByAdminInput = {
    id?: string
    memberId: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyScheduleCreateManyCreatedByAdminInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyScheduleCreateManyPublishedByAdminInput = {
    id?: string
    dutyRoleId: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissedCheckoutCreateManyResolvedByAdminInput = {
    id?: string
    memberId: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckinUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_audit_logUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SecurityAlertUpdateWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DdsAssignmentUpdateWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUpdateWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateManyWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUserUpdateWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
    qualificationsGranted?: MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminNestedInput
    qualificationsRevoked?: MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminNestedInput
    schedulesCreated?: WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    schedulesPublished?: WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminNestedInput
    missedCheckoutsResolved?: MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateManyWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberQualificationUpdateWithoutGrantedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutQualificationsNestedInput
    qualificationType?: QualificationTypeUpdateOneRequiredWithoutMemberQualificationsNestedInput
    revokedByAdmin?: AdminUserUpdateOneWithoutQualificationsRevokedNestedInput
  }

  export type MemberQualificationUncheckedUpdateWithoutGrantedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUncheckedUpdateManyWithoutGrantedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUpdateWithoutRevokedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutQualificationsNestedInput
    qualificationType?: QualificationTypeUpdateOneRequiredWithoutMemberQualificationsNestedInput
    grantedByAdmin?: AdminUserUpdateOneWithoutQualificationsGrantedNestedInput
  }

  export type MemberQualificationUncheckedUpdateWithoutRevokedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUncheckedUpdateManyWithoutRevokedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyScheduleUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutSchedulesNestedInput
    publishedByAdmin?: AdminUserUpdateOneWithoutSchedulesPublishedNestedInput
    assignments?: ScheduleAssignmentUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyScheduleUpdateWithoutPublishedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyRole?: DutyRoleUpdateOneRequiredWithoutSchedulesNestedInput
    createdByAdmin?: AdminUserUpdateOneWithoutSchedulesCreatedNestedInput
    assignments?: ScheduleAssignmentUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateWithoutPublishedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutPublishedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyRoleId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutUpdateWithoutResolvedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutMissedCheckoutsNestedInput
  }

  export type MissedCheckoutUncheckedUpdateWithoutResolvedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutUncheckedUpdateManyWithoutResolvedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckinCreateManyBadgeInput = {
    id?: string
    memberId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type EventAttendeeCreateManyBadgeInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventCheckinCreateManyBadgeInput = {
    id?: string
    eventAttendeeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type MemberCreateManyBadgeInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type VisitorCreateManyBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type CheckinUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventAttendeeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendee?: EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateManyDivisionInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type MemberUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateManyEventAttendeeInput = {
    id?: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateManyEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitorCreateManyEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type EventAttendeeUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmqEnrollmentCreateManyMemberInput = {
    id?: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type CheckinCreateManyMemberInput = {
    id?: string
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type VisitorCreateManyHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type MemberTagCreateManyMemberInput = {
    id?: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type DdsAssignmentCreateManyMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateManyTransferredToMemberInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationCreateManyMemberInput = {
    id?: string
    qualificationTypeId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentCreateManyMemberInput = {
    id?: string
    scheduleId: string
    dutyPositionId?: string | null
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LockupStatusCreateManyCurrentHolderInput = {
    id?: string
    date: Date | string
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    securedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LockupStatusCreateManySecuredByMemberInput = {
    id?: string
    date: Date | string
    currentHolderId?: string | null
    acquiredAt?: Date | string | null
    buildingStatus?: string
    securedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LockupTransferCreateManyFromMemberInput = {
    id?: string
    lockupStatusId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferCreateManyToMemberInput = {
    id?: string
    lockupStatusId: string
    fromMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupExecutionCreateManyExecutedByMemberInput = {
    id?: string
    lockupStatusId: string
    executedAt?: Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type MissedCheckoutCreateManyMemberInput = {
    id?: string
    date: Date | string
    originalCheckinAt: Date | string
    forcedCheckoutAt?: Date | string
    resolvedBy: string
    resolvedByAdminId?: string | null
    lockupExecutionId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type UnitEventDutyAssignmentCreateManyMemberInput = {
    id?: string
    eventId: string
    eventDutyPositionId?: string | null
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BmqEnrollmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    bmqCourse?: BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CheckinUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUpdateWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberTagUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: TagUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DdsAssignmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUpdateWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualificationType?: QualificationTypeUpdateOneRequiredWithoutMemberQualificationsNestedInput
    grantedByAdmin?: AdminUserUpdateOneWithoutQualificationsGrantedNestedInput
    revokedByAdmin?: AdminUserUpdateOneWithoutQualificationsRevokedNestedInput
  }

  export type MemberQualificationUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: WeeklyScheduleUpdateOneRequiredWithoutAssignmentsNestedInput
    dutyPosition?: DutyPositionUpdateOneWithoutAssignmentsNestedInput
  }

  export type ScheduleAssignmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupStatusUpdateWithoutCurrentHolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securedByMember?: MemberUpdateOneWithoutLockupSecuredNestedInput
    transfers?: LockupTransferUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateWithoutCurrentHolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfers?: LockupTransferUncheckedUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUncheckedUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateManyWithoutCurrentHolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    securedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupStatusUpdateWithoutSecuredByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolder?: MemberUpdateOneWithoutLockupHoldingNestedInput
    transfers?: LockupTransferUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateWithoutSecuredByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfers?: LockupTransferUncheckedUpdateManyWithoutLockupStatusNestedInput
    execution?: LockupExecutionUncheckedUpdateOneWithoutLockupStatusNestedInput
  }

  export type LockupStatusUncheckedUpdateManyWithoutSecuredByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHolderId?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buildingStatus?: StringFieldUpdateOperationsInput | string
    securedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUpdateWithoutFromMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockupStatus?: LockupStatusUpdateOneRequiredWithoutTransfersNestedInput
    toMember?: MemberUpdateOneRequiredWithoutLockupTransfersToNestedInput
  }

  export type LockupTransferUncheckedUpdateWithoutFromMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUncheckedUpdateManyWithoutFromMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUpdateWithoutToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockupStatus?: LockupStatusUpdateOneRequiredWithoutTransfersNestedInput
    fromMember?: MemberUpdateOneRequiredWithoutLockupTransfersFromNestedInput
  }

  export type LockupTransferUncheckedUpdateWithoutToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUncheckedUpdateManyWithoutToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupExecutionUpdateWithoutExecutedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockupStatus?: LockupStatusUpdateOneRequiredWithoutExecutionNestedInput
  }

  export type LockupExecutionUncheckedUpdateWithoutExecutedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockupStatusId?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membersCheckedOut?: JsonNullValueInput | InputJsonValue
    visitorsCheckedOut?: JsonNullValueInput | InputJsonValue
    totalCheckedOut?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedByAdmin?: AdminUserUpdateOneWithoutMissedCheckoutsResolvedNestedInput
  }

  export type MissedCheckoutUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissedCheckoutUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCheckinAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forcedCheckoutAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    lockupExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: UnitEventUpdateOneRequiredWithoutDutyAssignmentsNestedInput
    eventDutyPosition?: UnitEventDutyPositionUpdateOneWithoutAssignmentsNestedInput
  }

  export type UnitEventDutyAssignmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberTagCreateManyTagInput = {
    id?: string
    memberId: string
    createdAt?: Date | string | null
  }

  export type QualificationTypeCreateManyTagInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    canReceiveLockup?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QualificationTypeUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberQualifications?: MemberQualificationUpdateManyWithoutQualificationTypeNestedInput
  }

  export type QualificationTypeUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberQualifications?: MemberQualificationUncheckedUpdateManyWithoutQualificationTypeNestedInput
  }

  export type QualificationTypeUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canReceiveLockup?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BmqEnrollmentCreateManyBmqCourseInput = {
    id?: string
    memberId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    member?: MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type MemberUpdateWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateManyMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rankId: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type MemberUpdateWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rankRef?: RankUpdateOneWithoutMembersNestedInput
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorCreateManyVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgeCreateManyBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeUpdateWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateManyWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateManyRankRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    missedCheckoutCount?: number
    lastMissedCheckout?: Date | string | null
  }

  export type RankCreateManyReplacedByRankInput = {
    id?: string
    code: string
    name: string
    branch: string
    category: string
    displayOrder: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberUpdateWithoutRankRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
    qualifications?: MemberQualificationUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutRankRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
    qualifications?: MemberQualificationUncheckedUpdateManyWithoutMemberNestedInput
    scheduleAssignments?: ScheduleAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    lockupHolding?: LockupStatusUncheckedUpdateManyWithoutCurrentHolderNestedInput
    lockupSecured?: LockupStatusUncheckedUpdateManyWithoutSecuredByMemberNestedInput
    lockupTransfersFrom?: LockupTransferUncheckedUpdateManyWithoutFromMemberNestedInput
    lockupTransfersTo?: LockupTransferUncheckedUpdateManyWithoutToMemberNestedInput
    lockupExecutions?: LockupExecutionUncheckedUpdateManyWithoutExecutedByMemberNestedInput
    missedCheckouts?: MissedCheckoutUncheckedUpdateManyWithoutMemberNestedInput
    unitEventDutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutRankRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missedCheckoutCount?: IntFieldUpdateOperationsInput | number
    lastMissedCheckout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RankUpdateWithoutReplacedByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutRankRefNestedInput
    replacesRanks?: RankUpdateManyWithoutReplacedByRankNestedInput
  }

  export type RankUncheckedUpdateWithoutReplacedByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutRankRefNestedInput
    replacesRanks?: RankUncheckedUpdateManyWithoutReplacedByRankNestedInput
  }

  export type RankUncheckedUpdateManyWithoutReplacedByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationCreateManyQualificationTypeInput = {
    id?: string
    memberId: string
    status?: string
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokeReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberQualificationUpdateWithoutQualificationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutQualificationsNestedInput
    grantedByAdmin?: AdminUserUpdateOneWithoutQualificationsGrantedNestedInput
    revokedByAdmin?: AdminUserUpdateOneWithoutQualificationsRevokedNestedInput
  }

  export type MemberQualificationUncheckedUpdateWithoutQualificationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberQualificationUncheckedUpdateManyWithoutQualificationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokeReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyPositionCreateManyDutyRoleInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyScheduleCreateManyDutyRoleInput = {
    id?: string
    weekStartDate: Date | string
    status?: string
    createdBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyPositionUpdateWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUpdateManyWithoutDutyPositionNestedInput
  }

  export type DutyPositionUncheckedUpdateWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutDutyPositionNestedInput
  }

  export type DutyPositionUncheckedUpdateManyWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyScheduleUpdateWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUserUpdateOneWithoutSchedulesCreatedNestedInput
    publishedByAdmin?: AdminUserUpdateOneWithoutSchedulesPublishedNestedInput
    assignments?: ScheduleAssignmentUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ScheduleAssignmentUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type WeeklyScheduleUncheckedUpdateManyWithoutDutyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentCreateManyDutyPositionInput = {
    id?: string
    scheduleId: string
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentUpdateWithoutDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: WeeklyScheduleUpdateOneRequiredWithoutAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutScheduleAssignmentsNestedInput
  }

  export type ScheduleAssignmentUncheckedUpdateWithoutDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentCreateManyScheduleInput = {
    id?: string
    dutyPositionId?: string | null
    memberId: string
    status?: string
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAssignmentUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyPosition?: DutyPositionUpdateOneWithoutAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutScheduleAssignmentsNestedInput
  }

  export type ScheduleAssignmentUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAssignmentUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferCreateManyLockupStatusInput = {
    id?: string
    fromMemberId: string
    toMemberId: string
    transferredAt?: Date | string
    reason: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type LockupTransferUpdateWithoutLockupStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromMember?: MemberUpdateOneRequiredWithoutLockupTransfersFromNestedInput
    toMember?: MemberUpdateOneRequiredWithoutLockupTransfersToNestedInput
  }

  export type LockupTransferUncheckedUpdateWithoutLockupStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LockupTransferUncheckedUpdateManyWithoutLockupStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromMemberId?: StringFieldUpdateOperationsInput | string
    toMemberId?: StringFieldUpdateOperationsInput | string
    transferredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventCreateManyEventTypeInput = {
    id?: string
    title: string
    eventDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    location?: string | null
    description?: string | null
    organizer?: string | null
    requiresDutyWatch?: boolean
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventUpdateWithoutEventTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyPositions?: UnitEventDutyPositionUpdateManyWithoutEventNestedInput
    dutyAssignments?: UnitEventDutyAssignmentUpdateManyWithoutEventNestedInput
  }

  export type UnitEventUncheckedUpdateWithoutEventTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyPositions?: UnitEventDutyPositionUncheckedUpdateManyWithoutEventNestedInput
    dutyAssignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UnitEventUncheckedUpdateManyWithoutEventTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresDutyWatch?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyPositionCreateManyEventInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    maxSlots?: number
    isStandard?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentCreateManyEventInput = {
    id?: string
    eventDutyPositionId?: string | null
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyPositionUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: UnitEventDutyAssignmentUpdateManyWithoutEventDutyPositionNestedInput
  }

  export type UnitEventDutyPositionUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventDutyPositionNestedInput
  }

  export type UnitEventDutyPositionUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxSlots?: IntFieldUpdateOperationsInput | number
    isStandard?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventDutyPosition?: UnitEventDutyPositionUpdateOneWithoutAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutUnitEventDutyAssignmentsNestedInput
  }

  export type UnitEventDutyAssignmentUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDutyPositionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentCreateManyEventDutyPositionInput = {
    id?: string
    eventId: string
    memberId: string
    status?: string
    isVolunteer?: boolean
    confirmedAt?: Date | string | null
    releasedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitEventDutyAssignmentUpdateWithoutEventDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: UnitEventUpdateOneRequiredWithoutDutyAssignmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutUnitEventDutyAssignmentsNestedInput
  }

  export type UnitEventDutyAssignmentUncheckedUpdateWithoutEventDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitEventDutyAssignmentUncheckedUpdateManyWithoutEventDutyPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isVolunteer?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}