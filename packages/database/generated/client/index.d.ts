
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model Checkin
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Checkin = $Result.DefaultSelection<Prisma.$CheckinPayload>
/**
 * Model Division
 * 
 */
export type Division = $Result.DefaultSelection<Prisma.$DivisionPayload>
/**
 * Model EventAttendee
 * 
 */
export type EventAttendee = $Result.DefaultSelection<Prisma.$EventAttendeePayload>
/**
 * Model EventCheckin
 * 
 */
export type EventCheckin = $Result.DefaultSelection<Prisma.$EventCheckinPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model MemberTag
 * 
 */
export type MemberTag = $Result.DefaultSelection<Prisma.$MemberTagPayload>
/**
 * Model SecurityAlert
 * 
 */
export type SecurityAlert = $Result.DefaultSelection<Prisma.$SecurityAlertPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model BmqCourse
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type BmqCourse = $Result.DefaultSelection<Prisma.$BmqCoursePayload>
/**
 * Model BmqEnrollment
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type BmqEnrollment = $Result.DefaultSelection<Prisma.$BmqEnrollmentPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model report_audit_log
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type report_audit_log = $Result.DefaultSelection<Prisma.$report_audit_logPayload>
/**
 * Model ReportSetting
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ReportSetting = $Result.DefaultSelection<Prisma.$ReportSettingPayload>
/**
 * Model TrainingYear
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type TrainingYear = $Result.DefaultSelection<Prisma.$TrainingYearPayload>
/**
 * Model DdsAssignment
 * 
 */
export type DdsAssignment = $Result.DefaultSelection<Prisma.$DdsAssignmentPayload>
/**
 * Model ResponsibilityAuditLog
 * 
 */
export type ResponsibilityAuditLog = $Result.DefaultSelection<Prisma.$ResponsibilityAuditLogPayload>
/**
 * Model MemberStatus
 * 
 */
export type MemberStatus = $Result.DefaultSelection<Prisma.$MemberStatusPayload>
/**
 * Model MemberType
 * 
 */
export type MemberType = $Result.DefaultSelection<Prisma.$MemberTypePayload>
/**
 * Model VisitType
 * 
 */
export type VisitType = $Result.DefaultSelection<Prisma.$VisitTypePayload>
/**
 * Model BadgeStatus
 * 
 */
export type BadgeStatus = $Result.DefaultSelection<Prisma.$BadgeStatusPayload>
/**
 * Model ListItem
 * 
 */
export type ListItem = $Result.DefaultSelection<Prisma.$ListItemPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model AlertConfig
 * 
 */
export type AlertConfig = $Result.DefaultSelection<Prisma.$AlertConfigPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdminUsers
 * const adminUsers = await prisma.adminUser.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdminUsers
   * const adminUsers = await prisma.adminUser.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkin`: Exposes CRUD operations for the **Checkin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkins
    * const checkins = await prisma.checkin.findMany()
    * ```
    */
  get checkin(): Prisma.CheckinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.division`: Exposes CRUD operations for the **Division** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.division.findMany()
    * ```
    */
  get division(): Prisma.DivisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventAttendee`: Exposes CRUD operations for the **EventAttendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventAttendees
    * const eventAttendees = await prisma.eventAttendee.findMany()
    * ```
    */
  get eventAttendee(): Prisma.EventAttendeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventCheckin`: Exposes CRUD operations for the **EventCheckin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCheckins
    * const eventCheckins = await prisma.eventCheckin.findMany()
    * ```
    */
  get eventCheckin(): Prisma.EventCheckinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberTag`: Exposes CRUD operations for the **MemberTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberTags
    * const memberTags = await prisma.memberTag.findMany()
    * ```
    */
  get memberTag(): Prisma.MemberTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityAlert`: Exposes CRUD operations for the **SecurityAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityAlerts
    * const securityAlerts = await prisma.securityAlert.findMany()
    * ```
    */
  get securityAlert(): Prisma.SecurityAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmqCourse`: Exposes CRUD operations for the **BmqCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmqCourses
    * const bmqCourses = await prisma.bmqCourse.findMany()
    * ```
    */
  get bmqCourse(): Prisma.BmqCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmqEnrollment`: Exposes CRUD operations for the **BmqEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmqEnrollments
    * const bmqEnrollments = await prisma.bmqEnrollment.findMany()
    * ```
    */
  get bmqEnrollment(): Prisma.BmqEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report_audit_log`: Exposes CRUD operations for the **report_audit_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_audit_logs
    * const report_audit_logs = await prisma.report_audit_log.findMany()
    * ```
    */
  get report_audit_log(): Prisma.report_audit_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportSetting`: Exposes CRUD operations for the **ReportSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportSettings
    * const reportSettings = await prisma.reportSetting.findMany()
    * ```
    */
  get reportSetting(): Prisma.ReportSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingYear`: Exposes CRUD operations for the **TrainingYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingYears
    * const trainingYears = await prisma.trainingYear.findMany()
    * ```
    */
  get trainingYear(): Prisma.TrainingYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ddsAssignment`: Exposes CRUD operations for the **DdsAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DdsAssignments
    * const ddsAssignments = await prisma.ddsAssignment.findMany()
    * ```
    */
  get ddsAssignment(): Prisma.DdsAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.responsibilityAuditLog`: Exposes CRUD operations for the **ResponsibilityAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponsibilityAuditLogs
    * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany()
    * ```
    */
  get responsibilityAuditLog(): Prisma.ResponsibilityAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberStatus`: Exposes CRUD operations for the **MemberStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberStatuses
    * const memberStatuses = await prisma.memberStatus.findMany()
    * ```
    */
  get memberStatus(): Prisma.MemberStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberType`: Exposes CRUD operations for the **MemberType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberTypes
    * const memberTypes = await prisma.memberType.findMany()
    * ```
    */
  get memberType(): Prisma.MemberTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitType`: Exposes CRUD operations for the **VisitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitTypes
    * const visitTypes = await prisma.visitType.findMany()
    * ```
    */
  get visitType(): Prisma.VisitTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badgeStatus`: Exposes CRUD operations for the **BadgeStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BadgeStatuses
    * const badgeStatuses = await prisma.badgeStatus.findMany()
    * ```
    */
  get badgeStatus(): Prisma.BadgeStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listItem`: Exposes CRUD operations for the **ListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListItems
    * const listItems = await prisma.listItem.findMany()
    * ```
    */
  get listItem(): Prisma.ListItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertConfig`: Exposes CRUD operations for the **AlertConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertConfigs
    * const alertConfigs = await prisma.alertConfig.findMany()
    * ```
    */
  get alertConfig(): Prisma.AlertConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AdminUser: 'AdminUser',
    AuditLog: 'AuditLog',
    Badge: 'Badge',
    Checkin: 'Checkin',
    Division: 'Division',
    EventAttendee: 'EventAttendee',
    EventCheckin: 'EventCheckin',
    Event: 'Event',
    Member: 'Member',
    Tag: 'Tag',
    MemberTag: 'MemberTag',
    SecurityAlert: 'SecurityAlert',
    Visitor: 'Visitor',
    BmqCourse: 'BmqCourse',
    BmqEnrollment: 'BmqEnrollment',
    migrations: 'migrations',
    report_audit_log: 'report_audit_log',
    ReportSetting: 'ReportSetting',
    TrainingYear: 'TrainingYear',
    DdsAssignment: 'DdsAssignment',
    ResponsibilityAuditLog: 'ResponsibilityAuditLog',
    MemberStatus: 'MemberStatus',
    MemberType: 'MemberType',
    VisitType: 'VisitType',
    BadgeStatus: 'BadgeStatus',
    ListItem: 'ListItem',
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Setting: 'Setting',
    AlertConfig: 'AlertConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "adminUser" | "auditLog" | "badge" | "checkin" | "division" | "eventAttendee" | "eventCheckin" | "event" | "member" | "tag" | "memberTag" | "securityAlert" | "visitor" | "bmqCourse" | "bmqEnrollment" | "migrations" | "report_audit_log" | "reportSetting" | "trainingYear" | "ddsAssignment" | "responsibilityAuditLog" | "memberStatus" | "memberType" | "visitType" | "badgeStatus" | "listItem" | "user" | "session" | "account" | "verification" | "setting" | "alertConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      Checkin: {
        payload: Prisma.$CheckinPayload<ExtArgs>
        fields: Prisma.CheckinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          findFirst: {
            args: Prisma.CheckinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          findMany: {
            args: Prisma.CheckinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          create: {
            args: Prisma.CheckinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          createMany: {
            args: Prisma.CheckinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          delete: {
            args: Prisma.CheckinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          update: {
            args: Prisma.CheckinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          deleteMany: {
            args: Prisma.CheckinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>[]
          }
          upsert: {
            args: Prisma.CheckinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckinPayload>
          }
          aggregate: {
            args: Prisma.CheckinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckin>
          }
          groupBy: {
            args: Prisma.CheckinGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckinGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckinCountArgs<ExtArgs>
            result: $Utils.Optional<CheckinCountAggregateOutputType> | number
          }
        }
      }
      Division: {
        payload: Prisma.$DivisionPayload<ExtArgs>
        fields: Prisma.DivisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DivisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DivisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findFirst: {
            args: Prisma.DivisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DivisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findMany: {
            args: Prisma.DivisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          create: {
            args: Prisma.DivisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          createMany: {
            args: Prisma.DivisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DivisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          delete: {
            args: Prisma.DivisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          update: {
            args: Prisma.DivisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          deleteMany: {
            args: Prisma.DivisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DivisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DivisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          upsert: {
            args: Prisma.DivisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          aggregate: {
            args: Prisma.DivisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDivision>
          }
          groupBy: {
            args: Prisma.DivisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DivisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DivisionCountArgs<ExtArgs>
            result: $Utils.Optional<DivisionCountAggregateOutputType> | number
          }
        }
      }
      EventAttendee: {
        payload: Prisma.$EventAttendeePayload<ExtArgs>
        fields: Prisma.EventAttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventAttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventAttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findFirst: {
            args: Prisma.EventAttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventAttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findMany: {
            args: Prisma.EventAttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          create: {
            args: Prisma.EventAttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          createMany: {
            args: Prisma.EventAttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventAttendeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          delete: {
            args: Prisma.EventAttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          update: {
            args: Prisma.EventAttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          deleteMany: {
            args: Prisma.EventAttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventAttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventAttendeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          upsert: {
            args: Prisma.EventAttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          aggregate: {
            args: Prisma.EventAttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventAttendee>
          }
          groupBy: {
            args: Prisma.EventAttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventAttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeCountAggregateOutputType> | number
          }
        }
      }
      EventCheckin: {
        payload: Prisma.$EventCheckinPayload<ExtArgs>
        fields: Prisma.EventCheckinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCheckinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCheckinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          findFirst: {
            args: Prisma.EventCheckinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCheckinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          findMany: {
            args: Prisma.EventCheckinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          create: {
            args: Prisma.EventCheckinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          createMany: {
            args: Prisma.EventCheckinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCheckinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          delete: {
            args: Prisma.EventCheckinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          update: {
            args: Prisma.EventCheckinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          deleteMany: {
            args: Prisma.EventCheckinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCheckinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventCheckinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>[]
          }
          upsert: {
            args: Prisma.EventCheckinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCheckinPayload>
          }
          aggregate: {
            args: Prisma.EventCheckinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCheckin>
          }
          groupBy: {
            args: Prisma.EventCheckinGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCheckinGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCheckinCountArgs<ExtArgs>
            result: $Utils.Optional<EventCheckinCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      MemberTag: {
        payload: Prisma.$MemberTagPayload<ExtArgs>
        fields: Prisma.MemberTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          findFirst: {
            args: Prisma.MemberTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          findMany: {
            args: Prisma.MemberTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          create: {
            args: Prisma.MemberTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          createMany: {
            args: Prisma.MemberTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          delete: {
            args: Prisma.MemberTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          update: {
            args: Prisma.MemberTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          deleteMany: {
            args: Prisma.MemberTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
          }
          upsert: {
            args: Prisma.MemberTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTagPayload>
          }
          aggregate: {
            args: Prisma.MemberTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberTag>
          }
          groupBy: {
            args: Prisma.MemberTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberTagCountArgs<ExtArgs>
            result: $Utils.Optional<MemberTagCountAggregateOutputType> | number
          }
        }
      }
      SecurityAlert: {
        payload: Prisma.$SecurityAlertPayload<ExtArgs>
        fields: Prisma.SecurityAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findFirst: {
            args: Prisma.SecurityAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findMany: {
            args: Prisma.SecurityAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          create: {
            args: Prisma.SecurityAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          createMany: {
            args: Prisma.SecurityAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          delete: {
            args: Prisma.SecurityAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          update: {
            args: Prisma.SecurityAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          deleteMany: {
            args: Prisma.SecurityAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          upsert: {
            args: Prisma.SecurityAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          aggregate: {
            args: Prisma.SecurityAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityAlert>
          }
          groupBy: {
            args: Prisma.SecurityAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityAlertCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      BmqCourse: {
        payload: Prisma.$BmqCoursePayload<ExtArgs>
        fields: Prisma.BmqCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmqCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmqCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          findFirst: {
            args: Prisma.BmqCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmqCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          findMany: {
            args: Prisma.BmqCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          create: {
            args: Prisma.BmqCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          createMany: {
            args: Prisma.BmqCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BmqCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          delete: {
            args: Prisma.BmqCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          update: {
            args: Prisma.BmqCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          deleteMany: {
            args: Prisma.BmqCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmqCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BmqCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>[]
          }
          upsert: {
            args: Prisma.BmqCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqCoursePayload>
          }
          aggregate: {
            args: Prisma.BmqCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmqCourse>
          }
          groupBy: {
            args: Prisma.BmqCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmqCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmqCourseCountArgs<ExtArgs>
            result: $Utils.Optional<BmqCourseCountAggregateOutputType> | number
          }
        }
      }
      BmqEnrollment: {
        payload: Prisma.$BmqEnrollmentPayload<ExtArgs>
        fields: Prisma.BmqEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmqEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.BmqEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmqEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          findMany: {
            args: Prisma.BmqEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          create: {
            args: Prisma.BmqEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          createMany: {
            args: Prisma.BmqEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BmqEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.BmqEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          update: {
            args: Prisma.BmqEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.BmqEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmqEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.BmqEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmqEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.BmqEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmqEnrollment>
          }
          groupBy: {
            args: Prisma.BmqEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmqEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmqEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<BmqEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      report_audit_log: {
        payload: Prisma.$report_audit_logPayload<ExtArgs>
        fields: Prisma.report_audit_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.report_audit_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.report_audit_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          findFirst: {
            args: Prisma.report_audit_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.report_audit_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          findMany: {
            args: Prisma.report_audit_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          create: {
            args: Prisma.report_audit_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          createMany: {
            args: Prisma.report_audit_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.report_audit_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          delete: {
            args: Prisma.report_audit_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          update: {
            args: Prisma.report_audit_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          deleteMany: {
            args: Prisma.report_audit_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.report_audit_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.report_audit_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>[]
          }
          upsert: {
            args: Prisma.report_audit_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_audit_logPayload>
          }
          aggregate: {
            args: Prisma.Report_audit_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport_audit_log>
          }
          groupBy: {
            args: Prisma.report_audit_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Report_audit_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.report_audit_logCountArgs<ExtArgs>
            result: $Utils.Optional<Report_audit_logCountAggregateOutputType> | number
          }
        }
      }
      ReportSetting: {
        payload: Prisma.$ReportSettingPayload<ExtArgs>
        fields: Prisma.ReportSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          findFirst: {
            args: Prisma.ReportSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          findMany: {
            args: Prisma.ReportSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          create: {
            args: Prisma.ReportSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          createMany: {
            args: Prisma.ReportSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          delete: {
            args: Prisma.ReportSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          update: {
            args: Prisma.ReportSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          deleteMany: {
            args: Prisma.ReportSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>[]
          }
          upsert: {
            args: Prisma.ReportSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportSettingPayload>
          }
          aggregate: {
            args: Prisma.ReportSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportSetting>
          }
          groupBy: {
            args: Prisma.ReportSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportSettingCountArgs<ExtArgs>
            result: $Utils.Optional<ReportSettingCountAggregateOutputType> | number
          }
        }
      }
      TrainingYear: {
        payload: Prisma.$TrainingYearPayload<ExtArgs>
        fields: Prisma.TrainingYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          findFirst: {
            args: Prisma.TrainingYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          findMany: {
            args: Prisma.TrainingYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          create: {
            args: Prisma.TrainingYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          createMany: {
            args: Prisma.TrainingYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          delete: {
            args: Prisma.TrainingYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          update: {
            args: Prisma.TrainingYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          deleteMany: {
            args: Prisma.TrainingYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>[]
          }
          upsert: {
            args: Prisma.TrainingYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingYearPayload>
          }
          aggregate: {
            args: Prisma.TrainingYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingYear>
          }
          groupBy: {
            args: Prisma.TrainingYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingYearCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingYearCountAggregateOutputType> | number
          }
        }
      }
      DdsAssignment: {
        payload: Prisma.$DdsAssignmentPayload<ExtArgs>
        fields: Prisma.DdsAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DdsAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DdsAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DdsAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DdsAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          findMany: {
            args: Prisma.DdsAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          create: {
            args: Prisma.DdsAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          createMany: {
            args: Prisma.DdsAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DdsAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DdsAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          update: {
            args: Prisma.DdsAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DdsAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DdsAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DdsAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DdsAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DdsAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DdsAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDdsAssignment>
          }
          groupBy: {
            args: Prisma.DdsAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DdsAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DdsAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DdsAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ResponsibilityAuditLog: {
        payload: Prisma.$ResponsibilityAuditLogPayload<ExtArgs>
        fields: Prisma.ResponsibilityAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponsibilityAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          findFirst: {
            args: Prisma.ResponsibilityAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          findMany: {
            args: Prisma.ResponsibilityAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          create: {
            args: Prisma.ResponsibilityAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          createMany: {
            args: Prisma.ResponsibilityAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          delete: {
            args: Prisma.ResponsibilityAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          update: {
            args: Prisma.ResponsibilityAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.ResponsibilityAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponsibilityAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.ResponsibilityAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsibilityAuditLogPayload>
          }
          aggregate: {
            args: Prisma.ResponsibilityAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsibilityAuditLog>
          }
          groupBy: {
            args: Prisma.ResponsibilityAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponsibilityAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityAuditLogCountAggregateOutputType> | number
          }
        }
      }
      MemberStatus: {
        payload: Prisma.$MemberStatusPayload<ExtArgs>
        fields: Prisma.MemberStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          findFirst: {
            args: Prisma.MemberStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          findMany: {
            args: Prisma.MemberStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          create: {
            args: Prisma.MemberStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          createMany: {
            args: Prisma.MemberStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          delete: {
            args: Prisma.MemberStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          update: {
            args: Prisma.MemberStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          deleteMany: {
            args: Prisma.MemberStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>[]
          }
          upsert: {
            args: Prisma.MemberStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberStatusPayload>
          }
          aggregate: {
            args: Prisma.MemberStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberStatus>
          }
          groupBy: {
            args: Prisma.MemberStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MemberStatusCountAggregateOutputType> | number
          }
        }
      }
      MemberType: {
        payload: Prisma.$MemberTypePayload<ExtArgs>
        fields: Prisma.MemberTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          findFirst: {
            args: Prisma.MemberTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          findMany: {
            args: Prisma.MemberTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          create: {
            args: Prisma.MemberTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          createMany: {
            args: Prisma.MemberTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          delete: {
            args: Prisma.MemberTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          update: {
            args: Prisma.MemberTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          deleteMany: {
            args: Prisma.MemberTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>[]
          }
          upsert: {
            args: Prisma.MemberTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTypePayload>
          }
          aggregate: {
            args: Prisma.MemberTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberType>
          }
          groupBy: {
            args: Prisma.MemberTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberTypeCountArgs<ExtArgs>
            result: $Utils.Optional<MemberTypeCountAggregateOutputType> | number
          }
        }
      }
      VisitType: {
        payload: Prisma.$VisitTypePayload<ExtArgs>
        fields: Prisma.VisitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findFirst: {
            args: Prisma.VisitTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findMany: {
            args: Prisma.VisitTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          create: {
            args: Prisma.VisitTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          createMany: {
            args: Prisma.VisitTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          delete: {
            args: Prisma.VisitTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          update: {
            args: Prisma.VisitTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          deleteMany: {
            args: Prisma.VisitTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          upsert: {
            args: Prisma.VisitTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          aggregate: {
            args: Prisma.VisitTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitType>
          }
          groupBy: {
            args: Prisma.VisitTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VisitTypeCountAggregateOutputType> | number
          }
        }
      }
      BadgeStatus: {
        payload: Prisma.$BadgeStatusPayload<ExtArgs>
        fields: Prisma.BadgeStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          findFirst: {
            args: Prisma.BadgeStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          findMany: {
            args: Prisma.BadgeStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          create: {
            args: Prisma.BadgeStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          createMany: {
            args: Prisma.BadgeStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          delete: {
            args: Prisma.BadgeStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          update: {
            args: Prisma.BadgeStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          deleteMany: {
            args: Prisma.BadgeStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>[]
          }
          upsert: {
            args: Prisma.BadgeStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeStatusPayload>
          }
          aggregate: {
            args: Prisma.BadgeStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadgeStatus>
          }
          groupBy: {
            args: Prisma.BadgeStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeStatusCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeStatusCountAggregateOutputType> | number
          }
        }
      }
      ListItem: {
        payload: Prisma.$ListItemPayload<ExtArgs>
        fields: Prisma.ListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findFirst: {
            args: Prisma.ListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findMany: {
            args: Prisma.ListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          create: {
            args: Prisma.ListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          createMany: {
            args: Prisma.ListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          delete: {
            args: Prisma.ListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          update: {
            args: Prisma.ListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          deleteMany: {
            args: Prisma.ListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          upsert: {
            args: Prisma.ListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          aggregate: {
            args: Prisma.ListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListItem>
          }
          groupBy: {
            args: Prisma.ListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListItemCountArgs<ExtArgs>
            result: $Utils.Optional<ListItemCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      AlertConfig: {
        payload: Prisma.$AlertConfigPayload<ExtArgs>
        fields: Prisma.AlertConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          findFirst: {
            args: Prisma.AlertConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          findMany: {
            args: Prisma.AlertConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          create: {
            args: Prisma.AlertConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          createMany: {
            args: Prisma.AlertConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          delete: {
            args: Prisma.AlertConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          update: {
            args: Prisma.AlertConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          deleteMany: {
            args: Prisma.AlertConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>[]
          }
          upsert: {
            args: Prisma.AlertConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConfigPayload>
          }
          aggregate: {
            args: Prisma.AlertConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertConfig>
          }
          groupBy: {
            args: Prisma.AlertConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AlertConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    adminUser?: AdminUserOmit
    auditLog?: AuditLogOmit
    badge?: BadgeOmit
    checkin?: CheckinOmit
    division?: DivisionOmit
    eventAttendee?: EventAttendeeOmit
    eventCheckin?: EventCheckinOmit
    event?: EventOmit
    member?: MemberOmit
    tag?: TagOmit
    memberTag?: MemberTagOmit
    securityAlert?: SecurityAlertOmit
    visitor?: VisitorOmit
    bmqCourse?: BmqCourseOmit
    bmqEnrollment?: BmqEnrollmentOmit
    migrations?: migrationsOmit
    report_audit_log?: report_audit_logOmit
    reportSetting?: ReportSettingOmit
    trainingYear?: TrainingYearOmit
    ddsAssignment?: DdsAssignmentOmit
    responsibilityAuditLog?: ResponsibilityAuditLogOmit
    memberStatus?: MemberStatusOmit
    memberType?: MemberTypeOmit
    visitType?: VisitTypeOmit
    badgeStatus?: BadgeStatusOmit
    listItem?: ListItemOmit
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    setting?: SettingOmit
    alertConfig?: AlertConfigOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    auditLogs: number
    checkins: number
    report_audit_log: number
    securityAlerts: number
    visitors: number
    ddsAssignments: number
    disabledUsers: number
    updatedUsers: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUserCountOutputTypeCountAuditLogsArgs
    checkins?: boolean | AdminUserCountOutputTypeCountCheckinsArgs
    report_audit_log?: boolean | AdminUserCountOutputTypeCountReport_audit_logArgs
    securityAlerts?: boolean | AdminUserCountOutputTypeCountSecurityAlertsArgs
    visitors?: boolean | AdminUserCountOutputTypeCountVisitorsArgs
    ddsAssignments?: boolean | AdminUserCountOutputTypeCountDdsAssignmentsArgs
    disabledUsers?: boolean | AdminUserCountOutputTypeCountDisabledUsersArgs
    updatedUsers?: boolean | AdminUserCountOutputTypeCountUpdatedUsersArgs
  }

  // Custom InputTypes
  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountReport_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_audit_logWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountSecurityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountDdsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountDisabledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountUpdatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    checkins: number
    eventAttendees: number
    eventCheckins: number
    members: number
    visitors: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | BadgeCountOutputTypeCountCheckinsArgs
    eventAttendees?: boolean | BadgeCountOutputTypeCountEventAttendeesArgs
    eventCheckins?: boolean | BadgeCountOutputTypeCountEventCheckinsArgs
    members?: boolean | BadgeCountOutputTypeCountMembersArgs
    visitors?: boolean | BadgeCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountEventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountEventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type DivisionCountOutputType
   */

  export type DivisionCountOutputType = {
    members: number
  }

  export type DivisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DivisionCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DivisionCountOutputType
     */
    select?: DivisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type EventAttendeeCountOutputType
   */

  export type EventAttendeeCountOutputType = {
    eventCheckins: number
  }

  export type EventAttendeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventCheckins?: boolean | EventAttendeeCountOutputTypeCountEventCheckinsArgs
  }

  // Custom InputTypes
  /**
   * EventAttendeeCountOutputType without action
   */
  export type EventAttendeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendeeCountOutputType
     */
    select?: EventAttendeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventAttendeeCountOutputType without action
   */
  export type EventAttendeeCountOutputTypeCountEventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    eventAttendees: number
    visitors: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventAttendees?: boolean | EventCountOutputTypeCountEventAttendeesArgs
    visitors?: boolean | EventCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    bmqEnrollments: number
    checkins: number
    visitors: number
    memberTags: number
    ddsAssignments: number
    ddsTransfers: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | MemberCountOutputTypeCountBmqEnrollmentsArgs
    checkins?: boolean | MemberCountOutputTypeCountCheckinsArgs
    visitors?: boolean | MemberCountOutputTypeCountVisitorsArgs
    memberTags?: boolean | MemberCountOutputTypeCountMemberTagsArgs
    ddsAssignments?: boolean | MemberCountOutputTypeCountDdsAssignmentsArgs
    ddsTransfers?: boolean | MemberCountOutputTypeCountDdsTransfersArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountBmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountDdsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountDdsTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    memberTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberTags?: boolean | TagCountOutputTypeCountMemberTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMemberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
  }


  /**
   * Count Type BmqCourseCountOutputType
   */

  export type BmqCourseCountOutputType = {
    bmqEnrollments: number
  }

  export type BmqCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | BmqCourseCountOutputTypeCountBmqEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * BmqCourseCountOutputType without action
   */
  export type BmqCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourseCountOutputType
     */
    select?: BmqCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmqCourseCountOutputType without action
   */
  export type BmqCourseCountOutputTypeCountBmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
  }


  /**
   * Count Type MemberStatusCountOutputType
   */

  export type MemberStatusCountOutputType = {
    members: number
  }

  export type MemberStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberStatusCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MemberStatusCountOutputType without action
   */
  export type MemberStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatusCountOutputType
     */
    select?: MemberStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberStatusCountOutputType without action
   */
  export type MemberStatusCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type MemberTypeCountOutputType
   */

  export type MemberTypeCountOutputType = {
    members: number
  }

  export type MemberTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberTypeCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MemberTypeCountOutputType without action
   */
  export type MemberTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTypeCountOutputType
     */
    select?: MemberTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberTypeCountOutputType without action
   */
  export type MemberTypeCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type VisitTypeCountOutputType
   */

  export type VisitTypeCountOutputType = {
    visitors: number
  }

  export type VisitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | VisitTypeCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTypeCountOutputType
     */
    select?: VisitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }


  /**
   * Count Type BadgeStatusCountOutputType
   */

  export type BadgeStatusCountOutputType = {
    badges: number
  }

  export type BadgeStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeStatusCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeStatusCountOutputType without action
   */
  export type BadgeStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatusCountOutputType
     */
    select?: BadgeStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeStatusCountOutputType without action
   */
  export type BadgeStatusCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    fullName: string | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean | null
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    fullName: string | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean | null
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    displayName: number
    fullName: number
    role: number
    lastLogin: number
    createdAt: number
    first_name: number
    last_name: number
    updated_at: number
    disabled: number
    disabledAt: number
    disabledBy: number
    updatedBy: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    fullName?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    first_name?: true
    last_name?: true
    updated_at?: true
    disabled?: true
    disabledAt?: true
    disabledBy?: true
    updatedBy?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    username: string
    email: string | null
    passwordHash: string
    displayName: string
    fullName: string | null
    role: string
    lastLogin: Date | null
    createdAt: Date | null
    first_name: string | null
    last_name: string | null
    updated_at: Date | null
    disabled: boolean
    disabledAt: Date | null
    disabledBy: string | null
    updatedBy: string | null
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    checkins?: boolean | AdminUser$checkinsArgs<ExtArgs>
    report_audit_log?: boolean | AdminUser$report_audit_logArgs<ExtArgs>
    securityAlerts?: boolean | AdminUser$securityAlertsArgs<ExtArgs>
    visitors?: boolean | AdminUser$visitorsArgs<ExtArgs>
    ddsAssignments?: boolean | AdminUser$ddsAssignmentsArgs<ExtArgs>
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
    disabledUsers?: boolean | AdminUser$disabledUsersArgs<ExtArgs>
    updatedUsers?: boolean | AdminUser$updatedUsersArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    fullName?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    first_name?: boolean
    last_name?: boolean
    updated_at?: boolean
    disabled?: boolean
    disabledAt?: boolean
    disabledBy?: boolean
    updatedBy?: boolean
  }

  export type AdminUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "displayName" | "fullName" | "role" | "lastLogin" | "createdAt" | "first_name" | "last_name" | "updated_at" | "disabled" | "disabledAt" | "disabledBy" | "updatedBy", ExtArgs["result"]["adminUser"]>
  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    checkins?: boolean | AdminUser$checkinsArgs<ExtArgs>
    report_audit_log?: boolean | AdminUser$report_audit_logArgs<ExtArgs>
    securityAlerts?: boolean | AdminUser$securityAlertsArgs<ExtArgs>
    visitors?: boolean | AdminUser$visitorsArgs<ExtArgs>
    ddsAssignments?: boolean | AdminUser$ddsAssignmentsArgs<ExtArgs>
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
    disabledUsers?: boolean | AdminUser$disabledUsersArgs<ExtArgs>
    updatedUsers?: boolean | AdminUser$updatedUsersArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }
  export type AdminUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disabledByAdmin?: boolean | AdminUser$disabledByAdminArgs<ExtArgs>
    updatedByAdmin?: boolean | AdminUser$updatedByAdminArgs<ExtArgs>
  }

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      report_audit_log: Prisma.$report_audit_logPayload<ExtArgs>[]
      securityAlerts: Prisma.$SecurityAlertPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      ddsAssignments: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      disabledByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      updatedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
      disabledUsers: Prisma.$AdminUserPayload<ExtArgs>[]
      updatedUsers: Prisma.$AdminUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string | null
      passwordHash: string
      displayName: string
      fullName: string | null
      role: string
      lastLogin: Date | null
      createdAt: Date | null
      first_name: string | null
      last_name: string | null
      updated_at: Date | null
      disabled: boolean
      disabledAt: Date | null
      disabledBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers and returns the data updated in the database.
     * @param {AdminUserUpdateManyAndReturnArgs} args - Arguments to update many AdminUsers.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends AdminUser$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkins<T extends AdminUser$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    report_audit_log<T extends AdminUser$report_audit_logArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$report_audit_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityAlerts<T extends AdminUser$securityAlertsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$securityAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends AdminUser$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsAssignments<T extends AdminUser$ddsAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$ddsAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disabledByAdmin<T extends AdminUser$disabledByAdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$disabledByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedByAdmin<T extends AdminUser$updatedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$updatedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    disabledUsers<T extends AdminUser$disabledUsersArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$disabledUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedUsers<T extends AdminUser$updatedUsersArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$updatedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly username: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly passwordHash: FieldRef<"AdminUser", 'String'>
    readonly displayName: FieldRef<"AdminUser", 'String'>
    readonly fullName: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'String'>
    readonly lastLogin: FieldRef<"AdminUser", 'DateTime'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly first_name: FieldRef<"AdminUser", 'String'>
    readonly last_name: FieldRef<"AdminUser", 'String'>
    readonly updated_at: FieldRef<"AdminUser", 'DateTime'>
    readonly disabled: FieldRef<"AdminUser", 'Boolean'>
    readonly disabledAt: FieldRef<"AdminUser", 'DateTime'>
    readonly disabledBy: FieldRef<"AdminUser", 'String'>
    readonly updatedBy: FieldRef<"AdminUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
  }

  /**
   * AdminUser updateManyAndReturn
   */
  export type AdminUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to delete.
     */
    limit?: number
  }

  /**
   * AdminUser.auditLogs
   */
  export type AdminUser$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AdminUser.checkins
   */
  export type AdminUser$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * AdminUser.report_audit_log
   */
  export type AdminUser$report_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    where?: report_audit_logWhereInput
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    cursor?: report_audit_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
  }

  /**
   * AdminUser.securityAlerts
   */
  export type AdminUser$securityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    cursor?: SecurityAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * AdminUser.visitors
   */
  export type AdminUser$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * AdminUser.ddsAssignments
   */
  export type AdminUser$ddsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * AdminUser.disabledByAdmin
   */
  export type AdminUser$disabledByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.updatedByAdmin
   */
  export type AdminUser$updatedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.disabledUsers
   */
  export type AdminUser$disabledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    cursor?: AdminUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser.updatedUsers
   */
  export type AdminUser$updatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    cursor?: AdminUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    adminUserId: number
    action: number
    entityType: number
    entityId: number
    details: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    adminUserId: string | null
    action: string
    entityType: string
    entityId: string | null
    details: JsonValue | null
    ipAddress: string | null
    createdAt: Date | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminUserId" | "action" | "entityType" | "entityId" | "details" | "ipAddress" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AuditLog$adminUserArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      adminUser: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUserId: string | null
      action: string
      entityType: string
      entityId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUser<T extends AuditLog$adminUserArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$adminUserArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly adminUserId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.adminUser
   */
  export type AuditLog$adminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    assignmentType: string | null
    assignedToId: string | null
    status: string | null
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    assignmentType: string | null
    assignedToId: string | null
    status: string | null
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    serialNumber: number
    assignmentType: number
    assignedToId: number
    status: number
    badgeStatusId: number
    lastUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    serialNumber?: true
    assignmentType?: true
    assignedToId?: true
    status?: true
    badgeStatusId?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    serialNumber: string
    assignmentType: string
    assignedToId: string | null
    status: string
    badgeStatusId: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkins?: boolean | Badge$checkinsArgs<ExtArgs>
    eventAttendees?: boolean | Badge$eventAttendeesArgs<ExtArgs>
    eventCheckins?: boolean | Badge$eventCheckinsArgs<ExtArgs>
    members?: boolean | Badge$membersArgs<ExtArgs>
    visitors?: boolean | Badge$visitorsArgs<ExtArgs>
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    assignmentType?: boolean
    assignedToId?: boolean
    status?: boolean
    badgeStatusId?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serialNumber" | "assignmentType" | "assignedToId" | "status" | "badgeStatusId" | "lastUsed" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | Badge$checkinsArgs<ExtArgs>
    eventAttendees?: boolean | Badge$eventAttendeesArgs<ExtArgs>
    eventCheckins?: boolean | Badge$eventCheckinsArgs<ExtArgs>
    members?: boolean | Badge$membersArgs<ExtArgs>
    visitors?: boolean | Badge$visitorsArgs<ExtArgs>
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeStatusRef?: boolean | Badge$badgeStatusRefArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      eventAttendees: Prisma.$EventAttendeePayload<ExtArgs>[]
      eventCheckins: Prisma.$EventCheckinPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      badgeStatusRef: Prisma.$BadgeStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      assignmentType: string
      assignedToId: string | null
      status: string
      badgeStatusId: string | null
      lastUsed: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkins<T extends Badge$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventAttendees<T extends Badge$eventAttendeesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$eventAttendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventCheckins<T extends Badge$eventCheckinsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$eventCheckinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Badge$membersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Badge$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Badge$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badgeStatusRef<T extends Badge$badgeStatusRefArgs<ExtArgs> = {}>(args?: Subset<T, Badge$badgeStatusRefArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly serialNumber: FieldRef<"Badge", 'String'>
    readonly assignmentType: FieldRef<"Badge", 'String'>
    readonly assignedToId: FieldRef<"Badge", 'String'>
    readonly status: FieldRef<"Badge", 'String'>
    readonly badgeStatusId: FieldRef<"Badge", 'String'>
    readonly lastUsed: FieldRef<"Badge", 'DateTime'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.checkins
   */
  export type Badge$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Badge.eventAttendees
   */
  export type Badge$eventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * Badge.eventCheckins
   */
  export type Badge$eventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    cursor?: EventCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * Badge.members
   */
  export type Badge$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Badge.visitors
   */
  export type Badge$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Badge.badgeStatusRef
   */
  export type Badge$badgeStatusRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    where?: BadgeStatusWhereInput
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model Checkin
   */

  export type AggregateCheckin = {
    _count: CheckinCountAggregateOutputType | null
    _min: CheckinMinAggregateOutputType | null
    _max: CheckinMaxAggregateOutputType | null
  }

  export type CheckinMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
  }

  export type CheckinMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
  }

  export type CheckinCountAggregateOutputType = {
    id: number
    memberId: number
    badgeId: number
    direction: number
    timestamp: number
    kioskId: number
    synced: number
    createdAt: number
    flagged_for_review: number
    flag_reason: number
    method: number
    created_by_admin: number
    _all: number
  }


  export type CheckinMinAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
  }

  export type CheckinMaxAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
  }

  export type CheckinCountAggregateInputType = {
    id?: true
    memberId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    synced?: true
    createdAt?: true
    flagged_for_review?: true
    flag_reason?: true
    method?: true
    created_by_admin?: true
    _all?: true
  }

  export type CheckinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkin to aggregate.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Checkins
    **/
    _count?: true | CheckinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckinMaxAggregateInputType
  }

  export type GetCheckinAggregateType<T extends CheckinAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckin[P]>
      : GetScalarType<T[P], AggregateCheckin[P]>
  }




  export type CheckinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithAggregationInput | CheckinOrderByWithAggregationInput[]
    by: CheckinScalarFieldEnum[] | CheckinScalarFieldEnum
    having?: CheckinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckinCountAggregateInputType | true
    _min?: CheckinMinAggregateInputType
    _max?: CheckinMaxAggregateInputType
  }

  export type CheckinGroupByOutputType = {
    id: string
    memberId: string | null
    badgeId: string | null
    direction: string
    timestamp: Date
    kioskId: string
    synced: boolean | null
    createdAt: Date | null
    flagged_for_review: boolean | null
    flag_reason: string | null
    method: string | null
    created_by_admin: string | null
    _count: CheckinCountAggregateOutputType | null
    _min: CheckinMinAggregateOutputType | null
    _max: CheckinMaxAggregateOutputType | null
  }

  type GetCheckinGroupByPayload<T extends CheckinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckinGroupByOutputType[P]>
            : GetScalarType<T[P], CheckinGroupByOutputType[P]>
        }
      >
    >


  export type CheckinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }, ExtArgs["result"]["checkin"]>

  export type CheckinSelectScalar = {
    id?: boolean
    memberId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    synced?: boolean
    createdAt?: boolean
    flagged_for_review?: boolean
    flag_reason?: boolean
    method?: boolean
    created_by_admin?: boolean
  }

  export type CheckinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "badgeId" | "direction" | "timestamp" | "kioskId" | "synced" | "createdAt" | "flagged_for_review" | "flag_reason" | "method" | "created_by_admin", ExtArgs["result"]["checkin"]>
  export type CheckinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }
  export type CheckinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }
  export type CheckinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Checkin$badgeArgs<ExtArgs>
    admin_users?: boolean | Checkin$admin_usersArgs<ExtArgs>
    member?: boolean | Checkin$memberArgs<ExtArgs>
  }

  export type $CheckinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Checkin"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs> | null
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
      member: Prisma.$MemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string | null
      badgeId: string | null
      direction: string
      timestamp: Date
      kioskId: string
      synced: boolean | null
      createdAt: Date | null
      flagged_for_review: boolean | null
      flag_reason: string | null
      method: string | null
      created_by_admin: string | null
    }, ExtArgs["result"]["checkin"]>
    composites: {}
  }

  type CheckinGetPayload<S extends boolean | null | undefined | CheckinDefaultArgs> = $Result.GetResult<Prisma.$CheckinPayload, S>

  type CheckinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckinCountAggregateInputType | true
    }

  export interface CheckinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Checkin'], meta: { name: 'Checkin' } }
    /**
     * Find zero or one Checkin that matches the filter.
     * @param {CheckinFindUniqueArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckinFindUniqueArgs>(args: SelectSubset<T, CheckinFindUniqueArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Checkin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckinFindUniqueOrThrowArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckinFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindFirstArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckinFindFirstArgs>(args?: SelectSubset<T, CheckinFindFirstArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindFirstOrThrowArgs} args - Arguments to find a Checkin
     * @example
     * // Get one Checkin
     * const checkin = await prisma.checkin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckinFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckinFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkins
     * const checkins = await prisma.checkin.findMany()
     * 
     * // Get first 10 Checkins
     * const checkins = await prisma.checkin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkinWithIdOnly = await prisma.checkin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckinFindManyArgs>(args?: SelectSubset<T, CheckinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Checkin.
     * @param {CheckinCreateArgs} args - Arguments to create a Checkin.
     * @example
     * // Create one Checkin
     * const Checkin = await prisma.checkin.create({
     *   data: {
     *     // ... data to create a Checkin
     *   }
     * })
     * 
     */
    create<T extends CheckinCreateArgs>(args: SelectSubset<T, CheckinCreateArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Checkins.
     * @param {CheckinCreateManyArgs} args - Arguments to create many Checkins.
     * @example
     * // Create many Checkins
     * const checkin = await prisma.checkin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckinCreateManyArgs>(args?: SelectSubset<T, CheckinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkins and returns the data saved in the database.
     * @param {CheckinCreateManyAndReturnArgs} args - Arguments to create many Checkins.
     * @example
     * // Create many Checkins
     * const checkin = await prisma.checkin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkins and only return the `id`
     * const checkinWithIdOnly = await prisma.checkin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckinCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Checkin.
     * @param {CheckinDeleteArgs} args - Arguments to delete one Checkin.
     * @example
     * // Delete one Checkin
     * const Checkin = await prisma.checkin.delete({
     *   where: {
     *     // ... filter to delete one Checkin
     *   }
     * })
     * 
     */
    delete<T extends CheckinDeleteArgs>(args: SelectSubset<T, CheckinDeleteArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Checkin.
     * @param {CheckinUpdateArgs} args - Arguments to update one Checkin.
     * @example
     * // Update one Checkin
     * const checkin = await prisma.checkin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckinUpdateArgs>(args: SelectSubset<T, CheckinUpdateArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Checkins.
     * @param {CheckinDeleteManyArgs} args - Arguments to filter Checkins to delete.
     * @example
     * // Delete a few Checkins
     * const { count } = await prisma.checkin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckinDeleteManyArgs>(args?: SelectSubset<T, CheckinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkins
     * const checkin = await prisma.checkin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckinUpdateManyArgs>(args: SelectSubset<T, CheckinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkins and returns the data updated in the database.
     * @param {CheckinUpdateManyAndReturnArgs} args - Arguments to update many Checkins.
     * @example
     * // Update many Checkins
     * const checkin = await prisma.checkin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Checkins and only return the `id`
     * const checkinWithIdOnly = await prisma.checkin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckinUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Checkin.
     * @param {CheckinUpsertArgs} args - Arguments to update or create a Checkin.
     * @example
     * // Update or create a Checkin
     * const checkin = await prisma.checkin.upsert({
     *   create: {
     *     // ... data to create a Checkin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkin we want to update
     *   }
     * })
     */
    upsert<T extends CheckinUpsertArgs>(args: SelectSubset<T, CheckinUpsertArgs<ExtArgs>>): Prisma__CheckinClient<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinCountArgs} args - Arguments to filter Checkins to count.
     * @example
     * // Count the number of Checkins
     * const count = await prisma.checkin.count({
     *   where: {
     *     // ... the filter for the Checkins we want to count
     *   }
     * })
    **/
    count<T extends CheckinCountArgs>(
      args?: Subset<T, CheckinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckinAggregateArgs>(args: Subset<T, CheckinAggregateArgs>): Prisma.PrismaPromise<GetCheckinAggregateType<T>>

    /**
     * Group by Checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckinGroupByArgs['orderBy'] }
        : { orderBy?: CheckinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Checkin model
   */
  readonly fields: CheckinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Checkin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends Checkin$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin_users<T extends Checkin$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends Checkin$memberArgs<ExtArgs> = {}>(args?: Subset<T, Checkin$memberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Checkin model
   */
  interface CheckinFieldRefs {
    readonly id: FieldRef<"Checkin", 'String'>
    readonly memberId: FieldRef<"Checkin", 'String'>
    readonly badgeId: FieldRef<"Checkin", 'String'>
    readonly direction: FieldRef<"Checkin", 'String'>
    readonly timestamp: FieldRef<"Checkin", 'DateTime'>
    readonly kioskId: FieldRef<"Checkin", 'String'>
    readonly synced: FieldRef<"Checkin", 'Boolean'>
    readonly createdAt: FieldRef<"Checkin", 'DateTime'>
    readonly flagged_for_review: FieldRef<"Checkin", 'Boolean'>
    readonly flag_reason: FieldRef<"Checkin", 'String'>
    readonly method: FieldRef<"Checkin", 'String'>
    readonly created_by_admin: FieldRef<"Checkin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Checkin findUnique
   */
  export type CheckinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where: CheckinWhereUniqueInput
  }

  /**
   * Checkin findUniqueOrThrow
   */
  export type CheckinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where: CheckinWhereUniqueInput
  }

  /**
   * Checkin findFirst
   */
  export type CheckinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkins.
     */
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Checkin findFirstOrThrow
   */
  export type CheckinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkin to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkins.
     */
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Checkin findMany
   */
  export type CheckinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter, which Checkins to fetch.
     */
    where?: CheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkins to fetch.
     */
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Checkins.
     */
    cursor?: CheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkins.
     */
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Checkin create
   */
  export type CheckinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The data needed to create a Checkin.
     */
    data: XOR<CheckinCreateInput, CheckinUncheckedCreateInput>
  }

  /**
   * Checkin createMany
   */
  export type CheckinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Checkins.
     */
    data: CheckinCreateManyInput | CheckinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Checkin createManyAndReturn
   */
  export type CheckinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * The data used to create many Checkins.
     */
    data: CheckinCreateManyInput | CheckinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checkin update
   */
  export type CheckinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The data needed to update a Checkin.
     */
    data: XOR<CheckinUpdateInput, CheckinUncheckedUpdateInput>
    /**
     * Choose, which Checkin to update.
     */
    where: CheckinWhereUniqueInput
  }

  /**
   * Checkin updateMany
   */
  export type CheckinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Checkins.
     */
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyInput>
    /**
     * Filter which Checkins to update
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to update.
     */
    limit?: number
  }

  /**
   * Checkin updateManyAndReturn
   */
  export type CheckinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * The data used to update Checkins.
     */
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyInput>
    /**
     * Filter which Checkins to update
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checkin upsert
   */
  export type CheckinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * The filter to search for the Checkin to update in case it exists.
     */
    where: CheckinWhereUniqueInput
    /**
     * In case the Checkin found by the `where` argument doesn't exist, create a new Checkin with this data.
     */
    create: XOR<CheckinCreateInput, CheckinUncheckedCreateInput>
    /**
     * In case the Checkin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckinUpdateInput, CheckinUncheckedUpdateInput>
  }

  /**
   * Checkin delete
   */
  export type CheckinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    /**
     * Filter which Checkin to delete.
     */
    where: CheckinWhereUniqueInput
  }

  /**
   * Checkin deleteMany
   */
  export type CheckinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkins to delete
     */
    where?: CheckinWhereInput
    /**
     * Limit how many Checkins to delete.
     */
    limit?: number
  }

  /**
   * Checkin.badge
   */
  export type Checkin$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Checkin.admin_users
   */
  export type Checkin$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * Checkin.member
   */
  export type Checkin$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Checkin without action
   */
  export type CheckinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
  }


  /**
   * Model Division
   */

  export type AggregateDivision = {
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  export type DivisionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DivisionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DivisionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DivisionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DivisionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DivisionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DivisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Division to aggregate.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Divisions
    **/
    _count?: true | DivisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionMaxAggregateInputType
  }

  export type GetDivisionAggregateType<T extends DivisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDivision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivision[P]>
      : GetScalarType<T[P], AggregateDivision[P]>
  }




  export type DivisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionWhereInput
    orderBy?: DivisionOrderByWithAggregationInput | DivisionOrderByWithAggregationInput[]
    by: DivisionScalarFieldEnum[] | DivisionScalarFieldEnum
    having?: DivisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionCountAggregateInputType | true
    _min?: DivisionMinAggregateInputType
    _max?: DivisionMaxAggregateInputType
  }

  export type DivisionGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  type GetDivisionGroupByPayload<T extends DivisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionGroupByOutputType[P]>
        }
      >
    >


  export type DivisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Division$membersArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DivisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["division"]>
  export type DivisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Division$membersArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DivisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DivisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DivisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Division"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["division"]>
    composites: {}
  }

  type DivisionGetPayload<S extends boolean | null | undefined | DivisionDefaultArgs> = $Result.GetResult<Prisma.$DivisionPayload, S>

  type DivisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DivisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DivisionCountAggregateInputType | true
    }

  export interface DivisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Division'], meta: { name: 'Division' } }
    /**
     * Find zero or one Division that matches the filter.
     * @param {DivisionFindUniqueArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DivisionFindUniqueArgs>(args: SelectSubset<T, DivisionFindUniqueArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Division that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DivisionFindUniqueOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DivisionFindUniqueOrThrowArgs>(args: SelectSubset<T, DivisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Division that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DivisionFindFirstArgs>(args?: SelectSubset<T, DivisionFindFirstArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Division that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DivisionFindFirstOrThrowArgs>(args?: SelectSubset<T, DivisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.division.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.division.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const divisionWithIdOnly = await prisma.division.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DivisionFindManyArgs>(args?: SelectSubset<T, DivisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Division.
     * @param {DivisionCreateArgs} args - Arguments to create a Division.
     * @example
     * // Create one Division
     * const Division = await prisma.division.create({
     *   data: {
     *     // ... data to create a Division
     *   }
     * })
     * 
     */
    create<T extends DivisionCreateArgs>(args: SelectSubset<T, DivisionCreateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Divisions.
     * @param {DivisionCreateManyArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DivisionCreateManyArgs>(args?: SelectSubset<T, DivisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Divisions and returns the data saved in the database.
     * @param {DivisionCreateManyAndReturnArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Divisions and only return the `id`
     * const divisionWithIdOnly = await prisma.division.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DivisionCreateManyAndReturnArgs>(args?: SelectSubset<T, DivisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Division.
     * @param {DivisionDeleteArgs} args - Arguments to delete one Division.
     * @example
     * // Delete one Division
     * const Division = await prisma.division.delete({
     *   where: {
     *     // ... filter to delete one Division
     *   }
     * })
     * 
     */
    delete<T extends DivisionDeleteArgs>(args: SelectSubset<T, DivisionDeleteArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Division.
     * @param {DivisionUpdateArgs} args - Arguments to update one Division.
     * @example
     * // Update one Division
     * const division = await prisma.division.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DivisionUpdateArgs>(args: SelectSubset<T, DivisionUpdateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Divisions.
     * @param {DivisionDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.division.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DivisionDeleteManyArgs>(args?: SelectSubset<T, DivisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DivisionUpdateManyArgs>(args: SelectSubset<T, DivisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions and returns the data updated in the database.
     * @param {DivisionUpdateManyAndReturnArgs} args - Arguments to update many Divisions.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Divisions and only return the `id`
     * const divisionWithIdOnly = await prisma.division.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DivisionUpdateManyAndReturnArgs>(args: SelectSubset<T, DivisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Division.
     * @param {DivisionUpsertArgs} args - Arguments to update or create a Division.
     * @example
     * // Update or create a Division
     * const division = await prisma.division.upsert({
     *   create: {
     *     // ... data to create a Division
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Division we want to update
     *   }
     * })
     */
    upsert<T extends DivisionUpsertArgs>(args: SelectSubset<T, DivisionUpsertArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.division.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends DivisionCountArgs>(
      args?: Subset<T, DivisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionAggregateArgs>(args: Subset<T, DivisionAggregateArgs>): Prisma.PrismaPromise<GetDivisionAggregateType<T>>

    /**
     * Group by Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DivisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DivisionGroupByArgs['orderBy'] }
        : { orderBy?: DivisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DivisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Division model
   */
  readonly fields: DivisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Division.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DivisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Division$membersArgs<ExtArgs> = {}>(args?: Subset<T, Division$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Division model
   */
  interface DivisionFieldRefs {
    readonly id: FieldRef<"Division", 'String'>
    readonly name: FieldRef<"Division", 'String'>
    readonly code: FieldRef<"Division", 'String'>
    readonly description: FieldRef<"Division", 'String'>
    readonly createdAt: FieldRef<"Division", 'DateTime'>
    readonly updatedAt: FieldRef<"Division", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Division findUnique
   */
  export type DivisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division findUniqueOrThrow
   */
  export type DivisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division findFirst
   */
  export type DivisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division findFirstOrThrow
   */
  export type DivisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division findMany
   */
  export type DivisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division create
   */
  export type DivisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Division.
     */
    data: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
  }

  /**
   * Division createMany
   */
  export type DivisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Division createManyAndReturn
   */
  export type DivisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Division update
   */
  export type DivisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Division.
     */
    data: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
    /**
     * Choose, which Division to update.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division updateMany
   */
  export type DivisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Division updateManyAndReturn
   */
  export type DivisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Division upsert
   */
  export type DivisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Division to update in case it exists.
     */
    where: DivisionWhereUniqueInput
    /**
     * In case the Division found by the `where` argument doesn't exist, create a new Division with this data.
     */
    create: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
    /**
     * In case the Division was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
  }

  /**
   * Division delete
   */
  export type DivisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter which Division to delete.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division deleteMany
   */
  export type DivisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Divisions to delete
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to delete.
     */
    limit?: number
  }

  /**
   * Division.members
   */
  export type Division$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Division without action
   */
  export type DivisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
  }


  /**
   * Model EventAttendee
   */

  export type AggregateEventAttendee = {
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  export type EventAttendeeMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    rank: string | null
    organization: string | null
    role: string | null
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    rank: string | null
    organization: string | null
    role: string | null
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    rank: number
    organization: number
    role: number
    badgeId: number
    badgeAssignedAt: number
    accessStart: number
    accessEnd: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAttendeeMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    rank?: true
    organization?: true
    role?: true
    badgeId?: true
    badgeAssignedAt?: true
    accessStart?: true
    accessEnd?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendee to aggregate.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventAttendees
    **/
    _count?: true | EventAttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventAttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type GetEventAttendeeAggregateType<T extends EventAttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventAttendee[P]>
      : GetScalarType<T[P], AggregateEventAttendee[P]>
  }




  export type EventAttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithAggregationInput | EventAttendeeOrderByWithAggregationInput[]
    by: EventAttendeeScalarFieldEnum[] | EventAttendeeScalarFieldEnum
    having?: EventAttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventAttendeeCountAggregateInputType | true
    _min?: EventAttendeeMinAggregateInputType
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type EventAttendeeGroupByOutputType = {
    id: string
    eventId: string
    name: string
    rank: string | null
    organization: string
    role: string
    badgeId: string | null
    badgeAssignedAt: Date | null
    accessStart: Date | null
    accessEnd: Date | null
    status: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  type GetEventAttendeeGroupByPayload<T extends EventAttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventAttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventAttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
        }
      >
    >


  export type EventAttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    eventCheckins?: boolean | EventAttendee$eventCheckinsArgs<ExtArgs>
    _count?: boolean | EventAttendeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    rank?: boolean
    organization?: boolean
    role?: boolean
    badgeId?: boolean
    badgeAssignedAt?: boolean
    accessStart?: boolean
    accessEnd?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventAttendeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "rank" | "organization" | "role" | "badgeId" | "badgeAssignedAt" | "accessStart" | "accessEnd" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["eventAttendee"]>
  export type EventAttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    eventCheckins?: boolean | EventAttendee$eventCheckinsArgs<ExtArgs>
    _count?: boolean | EventAttendeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventAttendeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventAttendeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | EventAttendee$badgeArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventAttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventAttendee"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs>
      eventCheckins: Prisma.$EventCheckinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      rank: string | null
      organization: string
      role: string
      badgeId: string | null
      badgeAssignedAt: Date | null
      accessStart: Date | null
      accessEnd: Date | null
      status: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["eventAttendee"]>
    composites: {}
  }

  type EventAttendeeGetPayload<S extends boolean | null | undefined | EventAttendeeDefaultArgs> = $Result.GetResult<Prisma.$EventAttendeePayload, S>

  type EventAttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventAttendeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventAttendeeCountAggregateInputType | true
    }

  export interface EventAttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventAttendee'], meta: { name: 'EventAttendee' } }
    /**
     * Find zero or one EventAttendee that matches the filter.
     * @param {EventAttendeeFindUniqueArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventAttendeeFindUniqueArgs>(args: SelectSubset<T, EventAttendeeFindUniqueArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventAttendee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventAttendeeFindUniqueOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventAttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventAttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventAttendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventAttendeeFindFirstArgs>(args?: SelectSubset<T, EventAttendeeFindFirstArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventAttendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventAttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventAttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventAttendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany()
     * 
     * // Get first 10 EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventAttendeeFindManyArgs>(args?: SelectSubset<T, EventAttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventAttendee.
     * @param {EventAttendeeCreateArgs} args - Arguments to create a EventAttendee.
     * @example
     * // Create one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.create({
     *   data: {
     *     // ... data to create a EventAttendee
     *   }
     * })
     * 
     */
    create<T extends EventAttendeeCreateArgs>(args: SelectSubset<T, EventAttendeeCreateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventAttendees.
     * @param {EventAttendeeCreateManyArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventAttendeeCreateManyArgs>(args?: SelectSubset<T, EventAttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventAttendees and returns the data saved in the database.
     * @param {EventAttendeeCreateManyAndReturnArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventAttendees and only return the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventAttendeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EventAttendeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventAttendee.
     * @param {EventAttendeeDeleteArgs} args - Arguments to delete one EventAttendee.
     * @example
     * // Delete one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.delete({
     *   where: {
     *     // ... filter to delete one EventAttendee
     *   }
     * })
     * 
     */
    delete<T extends EventAttendeeDeleteArgs>(args: SelectSubset<T, EventAttendeeDeleteArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventAttendee.
     * @param {EventAttendeeUpdateArgs} args - Arguments to update one EventAttendee.
     * @example
     * // Update one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventAttendeeUpdateArgs>(args: SelectSubset<T, EventAttendeeUpdateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventAttendees.
     * @param {EventAttendeeDeleteManyArgs} args - Arguments to filter EventAttendees to delete.
     * @example
     * // Delete a few EventAttendees
     * const { count } = await prisma.eventAttendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventAttendeeDeleteManyArgs>(args?: SelectSubset<T, EventAttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventAttendeeUpdateManyArgs>(args: SelectSubset<T, EventAttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAttendees and returns the data updated in the database.
     * @param {EventAttendeeUpdateManyAndReturnArgs} args - Arguments to update many EventAttendees.
     * @example
     * // Update many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventAttendees and only return the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventAttendeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EventAttendeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventAttendee.
     * @param {EventAttendeeUpsertArgs} args - Arguments to update or create a EventAttendee.
     * @example
     * // Update or create a EventAttendee
     * const eventAttendee = await prisma.eventAttendee.upsert({
     *   create: {
     *     // ... data to create a EventAttendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventAttendee we want to update
     *   }
     * })
     */
    upsert<T extends EventAttendeeUpsertArgs>(args: SelectSubset<T, EventAttendeeUpsertArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeCountArgs} args - Arguments to filter EventAttendees to count.
     * @example
     * // Count the number of EventAttendees
     * const count = await prisma.eventAttendee.count({
     *   where: {
     *     // ... the filter for the EventAttendees we want to count
     *   }
     * })
    **/
    count<T extends EventAttendeeCountArgs>(
      args?: Subset<T, EventAttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventAttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAttendeeAggregateArgs>(args: Subset<T, EventAttendeeAggregateArgs>): Prisma.PrismaPromise<GetEventAttendeeAggregateType<T>>

    /**
     * Group by EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventAttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventAttendeeGroupByArgs['orderBy'] }
        : { orderBy?: EventAttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventAttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventAttendee model
   */
  readonly fields: EventAttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventAttendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventAttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends EventAttendee$badgeArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendee$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventCheckins<T extends EventAttendee$eventCheckinsArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendee$eventCheckinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventAttendee model
   */
  interface EventAttendeeFieldRefs {
    readonly id: FieldRef<"EventAttendee", 'String'>
    readonly eventId: FieldRef<"EventAttendee", 'String'>
    readonly name: FieldRef<"EventAttendee", 'String'>
    readonly rank: FieldRef<"EventAttendee", 'String'>
    readonly organization: FieldRef<"EventAttendee", 'String'>
    readonly role: FieldRef<"EventAttendee", 'String'>
    readonly badgeId: FieldRef<"EventAttendee", 'String'>
    readonly badgeAssignedAt: FieldRef<"EventAttendee", 'DateTime'>
    readonly accessStart: FieldRef<"EventAttendee", 'DateTime'>
    readonly accessEnd: FieldRef<"EventAttendee", 'DateTime'>
    readonly status: FieldRef<"EventAttendee", 'String'>
    readonly createdAt: FieldRef<"EventAttendee", 'DateTime'>
    readonly updatedAt: FieldRef<"EventAttendee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventAttendee findUnique
   */
  export type EventAttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee findUniqueOrThrow
   */
  export type EventAttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee findFirst
   */
  export type EventAttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee findFirstOrThrow
   */
  export type EventAttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee findMany
   */
  export type EventAttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendees to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee create
   */
  export type EventAttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventAttendee.
     */
    data: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
  }

  /**
   * EventAttendee createMany
   */
  export type EventAttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventAttendee createManyAndReturn
   */
  export type EventAttendeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAttendee update
   */
  export type EventAttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventAttendee.
     */
    data: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
    /**
     * Choose, which EventAttendee to update.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee updateMany
   */
  export type EventAttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventAttendees.
     */
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which EventAttendees to update
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to update.
     */
    limit?: number
  }

  /**
   * EventAttendee updateManyAndReturn
   */
  export type EventAttendeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * The data used to update EventAttendees.
     */
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which EventAttendees to update
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAttendee upsert
   */
  export type EventAttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventAttendee to update in case it exists.
     */
    where: EventAttendeeWhereUniqueInput
    /**
     * In case the EventAttendee found by the `where` argument doesn't exist, create a new EventAttendee with this data.
     */
    create: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
    /**
     * In case the EventAttendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
  }

  /**
   * EventAttendee delete
   */
  export type EventAttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter which EventAttendee to delete.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee deleteMany
   */
  export type EventAttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendees to delete
     */
    where?: EventAttendeeWhereInput
    /**
     * Limit how many EventAttendees to delete.
     */
    limit?: number
  }

  /**
   * EventAttendee.badge
   */
  export type EventAttendee$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * EventAttendee.eventCheckins
   */
  export type EventAttendee$eventCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    cursor?: EventCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * EventAttendee without action
   */
  export type EventAttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
  }


  /**
   * Model EventCheckin
   */

  export type AggregateEventCheckin = {
    _count: EventCheckinCountAggregateOutputType | null
    _min: EventCheckinMinAggregateOutputType | null
    _max: EventCheckinMaxAggregateOutputType | null
  }

  export type EventCheckinMinAggregateOutputType = {
    id: string | null
    eventAttendeeId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    createdAt: Date | null
  }

  export type EventCheckinMaxAggregateOutputType = {
    id: string | null
    eventAttendeeId: string | null
    badgeId: string | null
    direction: string | null
    timestamp: Date | null
    kioskId: string | null
    createdAt: Date | null
  }

  export type EventCheckinCountAggregateOutputType = {
    id: number
    eventAttendeeId: number
    badgeId: number
    direction: number
    timestamp: number
    kioskId: number
    createdAt: number
    _all: number
  }


  export type EventCheckinMinAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
  }

  export type EventCheckinMaxAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
  }

  export type EventCheckinCountAggregateInputType = {
    id?: true
    eventAttendeeId?: true
    badgeId?: true
    direction?: true
    timestamp?: true
    kioskId?: true
    createdAt?: true
    _all?: true
  }

  export type EventCheckinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCheckin to aggregate.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCheckins
    **/
    _count?: true | EventCheckinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCheckinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCheckinMaxAggregateInputType
  }

  export type GetEventCheckinAggregateType<T extends EventCheckinAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCheckin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCheckin[P]>
      : GetScalarType<T[P], AggregateEventCheckin[P]>
  }




  export type EventCheckinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCheckinWhereInput
    orderBy?: EventCheckinOrderByWithAggregationInput | EventCheckinOrderByWithAggregationInput[]
    by: EventCheckinScalarFieldEnum[] | EventCheckinScalarFieldEnum
    having?: EventCheckinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCheckinCountAggregateInputType | true
    _min?: EventCheckinMinAggregateInputType
    _max?: EventCheckinMaxAggregateInputType
  }

  export type EventCheckinGroupByOutputType = {
    id: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp: Date
    kioskId: string
    createdAt: Date | null
    _count: EventCheckinCountAggregateOutputType | null
    _min: EventCheckinMinAggregateOutputType | null
    _max: EventCheckinMaxAggregateOutputType | null
  }

  type GetEventCheckinGroupByPayload<T extends EventCheckinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCheckinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCheckinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCheckinGroupByOutputType[P]>
            : GetScalarType<T[P], EventCheckinGroupByOutputType[P]>
        }
      >
    >


  export type EventCheckinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCheckin"]>

  export type EventCheckinSelectScalar = {
    id?: boolean
    eventAttendeeId?: boolean
    badgeId?: boolean
    direction?: boolean
    timestamp?: boolean
    kioskId?: boolean
    createdAt?: boolean
  }

  export type EventCheckinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventAttendeeId" | "badgeId" | "direction" | "timestamp" | "kioskId" | "createdAt", ExtArgs["result"]["eventCheckin"]>
  export type EventCheckinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }
  export type EventCheckinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }
  export type EventCheckinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    eventAttendee?: boolean | EventAttendeeDefaultArgs<ExtArgs>
  }

  export type $EventCheckinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCheckin"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs>
      eventAttendee: Prisma.$EventAttendeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventAttendeeId: string
      badgeId: string
      direction: string
      timestamp: Date
      kioskId: string
      createdAt: Date | null
    }, ExtArgs["result"]["eventCheckin"]>
    composites: {}
  }

  type EventCheckinGetPayload<S extends boolean | null | undefined | EventCheckinDefaultArgs> = $Result.GetResult<Prisma.$EventCheckinPayload, S>

  type EventCheckinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventCheckinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCheckinCountAggregateInputType | true
    }

  export interface EventCheckinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCheckin'], meta: { name: 'EventCheckin' } }
    /**
     * Find zero or one EventCheckin that matches the filter.
     * @param {EventCheckinFindUniqueArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCheckinFindUniqueArgs>(args: SelectSubset<T, EventCheckinFindUniqueArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventCheckin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventCheckinFindUniqueOrThrowArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCheckinFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCheckinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventCheckin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindFirstArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCheckinFindFirstArgs>(args?: SelectSubset<T, EventCheckinFindFirstArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventCheckin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindFirstOrThrowArgs} args - Arguments to find a EventCheckin
     * @example
     * // Get one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCheckinFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCheckinFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventCheckins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCheckins
     * const eventCheckins = await prisma.eventCheckin.findMany()
     * 
     * // Get first 10 EventCheckins
     * const eventCheckins = await prisma.eventCheckin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCheckinFindManyArgs>(args?: SelectSubset<T, EventCheckinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventCheckin.
     * @param {EventCheckinCreateArgs} args - Arguments to create a EventCheckin.
     * @example
     * // Create one EventCheckin
     * const EventCheckin = await prisma.eventCheckin.create({
     *   data: {
     *     // ... data to create a EventCheckin
     *   }
     * })
     * 
     */
    create<T extends EventCheckinCreateArgs>(args: SelectSubset<T, EventCheckinCreateArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventCheckins.
     * @param {EventCheckinCreateManyArgs} args - Arguments to create many EventCheckins.
     * @example
     * // Create many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCheckinCreateManyArgs>(args?: SelectSubset<T, EventCheckinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventCheckins and returns the data saved in the database.
     * @param {EventCheckinCreateManyAndReturnArgs} args - Arguments to create many EventCheckins.
     * @example
     * // Create many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventCheckins and only return the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCheckinCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCheckinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventCheckin.
     * @param {EventCheckinDeleteArgs} args - Arguments to delete one EventCheckin.
     * @example
     * // Delete one EventCheckin
     * const EventCheckin = await prisma.eventCheckin.delete({
     *   where: {
     *     // ... filter to delete one EventCheckin
     *   }
     * })
     * 
     */
    delete<T extends EventCheckinDeleteArgs>(args: SelectSubset<T, EventCheckinDeleteArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventCheckin.
     * @param {EventCheckinUpdateArgs} args - Arguments to update one EventCheckin.
     * @example
     * // Update one EventCheckin
     * const eventCheckin = await prisma.eventCheckin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCheckinUpdateArgs>(args: SelectSubset<T, EventCheckinUpdateArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventCheckins.
     * @param {EventCheckinDeleteManyArgs} args - Arguments to filter EventCheckins to delete.
     * @example
     * // Delete a few EventCheckins
     * const { count } = await prisma.eventCheckin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCheckinDeleteManyArgs>(args?: SelectSubset<T, EventCheckinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCheckinUpdateManyArgs>(args: SelectSubset<T, EventCheckinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCheckins and returns the data updated in the database.
     * @param {EventCheckinUpdateManyAndReturnArgs} args - Arguments to update many EventCheckins.
     * @example
     * // Update many EventCheckins
     * const eventCheckin = await prisma.eventCheckin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventCheckins and only return the `id`
     * const eventCheckinWithIdOnly = await prisma.eventCheckin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventCheckinUpdateManyAndReturnArgs>(args: SelectSubset<T, EventCheckinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventCheckin.
     * @param {EventCheckinUpsertArgs} args - Arguments to update or create a EventCheckin.
     * @example
     * // Update or create a EventCheckin
     * const eventCheckin = await prisma.eventCheckin.upsert({
     *   create: {
     *     // ... data to create a EventCheckin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCheckin we want to update
     *   }
     * })
     */
    upsert<T extends EventCheckinUpsertArgs>(args: SelectSubset<T, EventCheckinUpsertArgs<ExtArgs>>): Prisma__EventCheckinClient<$Result.GetResult<Prisma.$EventCheckinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinCountArgs} args - Arguments to filter EventCheckins to count.
     * @example
     * // Count the number of EventCheckins
     * const count = await prisma.eventCheckin.count({
     *   where: {
     *     // ... the filter for the EventCheckins we want to count
     *   }
     * })
    **/
    count<T extends EventCheckinCountArgs>(
      args?: Subset<T, EventCheckinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCheckinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCheckinAggregateArgs>(args: Subset<T, EventCheckinAggregateArgs>): Prisma.PrismaPromise<GetEventCheckinAggregateType<T>>

    /**
     * Group by EventCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCheckinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCheckinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCheckinGroupByArgs['orderBy'] }
        : { orderBy?: EventCheckinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCheckinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCheckinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCheckin model
   */
  readonly fields: EventCheckinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCheckin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCheckinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventAttendee<T extends EventAttendeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventAttendeeDefaultArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCheckin model
   */
  interface EventCheckinFieldRefs {
    readonly id: FieldRef<"EventCheckin", 'String'>
    readonly eventAttendeeId: FieldRef<"EventCheckin", 'String'>
    readonly badgeId: FieldRef<"EventCheckin", 'String'>
    readonly direction: FieldRef<"EventCheckin", 'String'>
    readonly timestamp: FieldRef<"EventCheckin", 'DateTime'>
    readonly kioskId: FieldRef<"EventCheckin", 'String'>
    readonly createdAt: FieldRef<"EventCheckin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventCheckin findUnique
   */
  export type EventCheckinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where: EventCheckinWhereUniqueInput
  }

  /**
   * EventCheckin findUniqueOrThrow
   */
  export type EventCheckinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where: EventCheckinWhereUniqueInput
  }

  /**
   * EventCheckin findFirst
   */
  export type EventCheckinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCheckins.
     */
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * EventCheckin findFirstOrThrow
   */
  export type EventCheckinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckin to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCheckins.
     */
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * EventCheckin findMany
   */
  export type EventCheckinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter, which EventCheckins to fetch.
     */
    where?: EventCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCheckins to fetch.
     */
    orderBy?: EventCheckinOrderByWithRelationInput | EventCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCheckins.
     */
    cursor?: EventCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCheckins.
     */
    skip?: number
    distinct?: EventCheckinScalarFieldEnum | EventCheckinScalarFieldEnum[]
  }

  /**
   * EventCheckin create
   */
  export type EventCheckinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCheckin.
     */
    data: XOR<EventCheckinCreateInput, EventCheckinUncheckedCreateInput>
  }

  /**
   * EventCheckin createMany
   */
  export type EventCheckinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCheckins.
     */
    data: EventCheckinCreateManyInput | EventCheckinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCheckin createManyAndReturn
   */
  export type EventCheckinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * The data used to create many EventCheckins.
     */
    data: EventCheckinCreateManyInput | EventCheckinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCheckin update
   */
  export type EventCheckinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCheckin.
     */
    data: XOR<EventCheckinUpdateInput, EventCheckinUncheckedUpdateInput>
    /**
     * Choose, which EventCheckin to update.
     */
    where: EventCheckinWhereUniqueInput
  }

  /**
   * EventCheckin updateMany
   */
  export type EventCheckinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCheckins.
     */
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyInput>
    /**
     * Filter which EventCheckins to update
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to update.
     */
    limit?: number
  }

  /**
   * EventCheckin updateManyAndReturn
   */
  export type EventCheckinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * The data used to update EventCheckins.
     */
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyInput>
    /**
     * Filter which EventCheckins to update
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCheckin upsert
   */
  export type EventCheckinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCheckin to update in case it exists.
     */
    where: EventCheckinWhereUniqueInput
    /**
     * In case the EventCheckin found by the `where` argument doesn't exist, create a new EventCheckin with this data.
     */
    create: XOR<EventCheckinCreateInput, EventCheckinUncheckedCreateInput>
    /**
     * In case the EventCheckin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCheckinUpdateInput, EventCheckinUncheckedUpdateInput>
  }

  /**
   * EventCheckin delete
   */
  export type EventCheckinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
    /**
     * Filter which EventCheckin to delete.
     */
    where: EventCheckinWhereUniqueInput
  }

  /**
   * EventCheckin deleteMany
   */
  export type EventCheckinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCheckins to delete
     */
    where?: EventCheckinWhereInput
    /**
     * Limit how many EventCheckins to delete.
     */
    limit?: number
  }

  /**
   * EventCheckin without action
   */
  export type EventCheckinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCheckin
     */
    select?: EventCheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCheckin
     */
    omit?: EventCheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCheckinInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    autoExpireBadges: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    autoExpireBadges: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    startDate: number
    endDate: number
    status: number
    autoExpireBadges: number
    customRoles: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    autoExpireBadges?: true
    customRoles?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    startDate: Date
    endDate: Date
    status: string
    autoExpireBadges: boolean | null
    customRoles: JsonValue | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventAttendees?: boolean | Event$eventAttendeesArgs<ExtArgs>
    visitors?: boolean | Event$visitorsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoExpireBadges?: boolean
    customRoles?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "startDate" | "endDate" | "status" | "autoExpireBadges" | "customRoles" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventAttendees?: boolean | Event$eventAttendeesArgs<ExtArgs>
    visitors?: boolean | Event$visitorsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      eventAttendees: Prisma.$EventAttendeePayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      startDate: Date
      endDate: Date
      status: string
      autoExpireBadges: boolean | null
      customRoles: Prisma.JsonValue | null
      createdBy: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventAttendees<T extends Event$eventAttendeesArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventAttendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Event$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Event$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly code: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly status: FieldRef<"Event", 'String'>
    readonly autoExpireBadges: FieldRef<"Event", 'Boolean'>
    readonly customRoles: FieldRef<"Event", 'Json'>
    readonly createdBy: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.eventAttendees
   */
  export type Event$eventAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventAttendee
     */
    omit?: EventAttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * Event.visitors
   */
  export type Event$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    serviceNumber: string | null
    rank: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string | null
    status: string | null
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    serviceNumber: string | null
    rank: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string | null
    status: string | null
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    serviceNumber: number
    rank: number
    firstName: number
    lastName: number
    email: number
    mobilePhone: number
    divisionId: number
    badgeId: number
    memberType: number
    status: number
    memberTypeId: number
    memberStatusId: number
    createdAt: number
    updatedAt: number
    employeeNumber: number
    initials: number
    mess: number
    moc: number
    classDetails: number
    homePhone: number
    notes: number
    contract_start: number
    contract_end: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    serviceNumber?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    serviceNumber?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    serviceNumber?: true
    rank?: true
    firstName?: true
    lastName?: true
    email?: true
    mobilePhone?: true
    divisionId?: true
    badgeId?: true
    memberType?: true
    status?: true
    memberTypeId?: true
    memberStatusId?: true
    createdAt?: true
    updatedAt?: true
    employeeNumber?: true
    initials?: true
    mess?: true
    moc?: true
    classDetails?: true
    homePhone?: true
    notes?: true
    contract_start?: true
    contract_end?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email: string | null
    mobilePhone: string | null
    divisionId: string | null
    badgeId: string | null
    memberType: string
    status: string
    memberTypeId: string | null
    memberStatusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeNumber: string | null
    initials: string | null
    mess: string | null
    moc: string | null
    classDetails: string | null
    homePhone: string | null
    notes: string | null
    contract_start: Date | null
    contract_end: Date | null
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    badge?: boolean | Member$badgeArgs<ExtArgs>
    bmqEnrollments?: boolean | Member$bmqEnrollmentsArgs<ExtArgs>
    checkins?: boolean | Member$checkinsArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    visitors?: boolean | Member$visitorsArgs<ExtArgs>
    memberTags?: boolean | Member$memberTagsArgs<ExtArgs>
    ddsAssignments?: boolean | Member$ddsAssignmentsArgs<ExtArgs>
    ddsTransfers?: boolean | Member$ddsTransfersArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNumber?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    serviceNumber?: boolean
    rank?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    mobilePhone?: boolean
    divisionId?: boolean
    badgeId?: boolean
    memberType?: boolean
    status?: boolean
    memberTypeId?: boolean
    memberStatusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeNumber?: boolean
    initials?: boolean
    mess?: boolean
    moc?: boolean
    classDetails?: boolean
    homePhone?: boolean
    notes?: boolean
    contract_start?: boolean
    contract_end?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceNumber" | "rank" | "firstName" | "lastName" | "email" | "mobilePhone" | "divisionId" | "badgeId" | "memberType" | "status" | "memberTypeId" | "memberStatusId" | "createdAt" | "updatedAt" | "employeeNumber" | "initials" | "mess" | "moc" | "classDetails" | "homePhone" | "notes" | "contract_start" | "contract_end", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Member$badgeArgs<ExtArgs>
    bmqEnrollments?: boolean | Member$bmqEnrollmentsArgs<ExtArgs>
    checkins?: boolean | Member$checkinsArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    visitors?: boolean | Member$visitorsArgs<ExtArgs>
    memberTags?: boolean | Member$memberTagsArgs<ExtArgs>
    ddsAssignments?: boolean | Member$ddsAssignmentsArgs<ExtArgs>
    ddsTransfers?: boolean | Member$ddsTransfersArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | Member$badgeArgs<ExtArgs>
    division?: boolean | Member$divisionArgs<ExtArgs>
    memberTypeRef?: boolean | Member$memberTypeRefArgs<ExtArgs>
    memberStatusRef?: boolean | Member$memberStatusRefArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs> | null
      bmqEnrollments: Prisma.$BmqEnrollmentPayload<ExtArgs>[]
      checkins: Prisma.$CheckinPayload<ExtArgs>[]
      division: Prisma.$DivisionPayload<ExtArgs> | null
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      memberTags: Prisma.$MemberTagPayload<ExtArgs>[]
      ddsAssignments: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      ddsTransfers: Prisma.$DdsAssignmentPayload<ExtArgs>[]
      memberTypeRef: Prisma.$MemberTypePayload<ExtArgs> | null
      memberStatusRef: Prisma.$MemberStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceNumber: string
      rank: string
      firstName: string
      lastName: string
      email: string | null
      mobilePhone: string | null
      divisionId: string | null
      badgeId: string | null
      memberType: string
      status: string
      memberTypeId: string | null
      memberStatusId: string | null
      createdAt: Date | null
      updatedAt: Date | null
      employeeNumber: string | null
      initials: string | null
      mess: string | null
      moc: string | null
      classDetails: string | null
      homePhone: string | null
      notes: string | null
      contract_start: Date | null
      contract_end: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends Member$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Member$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bmqEnrollments<T extends Member$bmqEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$bmqEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkins<T extends Member$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Member$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    division<T extends Member$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Member$divisionArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitors<T extends Member$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Member$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberTags<T extends Member$memberTagsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsAssignments<T extends Member$ddsAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$ddsAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ddsTransfers<T extends Member$ddsTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Member$ddsTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberTypeRef<T extends Member$memberTypeRefArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberTypeRefArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    memberStatusRef<T extends Member$memberStatusRefArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberStatusRefArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly serviceNumber: FieldRef<"Member", 'String'>
    readonly rank: FieldRef<"Member", 'String'>
    readonly firstName: FieldRef<"Member", 'String'>
    readonly lastName: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly mobilePhone: FieldRef<"Member", 'String'>
    readonly divisionId: FieldRef<"Member", 'String'>
    readonly badgeId: FieldRef<"Member", 'String'>
    readonly memberType: FieldRef<"Member", 'String'>
    readonly status: FieldRef<"Member", 'String'>
    readonly memberTypeId: FieldRef<"Member", 'String'>
    readonly memberStatusId: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly employeeNumber: FieldRef<"Member", 'String'>
    readonly initials: FieldRef<"Member", 'String'>
    readonly mess: FieldRef<"Member", 'String'>
    readonly moc: FieldRef<"Member", 'String'>
    readonly classDetails: FieldRef<"Member", 'String'>
    readonly homePhone: FieldRef<"Member", 'String'>
    readonly notes: FieldRef<"Member", 'String'>
    readonly contract_start: FieldRef<"Member", 'DateTime'>
    readonly contract_end: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.badge
   */
  export type Member$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Member.bmqEnrollments
   */
  export type Member$bmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    cursor?: BmqEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * Member.checkins
   */
  export type Member$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkin
     */
    select?: CheckinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checkin
     */
    omit?: CheckinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckinInclude<ExtArgs> | null
    where?: CheckinWhereInput
    orderBy?: CheckinOrderByWithRelationInput | CheckinOrderByWithRelationInput[]
    cursor?: CheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckinScalarFieldEnum | CheckinScalarFieldEnum[]
  }

  /**
   * Member.division
   */
  export type Member$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
  }

  /**
   * Member.visitors
   */
  export type Member$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Member.memberTags
   */
  export type Member$memberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    cursor?: MemberTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * Member.ddsAssignments
   */
  export type Member$ddsAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * Member.ddsTransfers
   */
  export type Member$ddsTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    cursor?: DdsAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * Member.memberTypeRef
   */
  export type Member$memberTypeRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    where?: MemberTypeWhereInput
  }

  /**
   * Member.memberStatusRef
   */
  export type Member$memberStatusRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    where?: MemberStatusWhereInput
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TagSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    description: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TagSumAggregateInputType = {
    displayOrder?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string
    description: string | null
    displayOrder: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberTags?: boolean | Tag$memberTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "description" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberTags?: boolean | Tag$memberTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      memberTags: Prisma.$MemberTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      description: string | null
      displayOrder: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberTags<T extends Tag$memberTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$memberTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly displayOrder: FieldRef<"Tag", 'Int'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.memberTags
   */
  export type Tag$memberTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    cursor?: MemberTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model MemberTag
   */

  export type AggregateMemberTag = {
    _count: MemberTagCountAggregateOutputType | null
    _min: MemberTagMinAggregateOutputType | null
    _max: MemberTagMaxAggregateOutputType | null
  }

  export type MemberTagMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MemberTagMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type MemberTagCountAggregateOutputType = {
    id: number
    memberId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type MemberTagMinAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
  }

  export type MemberTagMaxAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
  }

  export type MemberTagCountAggregateInputType = {
    id?: true
    memberId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type MemberTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTag to aggregate.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberTags
    **/
    _count?: true | MemberTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberTagMaxAggregateInputType
  }

  export type GetMemberTagAggregateType<T extends MemberTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberTag[P]>
      : GetScalarType<T[P], AggregateMemberTag[P]>
  }




  export type MemberTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTagWhereInput
    orderBy?: MemberTagOrderByWithAggregationInput | MemberTagOrderByWithAggregationInput[]
    by: MemberTagScalarFieldEnum[] | MemberTagScalarFieldEnum
    having?: MemberTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberTagCountAggregateInputType | true
    _min?: MemberTagMinAggregateInputType
    _max?: MemberTagMaxAggregateInputType
  }

  export type MemberTagGroupByOutputType = {
    id: string
    memberId: string
    tagId: string
    createdAt: Date | null
    _count: MemberTagCountAggregateOutputType | null
    _min: MemberTagMinAggregateOutputType | null
    _max: MemberTagMaxAggregateOutputType | null
  }

  type GetMemberTagGroupByPayload<T extends MemberTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberTagGroupByOutputType[P]>
            : GetScalarType<T[P], MemberTagGroupByOutputType[P]>
        }
      >
    >


  export type MemberTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberTag"]>

  export type MemberTagSelectScalar = {
    id?: boolean
    memberId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type MemberTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "tagId" | "createdAt", ExtArgs["result"]["memberTag"]>
  export type MemberTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MemberTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MemberTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $MemberTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberTag"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      tagId: string
      createdAt: Date | null
    }, ExtArgs["result"]["memberTag"]>
    composites: {}
  }

  type MemberTagGetPayload<S extends boolean | null | undefined | MemberTagDefaultArgs> = $Result.GetResult<Prisma.$MemberTagPayload, S>

  type MemberTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberTagCountAggregateInputType | true
    }

  export interface MemberTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberTag'], meta: { name: 'MemberTag' } }
    /**
     * Find zero or one MemberTag that matches the filter.
     * @param {MemberTagFindUniqueArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberTagFindUniqueArgs>(args: SelectSubset<T, MemberTagFindUniqueArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberTagFindUniqueOrThrowArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberTagFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindFirstArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberTagFindFirstArgs>(args?: SelectSubset<T, MemberTagFindFirstArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindFirstOrThrowArgs} args - Arguments to find a MemberTag
     * @example
     * // Get one MemberTag
     * const memberTag = await prisma.memberTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberTagFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberTags
     * const memberTags = await prisma.memberTag.findMany()
     * 
     * // Get first 10 MemberTags
     * const memberTags = await prisma.memberTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberTagFindManyArgs>(args?: SelectSubset<T, MemberTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberTag.
     * @param {MemberTagCreateArgs} args - Arguments to create a MemberTag.
     * @example
     * // Create one MemberTag
     * const MemberTag = await prisma.memberTag.create({
     *   data: {
     *     // ... data to create a MemberTag
     *   }
     * })
     * 
     */
    create<T extends MemberTagCreateArgs>(args: SelectSubset<T, MemberTagCreateArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberTags.
     * @param {MemberTagCreateManyArgs} args - Arguments to create many MemberTags.
     * @example
     * // Create many MemberTags
     * const memberTag = await prisma.memberTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberTagCreateManyArgs>(args?: SelectSubset<T, MemberTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberTags and returns the data saved in the database.
     * @param {MemberTagCreateManyAndReturnArgs} args - Arguments to create many MemberTags.
     * @example
     * // Create many MemberTags
     * const memberTag = await prisma.memberTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberTags and only return the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberTagCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberTag.
     * @param {MemberTagDeleteArgs} args - Arguments to delete one MemberTag.
     * @example
     * // Delete one MemberTag
     * const MemberTag = await prisma.memberTag.delete({
     *   where: {
     *     // ... filter to delete one MemberTag
     *   }
     * })
     * 
     */
    delete<T extends MemberTagDeleteArgs>(args: SelectSubset<T, MemberTagDeleteArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberTag.
     * @param {MemberTagUpdateArgs} args - Arguments to update one MemberTag.
     * @example
     * // Update one MemberTag
     * const memberTag = await prisma.memberTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberTagUpdateArgs>(args: SelectSubset<T, MemberTagUpdateArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberTags.
     * @param {MemberTagDeleteManyArgs} args - Arguments to filter MemberTags to delete.
     * @example
     * // Delete a few MemberTags
     * const { count } = await prisma.memberTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberTagDeleteManyArgs>(args?: SelectSubset<T, MemberTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberTags
     * const memberTag = await prisma.memberTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberTagUpdateManyArgs>(args: SelectSubset<T, MemberTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTags and returns the data updated in the database.
     * @param {MemberTagUpdateManyAndReturnArgs} args - Arguments to update many MemberTags.
     * @example
     * // Update many MemberTags
     * const memberTag = await prisma.memberTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberTags and only return the `id`
     * const memberTagWithIdOnly = await prisma.memberTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberTagUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberTag.
     * @param {MemberTagUpsertArgs} args - Arguments to update or create a MemberTag.
     * @example
     * // Update or create a MemberTag
     * const memberTag = await prisma.memberTag.upsert({
     *   create: {
     *     // ... data to create a MemberTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberTag we want to update
     *   }
     * })
     */
    upsert<T extends MemberTagUpsertArgs>(args: SelectSubset<T, MemberTagUpsertArgs<ExtArgs>>): Prisma__MemberTagClient<$Result.GetResult<Prisma.$MemberTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagCountArgs} args - Arguments to filter MemberTags to count.
     * @example
     * // Count the number of MemberTags
     * const count = await prisma.memberTag.count({
     *   where: {
     *     // ... the filter for the MemberTags we want to count
     *   }
     * })
    **/
    count<T extends MemberTagCountArgs>(
      args?: Subset<T, MemberTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberTagAggregateArgs>(args: Subset<T, MemberTagAggregateArgs>): Prisma.PrismaPromise<GetMemberTagAggregateType<T>>

    /**
     * Group by MemberTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberTagGroupByArgs['orderBy'] }
        : { orderBy?: MemberTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberTag model
   */
  readonly fields: MemberTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberTag model
   */
  interface MemberTagFieldRefs {
    readonly id: FieldRef<"MemberTag", 'String'>
    readonly memberId: FieldRef<"MemberTag", 'String'>
    readonly tagId: FieldRef<"MemberTag", 'String'>
    readonly createdAt: FieldRef<"MemberTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberTag findUnique
   */
  export type MemberTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where: MemberTagWhereUniqueInput
  }

  /**
   * MemberTag findUniqueOrThrow
   */
  export type MemberTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where: MemberTagWhereUniqueInput
  }

  /**
   * MemberTag findFirst
   */
  export type MemberTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTags.
     */
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * MemberTag findFirstOrThrow
   */
  export type MemberTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTag to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTags.
     */
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * MemberTag findMany
   */
  export type MemberTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter, which MemberTags to fetch.
     */
    where?: MemberTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTags to fetch.
     */
    orderBy?: MemberTagOrderByWithRelationInput | MemberTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberTags.
     */
    cursor?: MemberTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTags.
     */
    skip?: number
    distinct?: MemberTagScalarFieldEnum | MemberTagScalarFieldEnum[]
  }

  /**
   * MemberTag create
   */
  export type MemberTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberTag.
     */
    data: XOR<MemberTagCreateInput, MemberTagUncheckedCreateInput>
  }

  /**
   * MemberTag createMany
   */
  export type MemberTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberTags.
     */
    data: MemberTagCreateManyInput | MemberTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberTag createManyAndReturn
   */
  export type MemberTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * The data used to create many MemberTags.
     */
    data: MemberTagCreateManyInput | MemberTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberTag update
   */
  export type MemberTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberTag.
     */
    data: XOR<MemberTagUpdateInput, MemberTagUncheckedUpdateInput>
    /**
     * Choose, which MemberTag to update.
     */
    where: MemberTagWhereUniqueInput
  }

  /**
   * MemberTag updateMany
   */
  export type MemberTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberTags.
     */
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyInput>
    /**
     * Filter which MemberTags to update
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to update.
     */
    limit?: number
  }

  /**
   * MemberTag updateManyAndReturn
   */
  export type MemberTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * The data used to update MemberTags.
     */
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyInput>
    /**
     * Filter which MemberTags to update
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberTag upsert
   */
  export type MemberTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberTag to update in case it exists.
     */
    where: MemberTagWhereUniqueInput
    /**
     * In case the MemberTag found by the `where` argument doesn't exist, create a new MemberTag with this data.
     */
    create: XOR<MemberTagCreateInput, MemberTagUncheckedCreateInput>
    /**
     * In case the MemberTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberTagUpdateInput, MemberTagUncheckedUpdateInput>
  }

  /**
   * MemberTag delete
   */
  export type MemberTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
    /**
     * Filter which MemberTag to delete.
     */
    where: MemberTagWhereUniqueInput
  }

  /**
   * MemberTag deleteMany
   */
  export type MemberTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTags to delete
     */
    where?: MemberTagWhereInput
    /**
     * Limit how many MemberTags to delete.
     */
    limit?: number
  }

  /**
   * MemberTag without action
   */
  export type MemberTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTag
     */
    select?: MemberTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTag
     */
    omit?: MemberTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTagInclude<ExtArgs> | null
  }


  /**
   * Model SecurityAlert
   */

  export type AggregateSecurityAlert = {
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  export type SecurityAlertMinAggregateOutputType = {
    id: string | null
    alertType: string | null
    severity: string | null
    badgeSerial: string | null
    memberId: string | null
    kioskId: string | null
    message: string | null
    status: string | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date | null
  }

  export type SecurityAlertMaxAggregateOutputType = {
    id: string | null
    alertType: string | null
    severity: string | null
    badgeSerial: string | null
    memberId: string | null
    kioskId: string | null
    message: string | null
    status: string | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date | null
  }

  export type SecurityAlertCountAggregateOutputType = {
    id: number
    alertType: number
    severity: number
    badgeSerial: number
    memberId: number
    kioskId: number
    message: number
    details: number
    status: number
    acknowledgedBy: number
    acknowledgedAt: number
    acknowledgeNote: number
    createdAt: number
    _all: number
  }


  export type SecurityAlertMinAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
  }

  export type SecurityAlertMaxAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
  }

  export type SecurityAlertCountAggregateInputType = {
    id?: true
    alertType?: true
    severity?: true
    badgeSerial?: true
    memberId?: true
    kioskId?: true
    message?: true
    details?: true
    status?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    acknowledgeNote?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlert to aggregate.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityAlerts
    **/
    _count?: true | SecurityAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type GetSecurityAlertAggregateType<T extends SecurityAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityAlert[P]>
      : GetScalarType<T[P], AggregateSecurityAlert[P]>
  }




  export type SecurityAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithAggregationInput | SecurityAlertOrderByWithAggregationInput[]
    by: SecurityAlertScalarFieldEnum[] | SecurityAlertScalarFieldEnum
    having?: SecurityAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityAlertCountAggregateInputType | true
    _min?: SecurityAlertMinAggregateInputType
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type SecurityAlertGroupByOutputType = {
    id: string
    alertType: string
    severity: string
    badgeSerial: string | null
    memberId: string | null
    kioskId: string
    message: string
    details: JsonValue | null
    status: string
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    acknowledgeNote: string | null
    createdAt: Date
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  type GetSecurityAlertGroupByPayload<T extends SecurityAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
        }
      >
    >


  export type SecurityAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectScalar = {
    id?: boolean
    alertType?: boolean
    severity?: boolean
    badgeSerial?: boolean
    memberId?: boolean
    kioskId?: boolean
    message?: boolean
    details?: boolean
    status?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    acknowledgeNote?: boolean
    createdAt?: boolean
  }

  export type SecurityAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alertType" | "severity" | "badgeSerial" | "memberId" | "kioskId" | "message" | "details" | "status" | "acknowledgedBy" | "acknowledgedAt" | "acknowledgeNote" | "createdAt", ExtArgs["result"]["securityAlert"]>
  export type SecurityAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }
  export type SecurityAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }
  export type SecurityAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgedByAdmin?: boolean | SecurityAlert$acknowledgedByAdminArgs<ExtArgs>
  }

  export type $SecurityAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityAlert"
    objects: {
      acknowledgedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertType: string
      severity: string
      badgeSerial: string | null
      memberId: string | null
      kioskId: string
      message: string
      details: Prisma.JsonValue | null
      status: string
      acknowledgedBy: string | null
      acknowledgedAt: Date | null
      acknowledgeNote: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityAlert"]>
    composites: {}
  }

  type SecurityAlertGetPayload<S extends boolean | null | undefined | SecurityAlertDefaultArgs> = $Result.GetResult<Prisma.$SecurityAlertPayload, S>

  type SecurityAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityAlertCountAggregateInputType | true
    }

  export interface SecurityAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityAlert'], meta: { name: 'SecurityAlert' } }
    /**
     * Find zero or one SecurityAlert that matches the filter.
     * @param {SecurityAlertFindUniqueArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityAlertFindUniqueArgs>(args: SelectSubset<T, SecurityAlertFindUniqueArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityAlertFindUniqueOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityAlertFindFirstArgs>(args?: SelectSubset<T, SecurityAlertFindFirstArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany()
     * 
     * // Get first 10 SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityAlertFindManyArgs>(args?: SelectSubset<T, SecurityAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityAlert.
     * @param {SecurityAlertCreateArgs} args - Arguments to create a SecurityAlert.
     * @example
     * // Create one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.create({
     *   data: {
     *     // ... data to create a SecurityAlert
     *   }
     * })
     * 
     */
    create<T extends SecurityAlertCreateArgs>(args: SelectSubset<T, SecurityAlertCreateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityAlerts.
     * @param {SecurityAlertCreateManyArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityAlertCreateManyArgs>(args?: SelectSubset<T, SecurityAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityAlerts and returns the data saved in the database.
     * @param {SecurityAlertCreateManyAndReturnArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityAlert.
     * @param {SecurityAlertDeleteArgs} args - Arguments to delete one SecurityAlert.
     * @example
     * // Delete one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.delete({
     *   where: {
     *     // ... filter to delete one SecurityAlert
     *   }
     * })
     * 
     */
    delete<T extends SecurityAlertDeleteArgs>(args: SelectSubset<T, SecurityAlertDeleteArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityAlert.
     * @param {SecurityAlertUpdateArgs} args - Arguments to update one SecurityAlert.
     * @example
     * // Update one SecurityAlert
     * const securityAlert = await prisma.securityAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityAlertUpdateArgs>(args: SelectSubset<T, SecurityAlertUpdateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityAlerts.
     * @param {SecurityAlertDeleteManyArgs} args - Arguments to filter SecurityAlerts to delete.
     * @example
     * // Delete a few SecurityAlerts
     * const { count } = await prisma.securityAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityAlertDeleteManyArgs>(args?: SelectSubset<T, SecurityAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityAlertUpdateManyArgs>(args: SelectSubset<T, SecurityAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts and returns the data updated in the database.
     * @param {SecurityAlertUpdateManyAndReturnArgs} args - Arguments to update many SecurityAlerts.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityAlert.
     * @param {SecurityAlertUpsertArgs} args - Arguments to update or create a SecurityAlert.
     * @example
     * // Update or create a SecurityAlert
     * const securityAlert = await prisma.securityAlert.upsert({
     *   create: {
     *     // ... data to create a SecurityAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityAlert we want to update
     *   }
     * })
     */
    upsert<T extends SecurityAlertUpsertArgs>(args: SelectSubset<T, SecurityAlertUpsertArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertCountArgs} args - Arguments to filter SecurityAlerts to count.
     * @example
     * // Count the number of SecurityAlerts
     * const count = await prisma.securityAlert.count({
     *   where: {
     *     // ... the filter for the SecurityAlerts we want to count
     *   }
     * })
    **/
    count<T extends SecurityAlertCountArgs>(
      args?: Subset<T, SecurityAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityAlertAggregateArgs>(args: Subset<T, SecurityAlertAggregateArgs>): Prisma.PrismaPromise<GetSecurityAlertAggregateType<T>>

    /**
     * Group by SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityAlertGroupByArgs['orderBy'] }
        : { orderBy?: SecurityAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityAlert model
   */
  readonly fields: SecurityAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acknowledgedByAdmin<T extends SecurityAlert$acknowledgedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, SecurityAlert$acknowledgedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityAlert model
   */
  interface SecurityAlertFieldRefs {
    readonly id: FieldRef<"SecurityAlert", 'String'>
    readonly alertType: FieldRef<"SecurityAlert", 'String'>
    readonly severity: FieldRef<"SecurityAlert", 'String'>
    readonly badgeSerial: FieldRef<"SecurityAlert", 'String'>
    readonly memberId: FieldRef<"SecurityAlert", 'String'>
    readonly kioskId: FieldRef<"SecurityAlert", 'String'>
    readonly message: FieldRef<"SecurityAlert", 'String'>
    readonly details: FieldRef<"SecurityAlert", 'Json'>
    readonly status: FieldRef<"SecurityAlert", 'String'>
    readonly acknowledgedBy: FieldRef<"SecurityAlert", 'String'>
    readonly acknowledgedAt: FieldRef<"SecurityAlert", 'DateTime'>
    readonly acknowledgeNote: FieldRef<"SecurityAlert", 'String'>
    readonly createdAt: FieldRef<"SecurityAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityAlert findUnique
   */
  export type SecurityAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert findUniqueOrThrow
   */
  export type SecurityAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert findFirst
   */
  export type SecurityAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert findFirstOrThrow
   */
  export type SecurityAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert findMany
   */
  export type SecurityAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlerts to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert create
   */
  export type SecurityAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityAlert.
     */
    data: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
  }

  /**
   * SecurityAlert createMany
   */
  export type SecurityAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAlert createManyAndReturn
   */
  export type SecurityAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert update
   */
  export type SecurityAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityAlert.
     */
    data: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
    /**
     * Choose, which SecurityAlert to update.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert updateMany
   */
  export type SecurityAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
  }

  /**
   * SecurityAlert updateManyAndReturn
   */
  export type SecurityAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert upsert
   */
  export type SecurityAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityAlert to update in case it exists.
     */
    where: SecurityAlertWhereUniqueInput
    /**
     * In case the SecurityAlert found by the `where` argument doesn't exist, create a new SecurityAlert with this data.
     */
    create: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
    /**
     * In case the SecurityAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
  }

  /**
   * SecurityAlert delete
   */
  export type SecurityAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter which SecurityAlert to delete.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert deleteMany
   */
  export type SecurityAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlerts to delete
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to delete.
     */
    limit?: number
  }

  /**
   * SecurityAlert.acknowledgedByAdmin
   */
  export type SecurityAlert$acknowledgedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * SecurityAlert without action
   */
  export type SecurityAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorMinAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    visitType: string | null
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string | null
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    visitType: string | null
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string | null
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    name: number
    organization: number
    visitType: number
    visitTypeId: number
    visitReason: number
    eventId: number
    hostMemberId: number
    checkInTime: number
    checkOutTime: number
    temporaryBadgeId: number
    kioskId: number
    createdAt: number
    adminNotes: number
    checkInMethod: number
    createdByAdmin: number
    _all: number
  }


  export type VisitorMinAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    visitType?: true
    visitTypeId?: true
    visitReason?: true
    eventId?: true
    hostMemberId?: true
    checkInTime?: true
    checkOutTime?: true
    temporaryBadgeId?: true
    kioskId?: true
    createdAt?: true
    adminNotes?: true
    checkInMethod?: true
    createdByAdmin?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: string
    name: string
    organization: string | null
    visitType: string
    visitTypeId: string | null
    visitReason: string | null
    eventId: string | null
    hostMemberId: string | null
    checkInTime: Date
    checkOutTime: Date | null
    temporaryBadgeId: string | null
    kioskId: string
    createdAt: Date | null
    adminNotes: string | null
    checkInMethod: string | null
    createdByAdmin: string | null
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectScalar = {
    id?: boolean
    name?: boolean
    organization?: boolean
    visitType?: boolean
    visitTypeId?: boolean
    visitReason?: boolean
    eventId?: boolean
    hostMemberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    temporaryBadgeId?: boolean
    kioskId?: boolean
    createdAt?: boolean
    adminNotes?: boolean
    checkInMethod?: boolean
    createdByAdmin?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organization" | "visitType" | "visitTypeId" | "visitReason" | "eventId" | "hostMemberId" | "checkInTime" | "checkOutTime" | "temporaryBadgeId" | "kioskId" | "createdAt" | "adminNotes" | "checkInMethod" | "createdByAdmin", ExtArgs["result"]["visitor"]>
  export type VisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }
  export type VisitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }
  export type VisitorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | Visitor$admin_usersArgs<ExtArgs>
    event?: boolean | Visitor$eventArgs<ExtArgs>
    hostMember?: boolean | Visitor$hostMemberArgs<ExtArgs>
    badge?: boolean | Visitor$badgeArgs<ExtArgs>
    visitTypeRef?: boolean | Visitor$visitTypeRefArgs<ExtArgs>
  }

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs> | null
      hostMember: Prisma.$MemberPayload<ExtArgs> | null
      badge: Prisma.$BadgePayload<ExtArgs> | null
      visitTypeRef: Prisma.$VisitTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      organization: string | null
      visitType: string
      visitTypeId: string | null
      visitReason: string | null
      eventId: string | null
      hostMemberId: string | null
      checkInTime: Date
      checkOutTime: Date | null
      temporaryBadgeId: string | null
      kioskId: string
      createdAt: Date | null
      adminNotes: string | null
      checkInMethod: string | null
      createdByAdmin: string | null
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visitors and returns the data saved in the database.
     * @param {VisitorCreateManyAndReturnArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visitors and only return the `id`
     * const visitorWithIdOnly = await prisma.visitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors and returns the data updated in the database.
     * @param {VisitorUpdateManyAndReturnArgs} args - Arguments to update many Visitors.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visitors and only return the `id`
     * const visitorWithIdOnly = await prisma.visitor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitorUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_users<T extends Visitor$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends Visitor$eventArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$eventArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hostMember<T extends Visitor$hostMemberArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$hostMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    badge<T extends Visitor$badgeArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$badgeArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitTypeRef<T extends Visitor$visitTypeRefArgs<ExtArgs> = {}>(args?: Subset<T, Visitor$visitTypeRefArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'String'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly organization: FieldRef<"Visitor", 'String'>
    readonly visitType: FieldRef<"Visitor", 'String'>
    readonly visitTypeId: FieldRef<"Visitor", 'String'>
    readonly visitReason: FieldRef<"Visitor", 'String'>
    readonly eventId: FieldRef<"Visitor", 'String'>
    readonly hostMemberId: FieldRef<"Visitor", 'String'>
    readonly checkInTime: FieldRef<"Visitor", 'DateTime'>
    readonly checkOutTime: FieldRef<"Visitor", 'DateTime'>
    readonly temporaryBadgeId: FieldRef<"Visitor", 'String'>
    readonly kioskId: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly adminNotes: FieldRef<"Visitor", 'String'>
    readonly checkInMethod: FieldRef<"Visitor", 'String'>
    readonly createdByAdmin: FieldRef<"Visitor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor createManyAndReturn
   */
  export type VisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor updateManyAndReturn
   */
  export type VisitorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor.admin_users
   */
  export type Visitor$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * Visitor.event
   */
  export type Visitor$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
  }

  /**
   * Visitor.hostMember
   */
  export type Visitor$hostMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Visitor.badge
   */
  export type Visitor$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
  }

  /**
   * Visitor.visitTypeRef
   */
  export type Visitor$visitTypeRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    where?: VisitTypeWhereInput
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
  }


  /**
   * Model BmqCourse
   */

  export type AggregateBmqCourse = {
    _count: BmqCourseCountAggregateOutputType | null
    _min: BmqCourseMinAggregateOutputType | null
    _max: BmqCourseMaxAggregateOutputType | null
  }

  export type BmqCourseMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    trainingStartTime: Date | null
    trainingEndTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BmqCourseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    trainingStartTime: Date | null
    trainingEndTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BmqCourseCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    trainingStartTime: number
    trainingEndTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    trainingDays: number
    _all: number
  }


  export type BmqCourseMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BmqCourseMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BmqCourseCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    trainingStartTime?: true
    trainingEndTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    trainingDays?: true
    _all?: true
  }

  export type BmqCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqCourse to aggregate.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmqCourses
    **/
    _count?: true | BmqCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmqCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmqCourseMaxAggregateInputType
  }

  export type GetBmqCourseAggregateType<T extends BmqCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateBmqCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmqCourse[P]>
      : GetScalarType<T[P], AggregateBmqCourse[P]>
  }




  export type BmqCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqCourseWhereInput
    orderBy?: BmqCourseOrderByWithAggregationInput | BmqCourseOrderByWithAggregationInput[]
    by: BmqCourseScalarFieldEnum[] | BmqCourseScalarFieldEnum
    having?: BmqCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmqCourseCountAggregateInputType | true
    _min?: BmqCourseMinAggregateInputType
    _max?: BmqCourseMaxAggregateInputType
  }

  export type BmqCourseGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    trainingStartTime: Date
    trainingEndTime: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    trainingDays: string[]
    _count: BmqCourseCountAggregateOutputType | null
    _min: BmqCourseMinAggregateOutputType | null
    _max: BmqCourseMaxAggregateOutputType | null
  }

  type GetBmqCourseGroupByPayload<T extends BmqCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmqCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmqCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmqCourseGroupByOutputType[P]>
            : GetScalarType<T[P], BmqCourseGroupByOutputType[P]>
        }
      >
    >


  export type BmqCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
    bmqEnrollments?: boolean | BmqCourse$bmqEnrollmentsArgs<ExtArgs>
    _count?: boolean | BmqCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }, ExtArgs["result"]["bmqCourse"]>

  export type BmqCourseSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingStartTime?: boolean
    trainingEndTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingDays?: boolean
  }

  export type BmqCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "trainingStartTime" | "trainingEndTime" | "isActive" | "createdAt" | "updatedAt" | "trainingDays", ExtArgs["result"]["bmqCourse"]>
  export type BmqCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqEnrollments?: boolean | BmqCourse$bmqEnrollmentsArgs<ExtArgs>
    _count?: boolean | BmqCourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BmqCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BmqCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BmqCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmqCourse"
    objects: {
      bmqEnrollments: Prisma.$BmqEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      trainingStartTime: Date
      trainingEndTime: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      trainingDays: string[]
    }, ExtArgs["result"]["bmqCourse"]>
    composites: {}
  }

  type BmqCourseGetPayload<S extends boolean | null | undefined | BmqCourseDefaultArgs> = $Result.GetResult<Prisma.$BmqCoursePayload, S>

  type BmqCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmqCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmqCourseCountAggregateInputType | true
    }

  export interface BmqCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmqCourse'], meta: { name: 'BmqCourse' } }
    /**
     * Find zero or one BmqCourse that matches the filter.
     * @param {BmqCourseFindUniqueArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmqCourseFindUniqueArgs>(args: SelectSubset<T, BmqCourseFindUniqueArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BmqCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmqCourseFindUniqueOrThrowArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmqCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, BmqCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindFirstArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmqCourseFindFirstArgs>(args?: SelectSubset<T, BmqCourseFindFirstArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindFirstOrThrowArgs} args - Arguments to find a BmqCourse
     * @example
     * // Get one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmqCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, BmqCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BmqCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmqCourses
     * const bmqCourses = await prisma.bmqCourse.findMany()
     * 
     * // Get first 10 BmqCourses
     * const bmqCourses = await prisma.bmqCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BmqCourseFindManyArgs>(args?: SelectSubset<T, BmqCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BmqCourse.
     * @param {BmqCourseCreateArgs} args - Arguments to create a BmqCourse.
     * @example
     * // Create one BmqCourse
     * const BmqCourse = await prisma.bmqCourse.create({
     *   data: {
     *     // ... data to create a BmqCourse
     *   }
     * })
     * 
     */
    create<T extends BmqCourseCreateArgs>(args: SelectSubset<T, BmqCourseCreateArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BmqCourses.
     * @param {BmqCourseCreateManyArgs} args - Arguments to create many BmqCourses.
     * @example
     * // Create many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmqCourseCreateManyArgs>(args?: SelectSubset<T, BmqCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BmqCourses and returns the data saved in the database.
     * @param {BmqCourseCreateManyAndReturnArgs} args - Arguments to create many BmqCourses.
     * @example
     * // Create many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BmqCourses and only return the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BmqCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, BmqCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BmqCourse.
     * @param {BmqCourseDeleteArgs} args - Arguments to delete one BmqCourse.
     * @example
     * // Delete one BmqCourse
     * const BmqCourse = await prisma.bmqCourse.delete({
     *   where: {
     *     // ... filter to delete one BmqCourse
     *   }
     * })
     * 
     */
    delete<T extends BmqCourseDeleteArgs>(args: SelectSubset<T, BmqCourseDeleteArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BmqCourse.
     * @param {BmqCourseUpdateArgs} args - Arguments to update one BmqCourse.
     * @example
     * // Update one BmqCourse
     * const bmqCourse = await prisma.bmqCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmqCourseUpdateArgs>(args: SelectSubset<T, BmqCourseUpdateArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BmqCourses.
     * @param {BmqCourseDeleteManyArgs} args - Arguments to filter BmqCourses to delete.
     * @example
     * // Delete a few BmqCourses
     * const { count } = await prisma.bmqCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmqCourseDeleteManyArgs>(args?: SelectSubset<T, BmqCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmqCourseUpdateManyArgs>(args: SelectSubset<T, BmqCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqCourses and returns the data updated in the database.
     * @param {BmqCourseUpdateManyAndReturnArgs} args - Arguments to update many BmqCourses.
     * @example
     * // Update many BmqCourses
     * const bmqCourse = await prisma.bmqCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BmqCourses and only return the `id`
     * const bmqCourseWithIdOnly = await prisma.bmqCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BmqCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, BmqCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BmqCourse.
     * @param {BmqCourseUpsertArgs} args - Arguments to update or create a BmqCourse.
     * @example
     * // Update or create a BmqCourse
     * const bmqCourse = await prisma.bmqCourse.upsert({
     *   create: {
     *     // ... data to create a BmqCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmqCourse we want to update
     *   }
     * })
     */
    upsert<T extends BmqCourseUpsertArgs>(args: SelectSubset<T, BmqCourseUpsertArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BmqCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseCountArgs} args - Arguments to filter BmqCourses to count.
     * @example
     * // Count the number of BmqCourses
     * const count = await prisma.bmqCourse.count({
     *   where: {
     *     // ... the filter for the BmqCourses we want to count
     *   }
     * })
    **/
    count<T extends BmqCourseCountArgs>(
      args?: Subset<T, BmqCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmqCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmqCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmqCourseAggregateArgs>(args: Subset<T, BmqCourseAggregateArgs>): Prisma.PrismaPromise<GetBmqCourseAggregateType<T>>

    /**
     * Group by BmqCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmqCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmqCourseGroupByArgs['orderBy'] }
        : { orderBy?: BmqCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmqCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmqCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmqCourse model
   */
  readonly fields: BmqCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmqCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmqCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bmqEnrollments<T extends BmqCourse$bmqEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, BmqCourse$bmqEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmqCourse model
   */
  interface BmqCourseFieldRefs {
    readonly id: FieldRef<"BmqCourse", 'String'>
    readonly name: FieldRef<"BmqCourse", 'String'>
    readonly startDate: FieldRef<"BmqCourse", 'DateTime'>
    readonly endDate: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingStartTime: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingEndTime: FieldRef<"BmqCourse", 'DateTime'>
    readonly isActive: FieldRef<"BmqCourse", 'Boolean'>
    readonly createdAt: FieldRef<"BmqCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"BmqCourse", 'DateTime'>
    readonly trainingDays: FieldRef<"BmqCourse", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * BmqCourse findUnique
   */
  export type BmqCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where: BmqCourseWhereUniqueInput
  }

  /**
   * BmqCourse findUniqueOrThrow
   */
  export type BmqCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where: BmqCourseWhereUniqueInput
  }

  /**
   * BmqCourse findFirst
   */
  export type BmqCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqCourses.
     */
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
  }

  /**
   * BmqCourse findFirstOrThrow
   */
  export type BmqCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourse to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqCourses.
     */
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
  }

  /**
   * BmqCourse findMany
   */
  export type BmqCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter, which BmqCourses to fetch.
     */
    where?: BmqCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqCourses to fetch.
     */
    orderBy?: BmqCourseOrderByWithRelationInput | BmqCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmqCourses.
     */
    cursor?: BmqCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqCourses.
     */
    skip?: number
    distinct?: BmqCourseScalarFieldEnum | BmqCourseScalarFieldEnum[]
  }

  /**
   * BmqCourse create
   */
  export type BmqCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a BmqCourse.
     */
    data: XOR<BmqCourseCreateInput, BmqCourseUncheckedCreateInput>
  }

  /**
   * BmqCourse createMany
   */
  export type BmqCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmqCourses.
     */
    data: BmqCourseCreateManyInput | BmqCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqCourse createManyAndReturn
   */
  export type BmqCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * The data used to create many BmqCourses.
     */
    data: BmqCourseCreateManyInput | BmqCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqCourse update
   */
  export type BmqCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a BmqCourse.
     */
    data: XOR<BmqCourseUpdateInput, BmqCourseUncheckedUpdateInput>
    /**
     * Choose, which BmqCourse to update.
     */
    where: BmqCourseWhereUniqueInput
  }

  /**
   * BmqCourse updateMany
   */
  export type BmqCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmqCourses.
     */
    data: XOR<BmqCourseUpdateManyMutationInput, BmqCourseUncheckedUpdateManyInput>
    /**
     * Filter which BmqCourses to update
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to update.
     */
    limit?: number
  }

  /**
   * BmqCourse updateManyAndReturn
   */
  export type BmqCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * The data used to update BmqCourses.
     */
    data: XOR<BmqCourseUpdateManyMutationInput, BmqCourseUncheckedUpdateManyInput>
    /**
     * Filter which BmqCourses to update
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to update.
     */
    limit?: number
  }

  /**
   * BmqCourse upsert
   */
  export type BmqCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the BmqCourse to update in case it exists.
     */
    where: BmqCourseWhereUniqueInput
    /**
     * In case the BmqCourse found by the `where` argument doesn't exist, create a new BmqCourse with this data.
     */
    create: XOR<BmqCourseCreateInput, BmqCourseUncheckedCreateInput>
    /**
     * In case the BmqCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmqCourseUpdateInput, BmqCourseUncheckedUpdateInput>
  }

  /**
   * BmqCourse delete
   */
  export type BmqCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
    /**
     * Filter which BmqCourse to delete.
     */
    where: BmqCourseWhereUniqueInput
  }

  /**
   * BmqCourse deleteMany
   */
  export type BmqCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqCourses to delete
     */
    where?: BmqCourseWhereInput
    /**
     * Limit how many BmqCourses to delete.
     */
    limit?: number
  }

  /**
   * BmqCourse.bmqEnrollments
   */
  export type BmqCourse$bmqEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    cursor?: BmqEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * BmqCourse without action
   */
  export type BmqCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqCourse
     */
    select?: BmqCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqCourse
     */
    omit?: BmqCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqCourseInclude<ExtArgs> | null
  }


  /**
   * Model BmqEnrollment
   */

  export type AggregateBmqEnrollment = {
    _count: BmqEnrollmentCountAggregateOutputType | null
    _min: BmqEnrollmentMinAggregateOutputType | null
    _max: BmqEnrollmentMaxAggregateOutputType | null
  }

  export type BmqEnrollmentMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    bmqCourseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
  }

  export type BmqEnrollmentMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    bmqCourseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
  }

  export type BmqEnrollmentCountAggregateOutputType = {
    id: number
    memberId: number
    bmqCourseId: number
    enrolledAt: number
    completedAt: number
    status: number
    _all: number
  }


  export type BmqEnrollmentMinAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
  }

  export type BmqEnrollmentMaxAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
  }

  export type BmqEnrollmentCountAggregateInputType = {
    id?: true
    memberId?: true
    bmqCourseId?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
    _all?: true
  }

  export type BmqEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqEnrollment to aggregate.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmqEnrollments
    **/
    _count?: true | BmqEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmqEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmqEnrollmentMaxAggregateInputType
  }

  export type GetBmqEnrollmentAggregateType<T extends BmqEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBmqEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmqEnrollment[P]>
      : GetScalarType<T[P], AggregateBmqEnrollment[P]>
  }




  export type BmqEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmqEnrollmentWhereInput
    orderBy?: BmqEnrollmentOrderByWithAggregationInput | BmqEnrollmentOrderByWithAggregationInput[]
    by: BmqEnrollmentScalarFieldEnum[] | BmqEnrollmentScalarFieldEnum
    having?: BmqEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmqEnrollmentCountAggregateInputType | true
    _min?: BmqEnrollmentMinAggregateInputType
    _max?: BmqEnrollmentMaxAggregateInputType
  }

  export type BmqEnrollmentGroupByOutputType = {
    id: string
    memberId: string
    bmqCourseId: string
    enrolledAt: Date
    completedAt: Date | null
    status: string
    _count: BmqEnrollmentCountAggregateOutputType | null
    _min: BmqEnrollmentMinAggregateOutputType | null
    _max: BmqEnrollmentMaxAggregateOutputType | null
  }

  type GetBmqEnrollmentGroupByPayload<T extends BmqEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmqEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmqEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmqEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], BmqEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type BmqEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmqEnrollment"]>

  export type BmqEnrollmentSelectScalar = {
    id?: boolean
    memberId?: boolean
    bmqCourseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
  }

  export type BmqEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "bmqCourseId" | "enrolledAt" | "completedAt" | "status", ExtArgs["result"]["bmqEnrollment"]>
  export type BmqEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BmqEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BmqEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bmqCourse?: boolean | BmqCourseDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $BmqEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmqEnrollment"
    objects: {
      bmqCourse: Prisma.$BmqCoursePayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      bmqCourseId: string
      enrolledAt: Date
      completedAt: Date | null
      status: string
    }, ExtArgs["result"]["bmqEnrollment"]>
    composites: {}
  }

  type BmqEnrollmentGetPayload<S extends boolean | null | undefined | BmqEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$BmqEnrollmentPayload, S>

  type BmqEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmqEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmqEnrollmentCountAggregateInputType | true
    }

  export interface BmqEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmqEnrollment'], meta: { name: 'BmqEnrollment' } }
    /**
     * Find zero or one BmqEnrollment that matches the filter.
     * @param {BmqEnrollmentFindUniqueArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmqEnrollmentFindUniqueArgs>(args: SelectSubset<T, BmqEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BmqEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmqEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmqEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindFirstArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmqEnrollmentFindFirstArgs>(args?: SelectSubset<T, BmqEnrollmentFindFirstArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BmqEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindFirstOrThrowArgs} args - Arguments to find a BmqEnrollment
     * @example
     * // Get one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmqEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, BmqEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BmqEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmqEnrollments
     * const bmqEnrollments = await prisma.bmqEnrollment.findMany()
     * 
     * // Get first 10 BmqEnrollments
     * const bmqEnrollments = await prisma.bmqEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BmqEnrollmentFindManyArgs>(args?: SelectSubset<T, BmqEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BmqEnrollment.
     * @param {BmqEnrollmentCreateArgs} args - Arguments to create a BmqEnrollment.
     * @example
     * // Create one BmqEnrollment
     * const BmqEnrollment = await prisma.bmqEnrollment.create({
     *   data: {
     *     // ... data to create a BmqEnrollment
     *   }
     * })
     * 
     */
    create<T extends BmqEnrollmentCreateArgs>(args: SelectSubset<T, BmqEnrollmentCreateArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BmqEnrollments.
     * @param {BmqEnrollmentCreateManyArgs} args - Arguments to create many BmqEnrollments.
     * @example
     * // Create many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmqEnrollmentCreateManyArgs>(args?: SelectSubset<T, BmqEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BmqEnrollments and returns the data saved in the database.
     * @param {BmqEnrollmentCreateManyAndReturnArgs} args - Arguments to create many BmqEnrollments.
     * @example
     * // Create many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BmqEnrollments and only return the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BmqEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, BmqEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BmqEnrollment.
     * @param {BmqEnrollmentDeleteArgs} args - Arguments to delete one BmqEnrollment.
     * @example
     * // Delete one BmqEnrollment
     * const BmqEnrollment = await prisma.bmqEnrollment.delete({
     *   where: {
     *     // ... filter to delete one BmqEnrollment
     *   }
     * })
     * 
     */
    delete<T extends BmqEnrollmentDeleteArgs>(args: SelectSubset<T, BmqEnrollmentDeleteArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BmqEnrollment.
     * @param {BmqEnrollmentUpdateArgs} args - Arguments to update one BmqEnrollment.
     * @example
     * // Update one BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmqEnrollmentUpdateArgs>(args: SelectSubset<T, BmqEnrollmentUpdateArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BmqEnrollments.
     * @param {BmqEnrollmentDeleteManyArgs} args - Arguments to filter BmqEnrollments to delete.
     * @example
     * // Delete a few BmqEnrollments
     * const { count } = await prisma.bmqEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmqEnrollmentDeleteManyArgs>(args?: SelectSubset<T, BmqEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmqEnrollmentUpdateManyArgs>(args: SelectSubset<T, BmqEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmqEnrollments and returns the data updated in the database.
     * @param {BmqEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many BmqEnrollments.
     * @example
     * // Update many BmqEnrollments
     * const bmqEnrollment = await prisma.bmqEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BmqEnrollments and only return the `id`
     * const bmqEnrollmentWithIdOnly = await prisma.bmqEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BmqEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BmqEnrollment.
     * @param {BmqEnrollmentUpsertArgs} args - Arguments to update or create a BmqEnrollment.
     * @example
     * // Update or create a BmqEnrollment
     * const bmqEnrollment = await prisma.bmqEnrollment.upsert({
     *   create: {
     *     // ... data to create a BmqEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmqEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends BmqEnrollmentUpsertArgs>(args: SelectSubset<T, BmqEnrollmentUpsertArgs<ExtArgs>>): Prisma__BmqEnrollmentClient<$Result.GetResult<Prisma.$BmqEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BmqEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentCountArgs} args - Arguments to filter BmqEnrollments to count.
     * @example
     * // Count the number of BmqEnrollments
     * const count = await prisma.bmqEnrollment.count({
     *   where: {
     *     // ... the filter for the BmqEnrollments we want to count
     *   }
     * })
    **/
    count<T extends BmqEnrollmentCountArgs>(
      args?: Subset<T, BmqEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmqEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmqEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmqEnrollmentAggregateArgs>(args: Subset<T, BmqEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetBmqEnrollmentAggregateType<T>>

    /**
     * Group by BmqEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmqEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmqEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmqEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: BmqEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmqEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmqEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmqEnrollment model
   */
  readonly fields: BmqEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmqEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmqEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bmqCourse<T extends BmqCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmqCourseDefaultArgs<ExtArgs>>): Prisma__BmqCourseClient<$Result.GetResult<Prisma.$BmqCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmqEnrollment model
   */
  interface BmqEnrollmentFieldRefs {
    readonly id: FieldRef<"BmqEnrollment", 'String'>
    readonly memberId: FieldRef<"BmqEnrollment", 'String'>
    readonly bmqCourseId: FieldRef<"BmqEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"BmqEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"BmqEnrollment", 'DateTime'>
    readonly status: FieldRef<"BmqEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmqEnrollment findUnique
   */
  export type BmqEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where: BmqEnrollmentWhereUniqueInput
  }

  /**
   * BmqEnrollment findUniqueOrThrow
   */
  export type BmqEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where: BmqEnrollmentWhereUniqueInput
  }

  /**
   * BmqEnrollment findFirst
   */
  export type BmqEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqEnrollments.
     */
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * BmqEnrollment findFirstOrThrow
   */
  export type BmqEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollment to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmqEnrollments.
     */
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * BmqEnrollment findMany
   */
  export type BmqEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which BmqEnrollments to fetch.
     */
    where?: BmqEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmqEnrollments to fetch.
     */
    orderBy?: BmqEnrollmentOrderByWithRelationInput | BmqEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmqEnrollments.
     */
    cursor?: BmqEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmqEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmqEnrollments.
     */
    skip?: number
    distinct?: BmqEnrollmentScalarFieldEnum | BmqEnrollmentScalarFieldEnum[]
  }

  /**
   * BmqEnrollment create
   */
  export type BmqEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a BmqEnrollment.
     */
    data: XOR<BmqEnrollmentCreateInput, BmqEnrollmentUncheckedCreateInput>
  }

  /**
   * BmqEnrollment createMany
   */
  export type BmqEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmqEnrollments.
     */
    data: BmqEnrollmentCreateManyInput | BmqEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BmqEnrollment createManyAndReturn
   */
  export type BmqEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many BmqEnrollments.
     */
    data: BmqEnrollmentCreateManyInput | BmqEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BmqEnrollment update
   */
  export type BmqEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a BmqEnrollment.
     */
    data: XOR<BmqEnrollmentUpdateInput, BmqEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which BmqEnrollment to update.
     */
    where: BmqEnrollmentWhereUniqueInput
  }

  /**
   * BmqEnrollment updateMany
   */
  export type BmqEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmqEnrollments.
     */
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which BmqEnrollments to update
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to update.
     */
    limit?: number
  }

  /**
   * BmqEnrollment updateManyAndReturn
   */
  export type BmqEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update BmqEnrollments.
     */
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which BmqEnrollments to update
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BmqEnrollment upsert
   */
  export type BmqEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the BmqEnrollment to update in case it exists.
     */
    where: BmqEnrollmentWhereUniqueInput
    /**
     * In case the BmqEnrollment found by the `where` argument doesn't exist, create a new BmqEnrollment with this data.
     */
    create: XOR<BmqEnrollmentCreateInput, BmqEnrollmentUncheckedCreateInput>
    /**
     * In case the BmqEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmqEnrollmentUpdateInput, BmqEnrollmentUncheckedUpdateInput>
  }

  /**
   * BmqEnrollment delete
   */
  export type BmqEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which BmqEnrollment to delete.
     */
    where: BmqEnrollmentWhereUniqueInput
  }

  /**
   * BmqEnrollment deleteMany
   */
  export type BmqEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmqEnrollments to delete
     */
    where?: BmqEnrollmentWhereInput
    /**
     * Limit how many BmqEnrollments to delete.
     */
    limit?: number
  }

  /**
   * BmqEnrollment without action
   */
  export type BmqEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmqEnrollment
     */
    select?: BmqEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmqEnrollment
     */
    omit?: BmqEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmqEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    name: number
    applied_at: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    name: string
    applied_at: Date | null
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "applied_at", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      applied_at: Date | null
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly name: FieldRef<"migrations", 'String'>
    readonly applied_at: FieldRef<"migrations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model report_audit_log
   */

  export type AggregateReport_audit_log = {
    _count: Report_audit_logCountAggregateOutputType | null
    _avg: Report_audit_logAvgAggregateOutputType | null
    _sum: Report_audit_logSumAggregateOutputType | null
    _min: Report_audit_logMinAggregateOutputType | null
    _max: Report_audit_logMaxAggregateOutputType | null
  }

  export type Report_audit_logAvgAggregateOutputType = {
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logSumAggregateOutputType = {
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logMinAggregateOutputType = {
    id: string | null
    report_type: string | null
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logMaxAggregateOutputType = {
    id: string | null
    report_type: string | null
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
  }

  export type Report_audit_logCountAggregateOutputType = {
    id: number
    report_type: number
    report_config: number
    generated_by: number
    is_scheduled: number
    scheduled_report_id: number
    generated_at: number
    file_size_bytes: number
    generation_time_ms: number
    _all: number
  }


  export type Report_audit_logAvgAggregateInputType = {
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logSumAggregateInputType = {
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logMinAggregateInputType = {
    id?: true
    report_type?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logMaxAggregateInputType = {
    id?: true
    report_type?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
  }

  export type Report_audit_logCountAggregateInputType = {
    id?: true
    report_type?: true
    report_config?: true
    generated_by?: true
    is_scheduled?: true
    scheduled_report_id?: true
    generated_at?: true
    file_size_bytes?: true
    generation_time_ms?: true
    _all?: true
  }

  export type Report_audit_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_audit_log to aggregate.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned report_audit_logs
    **/
    _count?: true | Report_audit_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Report_audit_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Report_audit_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_audit_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_audit_logMaxAggregateInputType
  }

  export type GetReport_audit_logAggregateType<T extends Report_audit_logAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_audit_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_audit_log[P]>
      : GetScalarType<T[P], AggregateReport_audit_log[P]>
  }




  export type report_audit_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_audit_logWhereInput
    orderBy?: report_audit_logOrderByWithAggregationInput | report_audit_logOrderByWithAggregationInput[]
    by: Report_audit_logScalarFieldEnum[] | Report_audit_logScalarFieldEnum
    having?: report_audit_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_audit_logCountAggregateInputType | true
    _avg?: Report_audit_logAvgAggregateInputType
    _sum?: Report_audit_logSumAggregateInputType
    _min?: Report_audit_logMinAggregateInputType
    _max?: Report_audit_logMaxAggregateInputType
  }

  export type Report_audit_logGroupByOutputType = {
    id: string
    report_type: string
    report_config: JsonValue
    generated_by: string | null
    is_scheduled: boolean | null
    scheduled_report_id: string | null
    generated_at: Date | null
    file_size_bytes: number | null
    generation_time_ms: number | null
    _count: Report_audit_logCountAggregateOutputType | null
    _avg: Report_audit_logAvgAggregateOutputType | null
    _sum: Report_audit_logSumAggregateOutputType | null
    _min: Report_audit_logMinAggregateOutputType | null
    _max: Report_audit_logMaxAggregateOutputType | null
  }

  type GetReport_audit_logGroupByPayload<T extends report_audit_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Report_audit_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_audit_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_audit_logGroupByOutputType[P]>
            : GetScalarType<T[P], Report_audit_logGroupByOutputType[P]>
        }
      >
    >


  export type report_audit_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }, ExtArgs["result"]["report_audit_log"]>

  export type report_audit_logSelectScalar = {
    id?: boolean
    report_type?: boolean
    report_config?: boolean
    generated_by?: boolean
    is_scheduled?: boolean
    scheduled_report_id?: boolean
    generated_at?: boolean
    file_size_bytes?: boolean
    generation_time_ms?: boolean
  }

  export type report_audit_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "report_type" | "report_config" | "generated_by" | "is_scheduled" | "scheduled_report_id" | "generated_at" | "file_size_bytes" | "generation_time_ms", ExtArgs["result"]["report_audit_log"]>
  export type report_audit_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }
  export type report_audit_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }
  export type report_audit_logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_users?: boolean | report_audit_log$admin_usersArgs<ExtArgs>
  }

  export type $report_audit_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report_audit_log"
    objects: {
      admin_users: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      report_type: string
      report_config: Prisma.JsonValue
      generated_by: string | null
      is_scheduled: boolean | null
      scheduled_report_id: string | null
      generated_at: Date | null
      file_size_bytes: number | null
      generation_time_ms: number | null
    }, ExtArgs["result"]["report_audit_log"]>
    composites: {}
  }

  type report_audit_logGetPayload<S extends boolean | null | undefined | report_audit_logDefaultArgs> = $Result.GetResult<Prisma.$report_audit_logPayload, S>

  type report_audit_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<report_audit_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Report_audit_logCountAggregateInputType | true
    }

  export interface report_audit_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report_audit_log'], meta: { name: 'report_audit_log' } }
    /**
     * Find zero or one Report_audit_log that matches the filter.
     * @param {report_audit_logFindUniqueArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends report_audit_logFindUniqueArgs>(args: SelectSubset<T, report_audit_logFindUniqueArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report_audit_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {report_audit_logFindUniqueOrThrowArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends report_audit_logFindUniqueOrThrowArgs>(args: SelectSubset<T, report_audit_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_audit_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindFirstArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends report_audit_logFindFirstArgs>(args?: SelectSubset<T, report_audit_logFindFirstArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_audit_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindFirstOrThrowArgs} args - Arguments to find a Report_audit_log
     * @example
     * // Get one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends report_audit_logFindFirstOrThrowArgs>(args?: SelectSubset<T, report_audit_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Report_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_audit_logs
     * const report_audit_logs = await prisma.report_audit_log.findMany()
     * 
     * // Get first 10 Report_audit_logs
     * const report_audit_logs = await prisma.report_audit_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends report_audit_logFindManyArgs>(args?: SelectSubset<T, report_audit_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report_audit_log.
     * @param {report_audit_logCreateArgs} args - Arguments to create a Report_audit_log.
     * @example
     * // Create one Report_audit_log
     * const Report_audit_log = await prisma.report_audit_log.create({
     *   data: {
     *     // ... data to create a Report_audit_log
     *   }
     * })
     * 
     */
    create<T extends report_audit_logCreateArgs>(args: SelectSubset<T, report_audit_logCreateArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Report_audit_logs.
     * @param {report_audit_logCreateManyArgs} args - Arguments to create many Report_audit_logs.
     * @example
     * // Create many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends report_audit_logCreateManyArgs>(args?: SelectSubset<T, report_audit_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Report_audit_logs and returns the data saved in the database.
     * @param {report_audit_logCreateManyAndReturnArgs} args - Arguments to create many Report_audit_logs.
     * @example
     * // Create many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Report_audit_logs and only return the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends report_audit_logCreateManyAndReturnArgs>(args?: SelectSubset<T, report_audit_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report_audit_log.
     * @param {report_audit_logDeleteArgs} args - Arguments to delete one Report_audit_log.
     * @example
     * // Delete one Report_audit_log
     * const Report_audit_log = await prisma.report_audit_log.delete({
     *   where: {
     *     // ... filter to delete one Report_audit_log
     *   }
     * })
     * 
     */
    delete<T extends report_audit_logDeleteArgs>(args: SelectSubset<T, report_audit_logDeleteArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report_audit_log.
     * @param {report_audit_logUpdateArgs} args - Arguments to update one Report_audit_log.
     * @example
     * // Update one Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends report_audit_logUpdateArgs>(args: SelectSubset<T, report_audit_logUpdateArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Report_audit_logs.
     * @param {report_audit_logDeleteManyArgs} args - Arguments to filter Report_audit_logs to delete.
     * @example
     * // Delete a few Report_audit_logs
     * const { count } = await prisma.report_audit_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends report_audit_logDeleteManyArgs>(args?: SelectSubset<T, report_audit_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends report_audit_logUpdateManyArgs>(args: SelectSubset<T, report_audit_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_audit_logs and returns the data updated in the database.
     * @param {report_audit_logUpdateManyAndReturnArgs} args - Arguments to update many Report_audit_logs.
     * @example
     * // Update many Report_audit_logs
     * const report_audit_log = await prisma.report_audit_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Report_audit_logs and only return the `id`
     * const report_audit_logWithIdOnly = await prisma.report_audit_log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends report_audit_logUpdateManyAndReturnArgs>(args: SelectSubset<T, report_audit_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report_audit_log.
     * @param {report_audit_logUpsertArgs} args - Arguments to update or create a Report_audit_log.
     * @example
     * // Update or create a Report_audit_log
     * const report_audit_log = await prisma.report_audit_log.upsert({
     *   create: {
     *     // ... data to create a Report_audit_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_audit_log we want to update
     *   }
     * })
     */
    upsert<T extends report_audit_logUpsertArgs>(args: SelectSubset<T, report_audit_logUpsertArgs<ExtArgs>>): Prisma__report_audit_logClient<$Result.GetResult<Prisma.$report_audit_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Report_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logCountArgs} args - Arguments to filter Report_audit_logs to count.
     * @example
     * // Count the number of Report_audit_logs
     * const count = await prisma.report_audit_log.count({
     *   where: {
     *     // ... the filter for the Report_audit_logs we want to count
     *   }
     * })
    **/
    count<T extends report_audit_logCountArgs>(
      args?: Subset<T, report_audit_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_audit_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_audit_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_audit_logAggregateArgs>(args: Subset<T, Report_audit_logAggregateArgs>): Prisma.PrismaPromise<GetReport_audit_logAggregateType<T>>

    /**
     * Group by Report_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_audit_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends report_audit_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: report_audit_logGroupByArgs['orderBy'] }
        : { orderBy?: report_audit_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, report_audit_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_audit_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report_audit_log model
   */
  readonly fields: report_audit_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report_audit_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__report_audit_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_users<T extends report_audit_log$admin_usersArgs<ExtArgs> = {}>(args?: Subset<T, report_audit_log$admin_usersArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report_audit_log model
   */
  interface report_audit_logFieldRefs {
    readonly id: FieldRef<"report_audit_log", 'String'>
    readonly report_type: FieldRef<"report_audit_log", 'String'>
    readonly report_config: FieldRef<"report_audit_log", 'Json'>
    readonly generated_by: FieldRef<"report_audit_log", 'String'>
    readonly is_scheduled: FieldRef<"report_audit_log", 'Boolean'>
    readonly scheduled_report_id: FieldRef<"report_audit_log", 'String'>
    readonly generated_at: FieldRef<"report_audit_log", 'DateTime'>
    readonly file_size_bytes: FieldRef<"report_audit_log", 'Int'>
    readonly generation_time_ms: FieldRef<"report_audit_log", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * report_audit_log findUnique
   */
  export type report_audit_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where: report_audit_logWhereUniqueInput
  }

  /**
   * report_audit_log findUniqueOrThrow
   */
  export type report_audit_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where: report_audit_logWhereUniqueInput
  }

  /**
   * report_audit_log findFirst
   */
  export type report_audit_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_audit_logs.
     */
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
  }

  /**
   * report_audit_log findFirstOrThrow
   */
  export type report_audit_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_log to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_audit_logs.
     */
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
  }

  /**
   * report_audit_log findMany
   */
  export type report_audit_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which report_audit_logs to fetch.
     */
    where?: report_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_audit_logs to fetch.
     */
    orderBy?: report_audit_logOrderByWithRelationInput | report_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing report_audit_logs.
     */
    cursor?: report_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_audit_logs.
     */
    skip?: number
    distinct?: Report_audit_logScalarFieldEnum | Report_audit_logScalarFieldEnum[]
  }

  /**
   * report_audit_log create
   */
  export type report_audit_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to create a report_audit_log.
     */
    data: XOR<report_audit_logCreateInput, report_audit_logUncheckedCreateInput>
  }

  /**
   * report_audit_log createMany
   */
  export type report_audit_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many report_audit_logs.
     */
    data: report_audit_logCreateManyInput | report_audit_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report_audit_log createManyAndReturn
   */
  export type report_audit_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * The data used to create many report_audit_logs.
     */
    data: report_audit_logCreateManyInput | report_audit_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_audit_log update
   */
  export type report_audit_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to update a report_audit_log.
     */
    data: XOR<report_audit_logUpdateInput, report_audit_logUncheckedUpdateInput>
    /**
     * Choose, which report_audit_log to update.
     */
    where: report_audit_logWhereUniqueInput
  }

  /**
   * report_audit_log updateMany
   */
  export type report_audit_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update report_audit_logs.
     */
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyInput>
    /**
     * Filter which report_audit_logs to update
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to update.
     */
    limit?: number
  }

  /**
   * report_audit_log updateManyAndReturn
   */
  export type report_audit_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * The data used to update report_audit_logs.
     */
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyInput>
    /**
     * Filter which report_audit_logs to update
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_audit_log upsert
   */
  export type report_audit_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * The filter to search for the report_audit_log to update in case it exists.
     */
    where: report_audit_logWhereUniqueInput
    /**
     * In case the report_audit_log found by the `where` argument doesn't exist, create a new report_audit_log with this data.
     */
    create: XOR<report_audit_logCreateInput, report_audit_logUncheckedCreateInput>
    /**
     * In case the report_audit_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<report_audit_logUpdateInput, report_audit_logUncheckedUpdateInput>
  }

  /**
   * report_audit_log delete
   */
  export type report_audit_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
    /**
     * Filter which report_audit_log to delete.
     */
    where: report_audit_logWhereUniqueInput
  }

  /**
   * report_audit_log deleteMany
   */
  export type report_audit_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_audit_logs to delete
     */
    where?: report_audit_logWhereInput
    /**
     * Limit how many report_audit_logs to delete.
     */
    limit?: number
  }

  /**
   * report_audit_log.admin_users
   */
  export type report_audit_log$admin_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * report_audit_log without action
   */
  export type report_audit_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_audit_log
     */
    select?: report_audit_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_audit_log
     */
    omit?: report_audit_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_audit_logInclude<ExtArgs> | null
  }


  /**
   * Model ReportSetting
   */

  export type AggregateReportSetting = {
    _count: ReportSettingCountAggregateOutputType | null
    _min: ReportSettingMinAggregateOutputType | null
    _max: ReportSettingMaxAggregateOutputType | null
  }

  export type ReportSettingMinAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type ReportSettingMaxAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type ReportSettingCountAggregateOutputType = {
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type ReportSettingMinAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type ReportSettingMaxAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type ReportSettingCountAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportSetting to aggregate.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportSettings
    **/
    _count?: true | ReportSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportSettingMaxAggregateInputType
  }

  export type GetReportSettingAggregateType<T extends ReportSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateReportSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportSetting[P]>
      : GetScalarType<T[P], AggregateReportSetting[P]>
  }




  export type ReportSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportSettingWhereInput
    orderBy?: ReportSettingOrderByWithAggregationInput | ReportSettingOrderByWithAggregationInput[]
    by: ReportSettingScalarFieldEnum[] | ReportSettingScalarFieldEnum
    having?: ReportSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportSettingCountAggregateInputType | true
    _min?: ReportSettingMinAggregateInputType
    _max?: ReportSettingMaxAggregateInputType
  }

  export type ReportSettingGroupByOutputType = {
    key: string
    value: JsonValue
    updatedAt: Date
    _count: ReportSettingCountAggregateOutputType | null
    _min: ReportSettingMinAggregateOutputType | null
    _max: ReportSettingMaxAggregateOutputType | null
  }

  type GetReportSettingGroupByPayload<T extends ReportSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportSettingGroupByOutputType[P]>
            : GetScalarType<T[P], ReportSettingGroupByOutputType[P]>
        }
      >
    >


  export type ReportSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportSetting"]>

  export type ReportSettingSelectScalar = {
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type ReportSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "updatedAt", ExtArgs["result"]["reportSetting"]>

  export type $ReportSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["reportSetting"]>
    composites: {}
  }

  type ReportSettingGetPayload<S extends boolean | null | undefined | ReportSettingDefaultArgs> = $Result.GetResult<Prisma.$ReportSettingPayload, S>

  type ReportSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportSettingCountAggregateInputType | true
    }

  export interface ReportSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportSetting'], meta: { name: 'ReportSetting' } }
    /**
     * Find zero or one ReportSetting that matches the filter.
     * @param {ReportSettingFindUniqueArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportSettingFindUniqueArgs>(args: SelectSubset<T, ReportSettingFindUniqueArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportSettingFindUniqueOrThrowArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindFirstArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportSettingFindFirstArgs>(args?: SelectSubset<T, ReportSettingFindFirstArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindFirstOrThrowArgs} args - Arguments to find a ReportSetting
     * @example
     * // Get one ReportSetting
     * const reportSetting = await prisma.reportSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportSettings
     * const reportSettings = await prisma.reportSetting.findMany()
     * 
     * // Get first 10 ReportSettings
     * const reportSettings = await prisma.reportSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends ReportSettingFindManyArgs>(args?: SelectSubset<T, ReportSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportSetting.
     * @param {ReportSettingCreateArgs} args - Arguments to create a ReportSetting.
     * @example
     * // Create one ReportSetting
     * const ReportSetting = await prisma.reportSetting.create({
     *   data: {
     *     // ... data to create a ReportSetting
     *   }
     * })
     * 
     */
    create<T extends ReportSettingCreateArgs>(args: SelectSubset<T, ReportSettingCreateArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportSettings.
     * @param {ReportSettingCreateManyArgs} args - Arguments to create many ReportSettings.
     * @example
     * // Create many ReportSettings
     * const reportSetting = await prisma.reportSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportSettingCreateManyArgs>(args?: SelectSubset<T, ReportSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportSettings and returns the data saved in the database.
     * @param {ReportSettingCreateManyAndReturnArgs} args - Arguments to create many ReportSettings.
     * @example
     * // Create many ReportSettings
     * const reportSetting = await prisma.reportSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportSettings and only return the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportSetting.
     * @param {ReportSettingDeleteArgs} args - Arguments to delete one ReportSetting.
     * @example
     * // Delete one ReportSetting
     * const ReportSetting = await prisma.reportSetting.delete({
     *   where: {
     *     // ... filter to delete one ReportSetting
     *   }
     * })
     * 
     */
    delete<T extends ReportSettingDeleteArgs>(args: SelectSubset<T, ReportSettingDeleteArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportSetting.
     * @param {ReportSettingUpdateArgs} args - Arguments to update one ReportSetting.
     * @example
     * // Update one ReportSetting
     * const reportSetting = await prisma.reportSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportSettingUpdateArgs>(args: SelectSubset<T, ReportSettingUpdateArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportSettings.
     * @param {ReportSettingDeleteManyArgs} args - Arguments to filter ReportSettings to delete.
     * @example
     * // Delete a few ReportSettings
     * const { count } = await prisma.reportSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportSettingDeleteManyArgs>(args?: SelectSubset<T, ReportSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportSettings
     * const reportSetting = await prisma.reportSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportSettingUpdateManyArgs>(args: SelectSubset<T, ReportSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportSettings and returns the data updated in the database.
     * @param {ReportSettingUpdateManyAndReturnArgs} args - Arguments to update many ReportSettings.
     * @example
     * // Update many ReportSettings
     * const reportSetting = await prisma.reportSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportSettings and only return the `key`
     * const reportSettingWithKeyOnly = await prisma.reportSetting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportSetting.
     * @param {ReportSettingUpsertArgs} args - Arguments to update or create a ReportSetting.
     * @example
     * // Update or create a ReportSetting
     * const reportSetting = await prisma.reportSetting.upsert({
     *   create: {
     *     // ... data to create a ReportSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportSetting we want to update
     *   }
     * })
     */
    upsert<T extends ReportSettingUpsertArgs>(args: SelectSubset<T, ReportSettingUpsertArgs<ExtArgs>>): Prisma__ReportSettingClient<$Result.GetResult<Prisma.$ReportSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingCountArgs} args - Arguments to filter ReportSettings to count.
     * @example
     * // Count the number of ReportSettings
     * const count = await prisma.reportSetting.count({
     *   where: {
     *     // ... the filter for the ReportSettings we want to count
     *   }
     * })
    **/
    count<T extends ReportSettingCountArgs>(
      args?: Subset<T, ReportSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportSettingAggregateArgs>(args: Subset<T, ReportSettingAggregateArgs>): Prisma.PrismaPromise<GetReportSettingAggregateType<T>>

    /**
     * Group by ReportSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportSettingGroupByArgs['orderBy'] }
        : { orderBy?: ReportSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportSetting model
   */
  readonly fields: ReportSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportSetting model
   */
  interface ReportSettingFieldRefs {
    readonly key: FieldRef<"ReportSetting", 'String'>
    readonly value: FieldRef<"ReportSetting", 'Json'>
    readonly updatedAt: FieldRef<"ReportSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportSetting findUnique
   */
  export type ReportSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where: ReportSettingWhereUniqueInput
  }

  /**
   * ReportSetting findUniqueOrThrow
   */
  export type ReportSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where: ReportSettingWhereUniqueInput
  }

  /**
   * ReportSetting findFirst
   */
  export type ReportSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportSettings.
     */
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
  }

  /**
   * ReportSetting findFirstOrThrow
   */
  export type ReportSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSetting to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportSettings.
     */
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
  }

  /**
   * ReportSetting findMany
   */
  export type ReportSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter, which ReportSettings to fetch.
     */
    where?: ReportSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSettings to fetch.
     */
    orderBy?: ReportSettingOrderByWithRelationInput | ReportSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportSettings.
     */
    cursor?: ReportSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSettings.
     */
    skip?: number
    distinct?: ReportSettingScalarFieldEnum | ReportSettingScalarFieldEnum[]
  }

  /**
   * ReportSetting create
   */
  export type ReportSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a ReportSetting.
     */
    data: XOR<ReportSettingCreateInput, ReportSettingUncheckedCreateInput>
  }

  /**
   * ReportSetting createMany
   */
  export type ReportSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportSettings.
     */
    data: ReportSettingCreateManyInput | ReportSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportSetting createManyAndReturn
   */
  export type ReportSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data used to create many ReportSettings.
     */
    data: ReportSettingCreateManyInput | ReportSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportSetting update
   */
  export type ReportSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a ReportSetting.
     */
    data: XOR<ReportSettingUpdateInput, ReportSettingUncheckedUpdateInput>
    /**
     * Choose, which ReportSetting to update.
     */
    where: ReportSettingWhereUniqueInput
  }

  /**
   * ReportSetting updateMany
   */
  export type ReportSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportSettings.
     */
    data: XOR<ReportSettingUpdateManyMutationInput, ReportSettingUncheckedUpdateManyInput>
    /**
     * Filter which ReportSettings to update
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to update.
     */
    limit?: number
  }

  /**
   * ReportSetting updateManyAndReturn
   */
  export type ReportSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The data used to update ReportSettings.
     */
    data: XOR<ReportSettingUpdateManyMutationInput, ReportSettingUncheckedUpdateManyInput>
    /**
     * Filter which ReportSettings to update
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to update.
     */
    limit?: number
  }

  /**
   * ReportSetting upsert
   */
  export type ReportSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the ReportSetting to update in case it exists.
     */
    where: ReportSettingWhereUniqueInput
    /**
     * In case the ReportSetting found by the `where` argument doesn't exist, create a new ReportSetting with this data.
     */
    create: XOR<ReportSettingCreateInput, ReportSettingUncheckedCreateInput>
    /**
     * In case the ReportSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportSettingUpdateInput, ReportSettingUncheckedUpdateInput>
  }

  /**
   * ReportSetting delete
   */
  export type ReportSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
    /**
     * Filter which ReportSetting to delete.
     */
    where: ReportSettingWhereUniqueInput
  }

  /**
   * ReportSetting deleteMany
   */
  export type ReportSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportSettings to delete
     */
    where?: ReportSettingWhereInput
    /**
     * Limit how many ReportSettings to delete.
     */
    limit?: number
  }

  /**
   * ReportSetting without action
   */
  export type ReportSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportSetting
     */
    select?: ReportSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportSetting
     */
    omit?: ReportSettingOmit<ExtArgs> | null
  }


  /**
   * Model TrainingYear
   */

  export type AggregateTrainingYear = {
    _count: TrainingYearCountAggregateOutputType | null
    _min: TrainingYearMinAggregateOutputType | null
    _max: TrainingYearMaxAggregateOutputType | null
  }

  export type TrainingYearMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingYearMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingYearCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    holidayExclusions: number
    dayExceptions: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingYearMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingYearMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingYearCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    holidayExclusions?: true
    dayExceptions?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingYear to aggregate.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingYears
    **/
    _count?: true | TrainingYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingYearMaxAggregateInputType
  }

  export type GetTrainingYearAggregateType<T extends TrainingYearAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingYear[P]>
      : GetScalarType<T[P], AggregateTrainingYear[P]>
  }




  export type TrainingYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingYearWhereInput
    orderBy?: TrainingYearOrderByWithAggregationInput | TrainingYearOrderByWithAggregationInput[]
    by: TrainingYearScalarFieldEnum[] | TrainingYearScalarFieldEnum
    having?: TrainingYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingYearCountAggregateInputType | true
    _min?: TrainingYearMinAggregateInputType
    _max?: TrainingYearMaxAggregateInputType
  }

  export type TrainingYearGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    holidayExclusions: JsonValue
    dayExceptions: JsonValue
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingYearCountAggregateOutputType | null
    _min: TrainingYearMinAggregateOutputType | null
    _max: TrainingYearMaxAggregateOutputType | null
  }

  type GetTrainingYearGroupByPayload<T extends TrainingYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingYearGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingYearGroupByOutputType[P]>
        }
      >
    >


  export type TrainingYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingYear"]>

  export type TrainingYearSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    holidayExclusions?: boolean
    dayExceptions?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "holidayExclusions" | "dayExceptions" | "isCurrent" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingYear"]>

  export type $TrainingYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingYear"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      holidayExclusions: Prisma.JsonValue
      dayExceptions: Prisma.JsonValue
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingYear"]>
    composites: {}
  }

  type TrainingYearGetPayload<S extends boolean | null | undefined | TrainingYearDefaultArgs> = $Result.GetResult<Prisma.$TrainingYearPayload, S>

  type TrainingYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingYearCountAggregateInputType | true
    }

  export interface TrainingYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingYear'], meta: { name: 'TrainingYear' } }
    /**
     * Find zero or one TrainingYear that matches the filter.
     * @param {TrainingYearFindUniqueArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingYearFindUniqueArgs>(args: SelectSubset<T, TrainingYearFindUniqueArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingYearFindUniqueOrThrowArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingYearFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindFirstArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingYearFindFirstArgs>(args?: SelectSubset<T, TrainingYearFindFirstArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindFirstOrThrowArgs} args - Arguments to find a TrainingYear
     * @example
     * // Get one TrainingYear
     * const trainingYear = await prisma.trainingYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingYearFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingYears
     * const trainingYears = await prisma.trainingYear.findMany()
     * 
     * // Get first 10 TrainingYears
     * const trainingYears = await prisma.trainingYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingYearFindManyArgs>(args?: SelectSubset<T, TrainingYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingYear.
     * @param {TrainingYearCreateArgs} args - Arguments to create a TrainingYear.
     * @example
     * // Create one TrainingYear
     * const TrainingYear = await prisma.trainingYear.create({
     *   data: {
     *     // ... data to create a TrainingYear
     *   }
     * })
     * 
     */
    create<T extends TrainingYearCreateArgs>(args: SelectSubset<T, TrainingYearCreateArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingYears.
     * @param {TrainingYearCreateManyArgs} args - Arguments to create many TrainingYears.
     * @example
     * // Create many TrainingYears
     * const trainingYear = await prisma.trainingYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingYearCreateManyArgs>(args?: SelectSubset<T, TrainingYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingYears and returns the data saved in the database.
     * @param {TrainingYearCreateManyAndReturnArgs} args - Arguments to create many TrainingYears.
     * @example
     * // Create many TrainingYears
     * const trainingYear = await prisma.trainingYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingYears and only return the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingYearCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingYear.
     * @param {TrainingYearDeleteArgs} args - Arguments to delete one TrainingYear.
     * @example
     * // Delete one TrainingYear
     * const TrainingYear = await prisma.trainingYear.delete({
     *   where: {
     *     // ... filter to delete one TrainingYear
     *   }
     * })
     * 
     */
    delete<T extends TrainingYearDeleteArgs>(args: SelectSubset<T, TrainingYearDeleteArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingYear.
     * @param {TrainingYearUpdateArgs} args - Arguments to update one TrainingYear.
     * @example
     * // Update one TrainingYear
     * const trainingYear = await prisma.trainingYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingYearUpdateArgs>(args: SelectSubset<T, TrainingYearUpdateArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingYears.
     * @param {TrainingYearDeleteManyArgs} args - Arguments to filter TrainingYears to delete.
     * @example
     * // Delete a few TrainingYears
     * const { count } = await prisma.trainingYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingYearDeleteManyArgs>(args?: SelectSubset<T, TrainingYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingYears
     * const trainingYear = await prisma.trainingYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingYearUpdateManyArgs>(args: SelectSubset<T, TrainingYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingYears and returns the data updated in the database.
     * @param {TrainingYearUpdateManyAndReturnArgs} args - Arguments to update many TrainingYears.
     * @example
     * // Update many TrainingYears
     * const trainingYear = await prisma.trainingYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingYears and only return the `id`
     * const trainingYearWithIdOnly = await prisma.trainingYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingYearUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingYear.
     * @param {TrainingYearUpsertArgs} args - Arguments to update or create a TrainingYear.
     * @example
     * // Update or create a TrainingYear
     * const trainingYear = await prisma.trainingYear.upsert({
     *   create: {
     *     // ... data to create a TrainingYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingYear we want to update
     *   }
     * })
     */
    upsert<T extends TrainingYearUpsertArgs>(args: SelectSubset<T, TrainingYearUpsertArgs<ExtArgs>>): Prisma__TrainingYearClient<$Result.GetResult<Prisma.$TrainingYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearCountArgs} args - Arguments to filter TrainingYears to count.
     * @example
     * // Count the number of TrainingYears
     * const count = await prisma.trainingYear.count({
     *   where: {
     *     // ... the filter for the TrainingYears we want to count
     *   }
     * })
    **/
    count<T extends TrainingYearCountArgs>(
      args?: Subset<T, TrainingYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingYearAggregateArgs>(args: Subset<T, TrainingYearAggregateArgs>): Prisma.PrismaPromise<GetTrainingYearAggregateType<T>>

    /**
     * Group by TrainingYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingYearGroupByArgs['orderBy'] }
        : { orderBy?: TrainingYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingYear model
   */
  readonly fields: TrainingYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingYear model
   */
  interface TrainingYearFieldRefs {
    readonly id: FieldRef<"TrainingYear", 'String'>
    readonly name: FieldRef<"TrainingYear", 'String'>
    readonly startDate: FieldRef<"TrainingYear", 'DateTime'>
    readonly endDate: FieldRef<"TrainingYear", 'DateTime'>
    readonly holidayExclusions: FieldRef<"TrainingYear", 'Json'>
    readonly dayExceptions: FieldRef<"TrainingYear", 'Json'>
    readonly isCurrent: FieldRef<"TrainingYear", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingYear", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingYear findUnique
   */
  export type TrainingYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where: TrainingYearWhereUniqueInput
  }

  /**
   * TrainingYear findUniqueOrThrow
   */
  export type TrainingYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where: TrainingYearWhereUniqueInput
  }

  /**
   * TrainingYear findFirst
   */
  export type TrainingYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingYears.
     */
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
  }

  /**
   * TrainingYear findFirstOrThrow
   */
  export type TrainingYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYear to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingYears.
     */
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
  }

  /**
   * TrainingYear findMany
   */
  export type TrainingYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter, which TrainingYears to fetch.
     */
    where?: TrainingYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingYears to fetch.
     */
    orderBy?: TrainingYearOrderByWithRelationInput | TrainingYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingYears.
     */
    cursor?: TrainingYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingYears.
     */
    skip?: number
    distinct?: TrainingYearScalarFieldEnum | TrainingYearScalarFieldEnum[]
  }

  /**
   * TrainingYear create
   */
  export type TrainingYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data needed to create a TrainingYear.
     */
    data: XOR<TrainingYearCreateInput, TrainingYearUncheckedCreateInput>
  }

  /**
   * TrainingYear createMany
   */
  export type TrainingYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingYears.
     */
    data: TrainingYearCreateManyInput | TrainingYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingYear createManyAndReturn
   */
  export type TrainingYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingYears.
     */
    data: TrainingYearCreateManyInput | TrainingYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingYear update
   */
  export type TrainingYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data needed to update a TrainingYear.
     */
    data: XOR<TrainingYearUpdateInput, TrainingYearUncheckedUpdateInput>
    /**
     * Choose, which TrainingYear to update.
     */
    where: TrainingYearWhereUniqueInput
  }

  /**
   * TrainingYear updateMany
   */
  export type TrainingYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingYears.
     */
    data: XOR<TrainingYearUpdateManyMutationInput, TrainingYearUncheckedUpdateManyInput>
    /**
     * Filter which TrainingYears to update
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to update.
     */
    limit?: number
  }

  /**
   * TrainingYear updateManyAndReturn
   */
  export type TrainingYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The data used to update TrainingYears.
     */
    data: XOR<TrainingYearUpdateManyMutationInput, TrainingYearUncheckedUpdateManyInput>
    /**
     * Filter which TrainingYears to update
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to update.
     */
    limit?: number
  }

  /**
   * TrainingYear upsert
   */
  export type TrainingYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * The filter to search for the TrainingYear to update in case it exists.
     */
    where: TrainingYearWhereUniqueInput
    /**
     * In case the TrainingYear found by the `where` argument doesn't exist, create a new TrainingYear with this data.
     */
    create: XOR<TrainingYearCreateInput, TrainingYearUncheckedCreateInput>
    /**
     * In case the TrainingYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingYearUpdateInput, TrainingYearUncheckedUpdateInput>
  }

  /**
   * TrainingYear delete
   */
  export type TrainingYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
    /**
     * Filter which TrainingYear to delete.
     */
    where: TrainingYearWhereUniqueInput
  }

  /**
   * TrainingYear deleteMany
   */
  export type TrainingYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingYears to delete
     */
    where?: TrainingYearWhereInput
    /**
     * Limit how many TrainingYears to delete.
     */
    limit?: number
  }

  /**
   * TrainingYear without action
   */
  export type TrainingYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingYear
     */
    select?: TrainingYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingYear
     */
    omit?: TrainingYearOmit<ExtArgs> | null
  }


  /**
   * Model DdsAssignment
   */

  export type AggregateDdsAssignment = {
    _count: DdsAssignmentCountAggregateOutputType | null
    _min: DdsAssignmentMinAggregateOutputType | null
    _max: DdsAssignmentMaxAggregateOutputType | null
  }

  export type DdsAssignmentMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    assignedDate: Date | null
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DdsAssignmentMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    assignedDate: Date | null
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DdsAssignmentCountAggregateOutputType = {
    id: number
    memberId: number
    assignedDate: number
    acceptedAt: number
    releasedAt: number
    transferredTo: number
    assignedBy: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DdsAssignmentMinAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DdsAssignmentMaxAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DdsAssignmentCountAggregateInputType = {
    id?: true
    memberId?: true
    assignedDate?: true
    acceptedAt?: true
    releasedAt?: true
    transferredTo?: true
    assignedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DdsAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DdsAssignment to aggregate.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DdsAssignments
    **/
    _count?: true | DdsAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DdsAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DdsAssignmentMaxAggregateInputType
  }

  export type GetDdsAssignmentAggregateType<T extends DdsAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDdsAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDdsAssignment[P]>
      : GetScalarType<T[P], AggregateDdsAssignment[P]>
  }




  export type DdsAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DdsAssignmentWhereInput
    orderBy?: DdsAssignmentOrderByWithAggregationInput | DdsAssignmentOrderByWithAggregationInput[]
    by: DdsAssignmentScalarFieldEnum[] | DdsAssignmentScalarFieldEnum
    having?: DdsAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DdsAssignmentCountAggregateInputType | true
    _min?: DdsAssignmentMinAggregateInputType
    _max?: DdsAssignmentMaxAggregateInputType
  }

  export type DdsAssignmentGroupByOutputType = {
    id: string
    memberId: string
    assignedDate: Date
    acceptedAt: Date | null
    releasedAt: Date | null
    transferredTo: string | null
    assignedBy: string | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DdsAssignmentCountAggregateOutputType | null
    _min: DdsAssignmentMinAggregateOutputType | null
    _max: DdsAssignmentMaxAggregateOutputType | null
  }

  type GetDdsAssignmentGroupByPayload<T extends DdsAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DdsAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DdsAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DdsAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DdsAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DdsAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["ddsAssignment"]>

  export type DdsAssignmentSelectScalar = {
    id?: boolean
    memberId?: boolean
    assignedDate?: boolean
    acceptedAt?: boolean
    releasedAt?: boolean
    transferredTo?: boolean
    assignedBy?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DdsAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "assignedDate" | "acceptedAt" | "releasedAt" | "transferredTo" | "assignedBy" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["ddsAssignment"]>
  export type DdsAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }
  export type DdsAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }
  export type DdsAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    transferredToMember?: boolean | DdsAssignment$transferredToMemberArgs<ExtArgs>
    assignedByAdmin?: boolean | DdsAssignment$assignedByAdminArgs<ExtArgs>
  }

  export type $DdsAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DdsAssignment"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      transferredToMember: Prisma.$MemberPayload<ExtArgs> | null
      assignedByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      assignedDate: Date
      acceptedAt: Date | null
      releasedAt: Date | null
      transferredTo: string | null
      assignedBy: string | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ddsAssignment"]>
    composites: {}
  }

  type DdsAssignmentGetPayload<S extends boolean | null | undefined | DdsAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DdsAssignmentPayload, S>

  type DdsAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DdsAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DdsAssignmentCountAggregateInputType | true
    }

  export interface DdsAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DdsAssignment'], meta: { name: 'DdsAssignment' } }
    /**
     * Find zero or one DdsAssignment that matches the filter.
     * @param {DdsAssignmentFindUniqueArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DdsAssignmentFindUniqueArgs>(args: SelectSubset<T, DdsAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DdsAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DdsAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DdsAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DdsAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DdsAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindFirstArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DdsAssignmentFindFirstArgs>(args?: SelectSubset<T, DdsAssignmentFindFirstArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DdsAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindFirstOrThrowArgs} args - Arguments to find a DdsAssignment
     * @example
     * // Get one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DdsAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DdsAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DdsAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DdsAssignments
     * const ddsAssignments = await prisma.ddsAssignment.findMany()
     * 
     * // Get first 10 DdsAssignments
     * const ddsAssignments = await prisma.ddsAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DdsAssignmentFindManyArgs>(args?: SelectSubset<T, DdsAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DdsAssignment.
     * @param {DdsAssignmentCreateArgs} args - Arguments to create a DdsAssignment.
     * @example
     * // Create one DdsAssignment
     * const DdsAssignment = await prisma.ddsAssignment.create({
     *   data: {
     *     // ... data to create a DdsAssignment
     *   }
     * })
     * 
     */
    create<T extends DdsAssignmentCreateArgs>(args: SelectSubset<T, DdsAssignmentCreateArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DdsAssignments.
     * @param {DdsAssignmentCreateManyArgs} args - Arguments to create many DdsAssignments.
     * @example
     * // Create many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DdsAssignmentCreateManyArgs>(args?: SelectSubset<T, DdsAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DdsAssignments and returns the data saved in the database.
     * @param {DdsAssignmentCreateManyAndReturnArgs} args - Arguments to create many DdsAssignments.
     * @example
     * // Create many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DdsAssignments and only return the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DdsAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DdsAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DdsAssignment.
     * @param {DdsAssignmentDeleteArgs} args - Arguments to delete one DdsAssignment.
     * @example
     * // Delete one DdsAssignment
     * const DdsAssignment = await prisma.ddsAssignment.delete({
     *   where: {
     *     // ... filter to delete one DdsAssignment
     *   }
     * })
     * 
     */
    delete<T extends DdsAssignmentDeleteArgs>(args: SelectSubset<T, DdsAssignmentDeleteArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DdsAssignment.
     * @param {DdsAssignmentUpdateArgs} args - Arguments to update one DdsAssignment.
     * @example
     * // Update one DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DdsAssignmentUpdateArgs>(args: SelectSubset<T, DdsAssignmentUpdateArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DdsAssignments.
     * @param {DdsAssignmentDeleteManyArgs} args - Arguments to filter DdsAssignments to delete.
     * @example
     * // Delete a few DdsAssignments
     * const { count } = await prisma.ddsAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DdsAssignmentDeleteManyArgs>(args?: SelectSubset<T, DdsAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DdsAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DdsAssignmentUpdateManyArgs>(args: SelectSubset<T, DdsAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DdsAssignments and returns the data updated in the database.
     * @param {DdsAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DdsAssignments.
     * @example
     * // Update many DdsAssignments
     * const ddsAssignment = await prisma.ddsAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DdsAssignments and only return the `id`
     * const ddsAssignmentWithIdOnly = await prisma.ddsAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DdsAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DdsAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DdsAssignment.
     * @param {DdsAssignmentUpsertArgs} args - Arguments to update or create a DdsAssignment.
     * @example
     * // Update or create a DdsAssignment
     * const ddsAssignment = await prisma.ddsAssignment.upsert({
     *   create: {
     *     // ... data to create a DdsAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DdsAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DdsAssignmentUpsertArgs>(args: SelectSubset<T, DdsAssignmentUpsertArgs<ExtArgs>>): Prisma__DdsAssignmentClient<$Result.GetResult<Prisma.$DdsAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DdsAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentCountArgs} args - Arguments to filter DdsAssignments to count.
     * @example
     * // Count the number of DdsAssignments
     * const count = await prisma.ddsAssignment.count({
     *   where: {
     *     // ... the filter for the DdsAssignments we want to count
     *   }
     * })
    **/
    count<T extends DdsAssignmentCountArgs>(
      args?: Subset<T, DdsAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DdsAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DdsAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DdsAssignmentAggregateArgs>(args: Subset<T, DdsAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDdsAssignmentAggregateType<T>>

    /**
     * Group by DdsAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DdsAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DdsAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DdsAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DdsAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DdsAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDdsAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DdsAssignment model
   */
  readonly fields: DdsAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DdsAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DdsAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transferredToMember<T extends DdsAssignment$transferredToMemberArgs<ExtArgs> = {}>(args?: Subset<T, DdsAssignment$transferredToMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedByAdmin<T extends DdsAssignment$assignedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, DdsAssignment$assignedByAdminArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DdsAssignment model
   */
  interface DdsAssignmentFieldRefs {
    readonly id: FieldRef<"DdsAssignment", 'String'>
    readonly memberId: FieldRef<"DdsAssignment", 'String'>
    readonly assignedDate: FieldRef<"DdsAssignment", 'DateTime'>
    readonly acceptedAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly releasedAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly transferredTo: FieldRef<"DdsAssignment", 'String'>
    readonly assignedBy: FieldRef<"DdsAssignment", 'String'>
    readonly status: FieldRef<"DdsAssignment", 'String'>
    readonly notes: FieldRef<"DdsAssignment", 'String'>
    readonly createdAt: FieldRef<"DdsAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"DdsAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DdsAssignment findUnique
   */
  export type DdsAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where: DdsAssignmentWhereUniqueInput
  }

  /**
   * DdsAssignment findUniqueOrThrow
   */
  export type DdsAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where: DdsAssignmentWhereUniqueInput
  }

  /**
   * DdsAssignment findFirst
   */
  export type DdsAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DdsAssignments.
     */
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * DdsAssignment findFirstOrThrow
   */
  export type DdsAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignment to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DdsAssignments.
     */
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * DdsAssignment findMany
   */
  export type DdsAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DdsAssignments to fetch.
     */
    where?: DdsAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DdsAssignments to fetch.
     */
    orderBy?: DdsAssignmentOrderByWithRelationInput | DdsAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DdsAssignments.
     */
    cursor?: DdsAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DdsAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DdsAssignments.
     */
    skip?: number
    distinct?: DdsAssignmentScalarFieldEnum | DdsAssignmentScalarFieldEnum[]
  }

  /**
   * DdsAssignment create
   */
  export type DdsAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DdsAssignment.
     */
    data: XOR<DdsAssignmentCreateInput, DdsAssignmentUncheckedCreateInput>
  }

  /**
   * DdsAssignment createMany
   */
  export type DdsAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DdsAssignments.
     */
    data: DdsAssignmentCreateManyInput | DdsAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DdsAssignment createManyAndReturn
   */
  export type DdsAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DdsAssignments.
     */
    data: DdsAssignmentCreateManyInput | DdsAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DdsAssignment update
   */
  export type DdsAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DdsAssignment.
     */
    data: XOR<DdsAssignmentUpdateInput, DdsAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DdsAssignment to update.
     */
    where: DdsAssignmentWhereUniqueInput
  }

  /**
   * DdsAssignment updateMany
   */
  export type DdsAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DdsAssignments.
     */
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DdsAssignments to update
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to update.
     */
    limit?: number
  }

  /**
   * DdsAssignment updateManyAndReturn
   */
  export type DdsAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DdsAssignments.
     */
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DdsAssignments to update
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DdsAssignment upsert
   */
  export type DdsAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DdsAssignment to update in case it exists.
     */
    where: DdsAssignmentWhereUniqueInput
    /**
     * In case the DdsAssignment found by the `where` argument doesn't exist, create a new DdsAssignment with this data.
     */
    create: XOR<DdsAssignmentCreateInput, DdsAssignmentUncheckedCreateInput>
    /**
     * In case the DdsAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DdsAssignmentUpdateInput, DdsAssignmentUncheckedUpdateInput>
  }

  /**
   * DdsAssignment delete
   */
  export type DdsAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DdsAssignment to delete.
     */
    where: DdsAssignmentWhereUniqueInput
  }

  /**
   * DdsAssignment deleteMany
   */
  export type DdsAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DdsAssignments to delete
     */
    where?: DdsAssignmentWhereInput
    /**
     * Limit how many DdsAssignments to delete.
     */
    limit?: number
  }

  /**
   * DdsAssignment.transferredToMember
   */
  export type DdsAssignment$transferredToMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * DdsAssignment.assignedByAdmin
   */
  export type DdsAssignment$assignedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * DdsAssignment without action
   */
  export type DdsAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DdsAssignment
     */
    select?: DdsAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DdsAssignment
     */
    omit?: DdsAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DdsAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ResponsibilityAuditLog
   */

  export type AggregateResponsibilityAuditLog = {
    _count: ResponsibilityAuditLogCountAggregateOutputType | null
    _min: ResponsibilityAuditLogMinAggregateOutputType | null
    _max: ResponsibilityAuditLogMaxAggregateOutputType | null
  }

  export type ResponsibilityAuditLogMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagName: string | null
    action: string | null
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string | null
    timestamp: Date | null
    notes: string | null
  }

  export type ResponsibilityAuditLogMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    tagName: string | null
    action: string | null
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string | null
    timestamp: Date | null
    notes: string | null
  }

  export type ResponsibilityAuditLogCountAggregateOutputType = {
    id: number
    memberId: number
    tagName: number
    action: number
    fromMemberId: number
    toMemberId: number
    performedBy: number
    performedByType: number
    timestamp: number
    notes: number
    _all: number
  }


  export type ResponsibilityAuditLogMinAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
  }

  export type ResponsibilityAuditLogMaxAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
  }

  export type ResponsibilityAuditLogCountAggregateInputType = {
    id?: true
    memberId?: true
    tagName?: true
    action?: true
    fromMemberId?: true
    toMemberId?: true
    performedBy?: true
    performedByType?: true
    timestamp?: true
    notes?: true
    _all?: true
  }

  export type ResponsibilityAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsibilityAuditLog to aggregate.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponsibilityAuditLogs
    **/
    _count?: true | ResponsibilityAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsibilityAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsibilityAuditLogMaxAggregateInputType
  }

  export type GetResponsibilityAuditLogAggregateType<T extends ResponsibilityAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsibilityAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsibilityAuditLog[P]>
      : GetScalarType<T[P], AggregateResponsibilityAuditLog[P]>
  }




  export type ResponsibilityAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsibilityAuditLogWhereInput
    orderBy?: ResponsibilityAuditLogOrderByWithAggregationInput | ResponsibilityAuditLogOrderByWithAggregationInput[]
    by: ResponsibilityAuditLogScalarFieldEnum[] | ResponsibilityAuditLogScalarFieldEnum
    having?: ResponsibilityAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsibilityAuditLogCountAggregateInputType | true
    _min?: ResponsibilityAuditLogMinAggregateInputType
    _max?: ResponsibilityAuditLogMaxAggregateInputType
  }

  export type ResponsibilityAuditLogGroupByOutputType = {
    id: string
    memberId: string
    tagName: string
    action: string
    fromMemberId: string | null
    toMemberId: string | null
    performedBy: string | null
    performedByType: string
    timestamp: Date
    notes: string | null
    _count: ResponsibilityAuditLogCountAggregateOutputType | null
    _min: ResponsibilityAuditLogMinAggregateOutputType | null
    _max: ResponsibilityAuditLogMaxAggregateOutputType | null
  }

  type GetResponsibilityAuditLogGroupByPayload<T extends ResponsibilityAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponsibilityAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsibilityAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsibilityAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsibilityAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type ResponsibilityAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }, ExtArgs["result"]["responsibilityAuditLog"]>

  export type ResponsibilityAuditLogSelectScalar = {
    id?: boolean
    memberId?: boolean
    tagName?: boolean
    action?: boolean
    fromMemberId?: boolean
    toMemberId?: boolean
    performedBy?: boolean
    performedByType?: boolean
    timestamp?: boolean
    notes?: boolean
  }

  export type ResponsibilityAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "tagName" | "action" | "fromMemberId" | "toMemberId" | "performedBy" | "performedByType" | "timestamp" | "notes", ExtArgs["result"]["responsibilityAuditLog"]>

  export type $ResponsibilityAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponsibilityAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      tagName: string
      action: string
      fromMemberId: string | null
      toMemberId: string | null
      performedBy: string | null
      performedByType: string
      timestamp: Date
      notes: string | null
    }, ExtArgs["result"]["responsibilityAuditLog"]>
    composites: {}
  }

  type ResponsibilityAuditLogGetPayload<S extends boolean | null | undefined | ResponsibilityAuditLogDefaultArgs> = $Result.GetResult<Prisma.$ResponsibilityAuditLogPayload, S>

  type ResponsibilityAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponsibilityAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResponsibilityAuditLogCountAggregateInputType | true
    }

  export interface ResponsibilityAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponsibilityAuditLog'], meta: { name: 'ResponsibilityAuditLog' } }
    /**
     * Find zero or one ResponsibilityAuditLog that matches the filter.
     * @param {ResponsibilityAuditLogFindUniqueArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponsibilityAuditLogFindUniqueArgs>(args: SelectSubset<T, ResponsibilityAuditLogFindUniqueArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResponsibilityAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponsibilityAuditLogFindUniqueOrThrowArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponsibilityAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsibilityAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindFirstArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponsibilityAuditLogFindFirstArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindFirstArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsibilityAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindFirstOrThrowArgs} args - Arguments to find a ResponsibilityAuditLog
     * @example
     * // Get one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponsibilityAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResponsibilityAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponsibilityAuditLogs
     * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany()
     * 
     * // Get first 10 ResponsibilityAuditLogs
     * const responsibilityAuditLogs = await prisma.responsibilityAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponsibilityAuditLogFindManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogCreateArgs} args - Arguments to create a ResponsibilityAuditLog.
     * @example
     * // Create one ResponsibilityAuditLog
     * const ResponsibilityAuditLog = await prisma.responsibilityAuditLog.create({
     *   data: {
     *     // ... data to create a ResponsibilityAuditLog
     *   }
     * })
     * 
     */
    create<T extends ResponsibilityAuditLogCreateArgs>(args: SelectSubset<T, ResponsibilityAuditLogCreateArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResponsibilityAuditLogs.
     * @param {ResponsibilityAuditLogCreateManyArgs} args - Arguments to create many ResponsibilityAuditLogs.
     * @example
     * // Create many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponsibilityAuditLogCreateManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponsibilityAuditLogs and returns the data saved in the database.
     * @param {ResponsibilityAuditLogCreateManyAndReturnArgs} args - Arguments to create many ResponsibilityAuditLogs.
     * @example
     * // Create many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponsibilityAuditLogs and only return the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponsibilityAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogDeleteArgs} args - Arguments to delete one ResponsibilityAuditLog.
     * @example
     * // Delete one ResponsibilityAuditLog
     * const ResponsibilityAuditLog = await prisma.responsibilityAuditLog.delete({
     *   where: {
     *     // ... filter to delete one ResponsibilityAuditLog
     *   }
     * })
     * 
     */
    delete<T extends ResponsibilityAuditLogDeleteArgs>(args: SelectSubset<T, ResponsibilityAuditLogDeleteArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogUpdateArgs} args - Arguments to update one ResponsibilityAuditLog.
     * @example
     * // Update one ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponsibilityAuditLogUpdateArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResponsibilityAuditLogs.
     * @param {ResponsibilityAuditLogDeleteManyArgs} args - Arguments to filter ResponsibilityAuditLogs to delete.
     * @example
     * // Delete a few ResponsibilityAuditLogs
     * const { count } = await prisma.responsibilityAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponsibilityAuditLogDeleteManyArgs>(args?: SelectSubset<T, ResponsibilityAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsibilityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponsibilityAuditLogUpdateManyArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsibilityAuditLogs and returns the data updated in the database.
     * @param {ResponsibilityAuditLogUpdateManyAndReturnArgs} args - Arguments to update many ResponsibilityAuditLogs.
     * @example
     * // Update many ResponsibilityAuditLogs
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResponsibilityAuditLogs and only return the `id`
     * const responsibilityAuditLogWithIdOnly = await prisma.responsibilityAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResponsibilityAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResponsibilityAuditLog.
     * @param {ResponsibilityAuditLogUpsertArgs} args - Arguments to update or create a ResponsibilityAuditLog.
     * @example
     * // Update or create a ResponsibilityAuditLog
     * const responsibilityAuditLog = await prisma.responsibilityAuditLog.upsert({
     *   create: {
     *     // ... data to create a ResponsibilityAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponsibilityAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends ResponsibilityAuditLogUpsertArgs>(args: SelectSubset<T, ResponsibilityAuditLogUpsertArgs<ExtArgs>>): Prisma__ResponsibilityAuditLogClient<$Result.GetResult<Prisma.$ResponsibilityAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResponsibilityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogCountArgs} args - Arguments to filter ResponsibilityAuditLogs to count.
     * @example
     * // Count the number of ResponsibilityAuditLogs
     * const count = await prisma.responsibilityAuditLog.count({
     *   where: {
     *     // ... the filter for the ResponsibilityAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends ResponsibilityAuditLogCountArgs>(
      args?: Subset<T, ResponsibilityAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsibilityAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponsibilityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsibilityAuditLogAggregateArgs>(args: Subset<T, ResponsibilityAuditLogAggregateArgs>): Prisma.PrismaPromise<GetResponsibilityAuditLogAggregateType<T>>

    /**
     * Group by ResponsibilityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponsibilityAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponsibilityAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: ResponsibilityAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponsibilityAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsibilityAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponsibilityAuditLog model
   */
  readonly fields: ResponsibilityAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponsibilityAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponsibilityAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponsibilityAuditLog model
   */
  interface ResponsibilityAuditLogFieldRefs {
    readonly id: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly memberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly tagName: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly action: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly fromMemberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly toMemberId: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly performedBy: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly performedByType: FieldRef<"ResponsibilityAuditLog", 'String'>
    readonly timestamp: FieldRef<"ResponsibilityAuditLog", 'DateTime'>
    readonly notes: FieldRef<"ResponsibilityAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResponsibilityAuditLog findUnique
   */
  export type ResponsibilityAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
  }

  /**
   * ResponsibilityAuditLog findUniqueOrThrow
   */
  export type ResponsibilityAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
  }

  /**
   * ResponsibilityAuditLog findFirst
   */
  export type ResponsibilityAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsibilityAuditLogs.
     */
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
  }

  /**
   * ResponsibilityAuditLog findFirstOrThrow
   */
  export type ResponsibilityAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLog to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsibilityAuditLogs.
     */
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
  }

  /**
   * ResponsibilityAuditLog findMany
   */
  export type ResponsibilityAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which ResponsibilityAuditLogs to fetch.
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsibilityAuditLogs to fetch.
     */
    orderBy?: ResponsibilityAuditLogOrderByWithRelationInput | ResponsibilityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponsibilityAuditLogs.
     */
    cursor?: ResponsibilityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsibilityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsibilityAuditLogs.
     */
    skip?: number
    distinct?: ResponsibilityAuditLogScalarFieldEnum | ResponsibilityAuditLogScalarFieldEnum[]
  }

  /**
   * ResponsibilityAuditLog create
   */
  export type ResponsibilityAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ResponsibilityAuditLog.
     */
    data: XOR<ResponsibilityAuditLogCreateInput, ResponsibilityAuditLogUncheckedCreateInput>
  }

  /**
   * ResponsibilityAuditLog createMany
   */
  export type ResponsibilityAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponsibilityAuditLogs.
     */
    data: ResponsibilityAuditLogCreateManyInput | ResponsibilityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsibilityAuditLog createManyAndReturn
   */
  export type ResponsibilityAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many ResponsibilityAuditLogs.
     */
    data: ResponsibilityAuditLogCreateManyInput | ResponsibilityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsibilityAuditLog update
   */
  export type ResponsibilityAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ResponsibilityAuditLog.
     */
    data: XOR<ResponsibilityAuditLogUpdateInput, ResponsibilityAuditLogUncheckedUpdateInput>
    /**
     * Choose, which ResponsibilityAuditLog to update.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
  }

  /**
   * ResponsibilityAuditLog updateMany
   */
  export type ResponsibilityAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponsibilityAuditLogs.
     */
    data: XOR<ResponsibilityAuditLogUpdateManyMutationInput, ResponsibilityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ResponsibilityAuditLogs to update
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog updateManyAndReturn
   */
  export type ResponsibilityAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update ResponsibilityAuditLogs.
     */
    data: XOR<ResponsibilityAuditLogUpdateManyMutationInput, ResponsibilityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ResponsibilityAuditLogs to update
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog upsert
   */
  export type ResponsibilityAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ResponsibilityAuditLog to update in case it exists.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
    /**
     * In case the ResponsibilityAuditLog found by the `where` argument doesn't exist, create a new ResponsibilityAuditLog with this data.
     */
    create: XOR<ResponsibilityAuditLogCreateInput, ResponsibilityAuditLogUncheckedCreateInput>
    /**
     * In case the ResponsibilityAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponsibilityAuditLogUpdateInput, ResponsibilityAuditLogUncheckedUpdateInput>
  }

  /**
   * ResponsibilityAuditLog delete
   */
  export type ResponsibilityAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
    /**
     * Filter which ResponsibilityAuditLog to delete.
     */
    where: ResponsibilityAuditLogWhereUniqueInput
  }

  /**
   * ResponsibilityAuditLog deleteMany
   */
  export type ResponsibilityAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsibilityAuditLogs to delete
     */
    where?: ResponsibilityAuditLogWhereInput
    /**
     * Limit how many ResponsibilityAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * ResponsibilityAuditLog without action
   */
  export type ResponsibilityAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsibilityAuditLog
     */
    select?: ResponsibilityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsibilityAuditLog
     */
    omit?: ResponsibilityAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model MemberStatus
   */

  export type AggregateMemberStatus = {
    _count: MemberStatusCountAggregateOutputType | null
    _min: MemberStatusMinAggregateOutputType | null
    _max: MemberStatusMaxAggregateOutputType | null
  }

  export type MemberStatusMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberStatusMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberStatusCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberStatusMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberStatusMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberStatusCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberStatus to aggregate.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberStatuses
    **/
    _count?: true | MemberStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberStatusMaxAggregateInputType
  }

  export type GetMemberStatusAggregateType<T extends MemberStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberStatus[P]>
      : GetScalarType<T[P], AggregateMemberStatus[P]>
  }




  export type MemberStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberStatusWhereInput
    orderBy?: MemberStatusOrderByWithAggregationInput | MemberStatusOrderByWithAggregationInput[]
    by: MemberStatusScalarFieldEnum[] | MemberStatusScalarFieldEnum
    having?: MemberStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberStatusCountAggregateInputType | true
    _min?: MemberStatusMinAggregateInputType
    _max?: MemberStatusMaxAggregateInputType
  }

  export type MemberStatusGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberStatusCountAggregateOutputType | null
    _min: MemberStatusMinAggregateOutputType | null
    _max: MemberStatusMaxAggregateOutputType | null
  }

  type GetMemberStatusGroupByPayload<T extends MemberStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MemberStatusGroupByOutputType[P]>
        }
      >
    >


  export type MemberStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | MemberStatus$membersArgs<ExtArgs>
    _count?: boolean | MemberStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberStatus"]>

  export type MemberStatusSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["memberStatus"]>
  export type MemberStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberStatus$membersArgs<ExtArgs>
    _count?: boolean | MemberStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberStatus"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberStatus"]>
    composites: {}
  }

  type MemberStatusGetPayload<S extends boolean | null | undefined | MemberStatusDefaultArgs> = $Result.GetResult<Prisma.$MemberStatusPayload, S>

  type MemberStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberStatusCountAggregateInputType | true
    }

  export interface MemberStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberStatus'], meta: { name: 'MemberStatus' } }
    /**
     * Find zero or one MemberStatus that matches the filter.
     * @param {MemberStatusFindUniqueArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberStatusFindUniqueArgs>(args: SelectSubset<T, MemberStatusFindUniqueArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberStatusFindUniqueOrThrowArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindFirstArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberStatusFindFirstArgs>(args?: SelectSubset<T, MemberStatusFindFirstArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindFirstOrThrowArgs} args - Arguments to find a MemberStatus
     * @example
     * // Get one MemberStatus
     * const memberStatus = await prisma.memberStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberStatuses
     * const memberStatuses = await prisma.memberStatus.findMany()
     * 
     * // Get first 10 MemberStatuses
     * const memberStatuses = await prisma.memberStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberStatusFindManyArgs>(args?: SelectSubset<T, MemberStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberStatus.
     * @param {MemberStatusCreateArgs} args - Arguments to create a MemberStatus.
     * @example
     * // Create one MemberStatus
     * const MemberStatus = await prisma.memberStatus.create({
     *   data: {
     *     // ... data to create a MemberStatus
     *   }
     * })
     * 
     */
    create<T extends MemberStatusCreateArgs>(args: SelectSubset<T, MemberStatusCreateArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberStatuses.
     * @param {MemberStatusCreateManyArgs} args - Arguments to create many MemberStatuses.
     * @example
     * // Create many MemberStatuses
     * const memberStatus = await prisma.memberStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberStatusCreateManyArgs>(args?: SelectSubset<T, MemberStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberStatuses and returns the data saved in the database.
     * @param {MemberStatusCreateManyAndReturnArgs} args - Arguments to create many MemberStatuses.
     * @example
     * // Create many MemberStatuses
     * const memberStatus = await prisma.memberStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberStatuses and only return the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberStatus.
     * @param {MemberStatusDeleteArgs} args - Arguments to delete one MemberStatus.
     * @example
     * // Delete one MemberStatus
     * const MemberStatus = await prisma.memberStatus.delete({
     *   where: {
     *     // ... filter to delete one MemberStatus
     *   }
     * })
     * 
     */
    delete<T extends MemberStatusDeleteArgs>(args: SelectSubset<T, MemberStatusDeleteArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberStatus.
     * @param {MemberStatusUpdateArgs} args - Arguments to update one MemberStatus.
     * @example
     * // Update one MemberStatus
     * const memberStatus = await prisma.memberStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberStatusUpdateArgs>(args: SelectSubset<T, MemberStatusUpdateArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberStatuses.
     * @param {MemberStatusDeleteManyArgs} args - Arguments to filter MemberStatuses to delete.
     * @example
     * // Delete a few MemberStatuses
     * const { count } = await prisma.memberStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberStatusDeleteManyArgs>(args?: SelectSubset<T, MemberStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberStatuses
     * const memberStatus = await prisma.memberStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberStatusUpdateManyArgs>(args: SelectSubset<T, MemberStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberStatuses and returns the data updated in the database.
     * @param {MemberStatusUpdateManyAndReturnArgs} args - Arguments to update many MemberStatuses.
     * @example
     * // Update many MemberStatuses
     * const memberStatus = await prisma.memberStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberStatuses and only return the `id`
     * const memberStatusWithIdOnly = await prisma.memberStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberStatus.
     * @param {MemberStatusUpsertArgs} args - Arguments to update or create a MemberStatus.
     * @example
     * // Update or create a MemberStatus
     * const memberStatus = await prisma.memberStatus.upsert({
     *   create: {
     *     // ... data to create a MemberStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberStatus we want to update
     *   }
     * })
     */
    upsert<T extends MemberStatusUpsertArgs>(args: SelectSubset<T, MemberStatusUpsertArgs<ExtArgs>>): Prisma__MemberStatusClient<$Result.GetResult<Prisma.$MemberStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusCountArgs} args - Arguments to filter MemberStatuses to count.
     * @example
     * // Count the number of MemberStatuses
     * const count = await prisma.memberStatus.count({
     *   where: {
     *     // ... the filter for the MemberStatuses we want to count
     *   }
     * })
    **/
    count<T extends MemberStatusCountArgs>(
      args?: Subset<T, MemberStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberStatusAggregateArgs>(args: Subset<T, MemberStatusAggregateArgs>): Prisma.PrismaPromise<GetMemberStatusAggregateType<T>>

    /**
     * Group by MemberStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberStatusGroupByArgs['orderBy'] }
        : { orderBy?: MemberStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberStatus model
   */
  readonly fields: MemberStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MemberStatus$membersArgs<ExtArgs> = {}>(args?: Subset<T, MemberStatus$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberStatus model
   */
  interface MemberStatusFieldRefs {
    readonly id: FieldRef<"MemberStatus", 'String'>
    readonly code: FieldRef<"MemberStatus", 'String'>
    readonly name: FieldRef<"MemberStatus", 'String'>
    readonly description: FieldRef<"MemberStatus", 'String'>
    readonly color: FieldRef<"MemberStatus", 'String'>
    readonly createdAt: FieldRef<"MemberStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberStatus findUnique
   */
  export type MemberStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where: MemberStatusWhereUniqueInput
  }

  /**
   * MemberStatus findUniqueOrThrow
   */
  export type MemberStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where: MemberStatusWhereUniqueInput
  }

  /**
   * MemberStatus findFirst
   */
  export type MemberStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberStatuses.
     */
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
  }

  /**
   * MemberStatus findFirstOrThrow
   */
  export type MemberStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatus to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberStatuses.
     */
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
  }

  /**
   * MemberStatus findMany
   */
  export type MemberStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter, which MemberStatuses to fetch.
     */
    where?: MemberStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberStatuses to fetch.
     */
    orderBy?: MemberStatusOrderByWithRelationInput | MemberStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberStatuses.
     */
    cursor?: MemberStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberStatuses.
     */
    skip?: number
    distinct?: MemberStatusScalarFieldEnum | MemberStatusScalarFieldEnum[]
  }

  /**
   * MemberStatus create
   */
  export type MemberStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberStatus.
     */
    data: XOR<MemberStatusCreateInput, MemberStatusUncheckedCreateInput>
  }

  /**
   * MemberStatus createMany
   */
  export type MemberStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberStatuses.
     */
    data: MemberStatusCreateManyInput | MemberStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberStatus createManyAndReturn
   */
  export type MemberStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * The data used to create many MemberStatuses.
     */
    data: MemberStatusCreateManyInput | MemberStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberStatus update
   */
  export type MemberStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberStatus.
     */
    data: XOR<MemberStatusUpdateInput, MemberStatusUncheckedUpdateInput>
    /**
     * Choose, which MemberStatus to update.
     */
    where: MemberStatusWhereUniqueInput
  }

  /**
   * MemberStatus updateMany
   */
  export type MemberStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberStatuses.
     */
    data: XOR<MemberStatusUpdateManyMutationInput, MemberStatusUncheckedUpdateManyInput>
    /**
     * Filter which MemberStatuses to update
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to update.
     */
    limit?: number
  }

  /**
   * MemberStatus updateManyAndReturn
   */
  export type MemberStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * The data used to update MemberStatuses.
     */
    data: XOR<MemberStatusUpdateManyMutationInput, MemberStatusUncheckedUpdateManyInput>
    /**
     * Filter which MemberStatuses to update
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to update.
     */
    limit?: number
  }

  /**
   * MemberStatus upsert
   */
  export type MemberStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberStatus to update in case it exists.
     */
    where: MemberStatusWhereUniqueInput
    /**
     * In case the MemberStatus found by the `where` argument doesn't exist, create a new MemberStatus with this data.
     */
    create: XOR<MemberStatusCreateInput, MemberStatusUncheckedCreateInput>
    /**
     * In case the MemberStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberStatusUpdateInput, MemberStatusUncheckedUpdateInput>
  }

  /**
   * MemberStatus delete
   */
  export type MemberStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
    /**
     * Filter which MemberStatus to delete.
     */
    where: MemberStatusWhereUniqueInput
  }

  /**
   * MemberStatus deleteMany
   */
  export type MemberStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberStatuses to delete
     */
    where?: MemberStatusWhereInput
    /**
     * Limit how many MemberStatuses to delete.
     */
    limit?: number
  }

  /**
   * MemberStatus.members
   */
  export type MemberStatus$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * MemberStatus without action
   */
  export type MemberStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberStatus
     */
    select?: MemberStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberStatus
     */
    omit?: MemberStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberStatusInclude<ExtArgs> | null
  }


  /**
   * Model MemberType
   */

  export type AggregateMemberType = {
    _count: MemberTypeCountAggregateOutputType | null
    _min: MemberTypeMinAggregateOutputType | null
    _max: MemberTypeMaxAggregateOutputType | null
  }

  export type MemberTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberType to aggregate.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberTypes
    **/
    _count?: true | MemberTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberTypeMaxAggregateInputType
  }

  export type GetMemberTypeAggregateType<T extends MemberTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberType[P]>
      : GetScalarType<T[P], AggregateMemberType[P]>
  }




  export type MemberTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTypeWhereInput
    orderBy?: MemberTypeOrderByWithAggregationInput | MemberTypeOrderByWithAggregationInput[]
    by: MemberTypeScalarFieldEnum[] | MemberTypeScalarFieldEnum
    having?: MemberTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberTypeCountAggregateInputType | true
    _min?: MemberTypeMinAggregateInputType
    _max?: MemberTypeMaxAggregateInputType
  }

  export type MemberTypeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberTypeCountAggregateOutputType | null
    _min: MemberTypeMinAggregateOutputType | null
    _max: MemberTypeMaxAggregateOutputType | null
  }

  type GetMemberTypeGroupByPayload<T extends MemberTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberTypeGroupByOutputType[P]>
            : GetScalarType<T[P], MemberTypeGroupByOutputType[P]>
        }
      >
    >


  export type MemberTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | MemberType$membersArgs<ExtArgs>
    _count?: boolean | MemberTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberType"]>

  export type MemberTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["memberType"]>
  export type MemberTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MemberType$membersArgs<ExtArgs>
    _count?: boolean | MemberTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberType"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberType"]>
    composites: {}
  }

  type MemberTypeGetPayload<S extends boolean | null | undefined | MemberTypeDefaultArgs> = $Result.GetResult<Prisma.$MemberTypePayload, S>

  type MemberTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberTypeCountAggregateInputType | true
    }

  export interface MemberTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberType'], meta: { name: 'MemberType' } }
    /**
     * Find zero or one MemberType that matches the filter.
     * @param {MemberTypeFindUniqueArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberTypeFindUniqueArgs>(args: SelectSubset<T, MemberTypeFindUniqueArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberTypeFindUniqueOrThrowArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindFirstArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberTypeFindFirstArgs>(args?: SelectSubset<T, MemberTypeFindFirstArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindFirstOrThrowArgs} args - Arguments to find a MemberType
     * @example
     * // Get one MemberType
     * const memberType = await prisma.memberType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberTypes
     * const memberTypes = await prisma.memberType.findMany()
     * 
     * // Get first 10 MemberTypes
     * const memberTypes = await prisma.memberType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberTypeFindManyArgs>(args?: SelectSubset<T, MemberTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberType.
     * @param {MemberTypeCreateArgs} args - Arguments to create a MemberType.
     * @example
     * // Create one MemberType
     * const MemberType = await prisma.memberType.create({
     *   data: {
     *     // ... data to create a MemberType
     *   }
     * })
     * 
     */
    create<T extends MemberTypeCreateArgs>(args: SelectSubset<T, MemberTypeCreateArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberTypes.
     * @param {MemberTypeCreateManyArgs} args - Arguments to create many MemberTypes.
     * @example
     * // Create many MemberTypes
     * const memberType = await prisma.memberType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberTypeCreateManyArgs>(args?: SelectSubset<T, MemberTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberTypes and returns the data saved in the database.
     * @param {MemberTypeCreateManyAndReturnArgs} args - Arguments to create many MemberTypes.
     * @example
     * // Create many MemberTypes
     * const memberType = await prisma.memberType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberTypes and only return the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberType.
     * @param {MemberTypeDeleteArgs} args - Arguments to delete one MemberType.
     * @example
     * // Delete one MemberType
     * const MemberType = await prisma.memberType.delete({
     *   where: {
     *     // ... filter to delete one MemberType
     *   }
     * })
     * 
     */
    delete<T extends MemberTypeDeleteArgs>(args: SelectSubset<T, MemberTypeDeleteArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberType.
     * @param {MemberTypeUpdateArgs} args - Arguments to update one MemberType.
     * @example
     * // Update one MemberType
     * const memberType = await prisma.memberType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberTypeUpdateArgs>(args: SelectSubset<T, MemberTypeUpdateArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberTypes.
     * @param {MemberTypeDeleteManyArgs} args - Arguments to filter MemberTypes to delete.
     * @example
     * // Delete a few MemberTypes
     * const { count } = await prisma.memberType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberTypeDeleteManyArgs>(args?: SelectSubset<T, MemberTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberTypes
     * const memberType = await prisma.memberType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberTypeUpdateManyArgs>(args: SelectSubset<T, MemberTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTypes and returns the data updated in the database.
     * @param {MemberTypeUpdateManyAndReturnArgs} args - Arguments to update many MemberTypes.
     * @example
     * // Update many MemberTypes
     * const memberType = await prisma.memberType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberTypes and only return the `id`
     * const memberTypeWithIdOnly = await prisma.memberType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberType.
     * @param {MemberTypeUpsertArgs} args - Arguments to update or create a MemberType.
     * @example
     * // Update or create a MemberType
     * const memberType = await prisma.memberType.upsert({
     *   create: {
     *     // ... data to create a MemberType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberType we want to update
     *   }
     * })
     */
    upsert<T extends MemberTypeUpsertArgs>(args: SelectSubset<T, MemberTypeUpsertArgs<ExtArgs>>): Prisma__MemberTypeClient<$Result.GetResult<Prisma.$MemberTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeCountArgs} args - Arguments to filter MemberTypes to count.
     * @example
     * // Count the number of MemberTypes
     * const count = await prisma.memberType.count({
     *   where: {
     *     // ... the filter for the MemberTypes we want to count
     *   }
     * })
    **/
    count<T extends MemberTypeCountArgs>(
      args?: Subset<T, MemberTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberTypeAggregateArgs>(args: Subset<T, MemberTypeAggregateArgs>): Prisma.PrismaPromise<GetMemberTypeAggregateType<T>>

    /**
     * Group by MemberType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberTypeGroupByArgs['orderBy'] }
        : { orderBy?: MemberTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberType model
   */
  readonly fields: MemberTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MemberType$membersArgs<ExtArgs> = {}>(args?: Subset<T, MemberType$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberType model
   */
  interface MemberTypeFieldRefs {
    readonly id: FieldRef<"MemberType", 'String'>
    readonly code: FieldRef<"MemberType", 'String'>
    readonly name: FieldRef<"MemberType", 'String'>
    readonly description: FieldRef<"MemberType", 'String'>
    readonly color: FieldRef<"MemberType", 'String'>
    readonly createdAt: FieldRef<"MemberType", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberType findUnique
   */
  export type MemberTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where: MemberTypeWhereUniqueInput
  }

  /**
   * MemberType findUniqueOrThrow
   */
  export type MemberTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where: MemberTypeWhereUniqueInput
  }

  /**
   * MemberType findFirst
   */
  export type MemberTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTypes.
     */
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
  }

  /**
   * MemberType findFirstOrThrow
   */
  export type MemberTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberType to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTypes.
     */
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
  }

  /**
   * MemberType findMany
   */
  export type MemberTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter, which MemberTypes to fetch.
     */
    where?: MemberTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTypes to fetch.
     */
    orderBy?: MemberTypeOrderByWithRelationInput | MemberTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberTypes.
     */
    cursor?: MemberTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTypes.
     */
    skip?: number
    distinct?: MemberTypeScalarFieldEnum | MemberTypeScalarFieldEnum[]
  }

  /**
   * MemberType create
   */
  export type MemberTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberType.
     */
    data: XOR<MemberTypeCreateInput, MemberTypeUncheckedCreateInput>
  }

  /**
   * MemberType createMany
   */
  export type MemberTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberTypes.
     */
    data: MemberTypeCreateManyInput | MemberTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberType createManyAndReturn
   */
  export type MemberTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * The data used to create many MemberTypes.
     */
    data: MemberTypeCreateManyInput | MemberTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberType update
   */
  export type MemberTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberType.
     */
    data: XOR<MemberTypeUpdateInput, MemberTypeUncheckedUpdateInput>
    /**
     * Choose, which MemberType to update.
     */
    where: MemberTypeWhereUniqueInput
  }

  /**
   * MemberType updateMany
   */
  export type MemberTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberTypes.
     */
    data: XOR<MemberTypeUpdateManyMutationInput, MemberTypeUncheckedUpdateManyInput>
    /**
     * Filter which MemberTypes to update
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to update.
     */
    limit?: number
  }

  /**
   * MemberType updateManyAndReturn
   */
  export type MemberTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * The data used to update MemberTypes.
     */
    data: XOR<MemberTypeUpdateManyMutationInput, MemberTypeUncheckedUpdateManyInput>
    /**
     * Filter which MemberTypes to update
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to update.
     */
    limit?: number
  }

  /**
   * MemberType upsert
   */
  export type MemberTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberType to update in case it exists.
     */
    where: MemberTypeWhereUniqueInput
    /**
     * In case the MemberType found by the `where` argument doesn't exist, create a new MemberType with this data.
     */
    create: XOR<MemberTypeCreateInput, MemberTypeUncheckedCreateInput>
    /**
     * In case the MemberType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberTypeUpdateInput, MemberTypeUncheckedUpdateInput>
  }

  /**
   * MemberType delete
   */
  export type MemberTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
    /**
     * Filter which MemberType to delete.
     */
    where: MemberTypeWhereUniqueInput
  }

  /**
   * MemberType deleteMany
   */
  export type MemberTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTypes to delete
     */
    where?: MemberTypeWhereInput
    /**
     * Limit how many MemberTypes to delete.
     */
    limit?: number
  }

  /**
   * MemberType.members
   */
  export type MemberType$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * MemberType without action
   */
  export type MemberTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberType
     */
    select?: MemberTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberType
     */
    omit?: MemberTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberTypeInclude<ExtArgs> | null
  }


  /**
   * Model VisitType
   */

  export type AggregateVisitType = {
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  export type VisitTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitType to aggregate.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitTypes
    **/
    _count?: true | VisitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitTypeMaxAggregateInputType
  }

  export type GetVisitTypeAggregateType<T extends VisitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitType[P]>
      : GetScalarType<T[P], AggregateVisitType[P]>
  }




  export type VisitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTypeWhereInput
    orderBy?: VisitTypeOrderByWithAggregationInput | VisitTypeOrderByWithAggregationInput[]
    by: VisitTypeScalarFieldEnum[] | VisitTypeScalarFieldEnum
    having?: VisitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitTypeCountAggregateInputType | true
    _min?: VisitTypeMinAggregateInputType
    _max?: VisitTypeMaxAggregateInputType
  }

  export type VisitTypeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  type GetVisitTypeGroupByPayload<T extends VisitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
        }
      >
    >


  export type VisitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visitors?: boolean | VisitType$visitorsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["visitType"]>
  export type VisitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | VisitType$visitorsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisitTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VisitTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VisitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitType"
    objects: {
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["visitType"]>
    composites: {}
  }

  type VisitTypeGetPayload<S extends boolean | null | undefined | VisitTypeDefaultArgs> = $Result.GetResult<Prisma.$VisitTypePayload, S>

  type VisitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitTypeCountAggregateInputType | true
    }

  export interface VisitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitType'], meta: { name: 'VisitType' } }
    /**
     * Find zero or one VisitType that matches the filter.
     * @param {VisitTypeFindUniqueArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitTypeFindUniqueArgs>(args: SelectSubset<T, VisitTypeFindUniqueArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitTypeFindUniqueOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitTypeFindFirstArgs>(args?: SelectSubset<T, VisitTypeFindFirstArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitTypes
     * const visitTypes = await prisma.visitType.findMany()
     * 
     * // Get first 10 VisitTypes
     * const visitTypes = await prisma.visitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitTypeFindManyArgs>(args?: SelectSubset<T, VisitTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitType.
     * @param {VisitTypeCreateArgs} args - Arguments to create a VisitType.
     * @example
     * // Create one VisitType
     * const VisitType = await prisma.visitType.create({
     *   data: {
     *     // ... data to create a VisitType
     *   }
     * })
     * 
     */
    create<T extends VisitTypeCreateArgs>(args: SelectSubset<T, VisitTypeCreateArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitTypes.
     * @param {VisitTypeCreateManyArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitTypeCreateManyArgs>(args?: SelectSubset<T, VisitTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitTypes and returns the data saved in the database.
     * @param {VisitTypeCreateManyAndReturnArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisitType.
     * @param {VisitTypeDeleteArgs} args - Arguments to delete one VisitType.
     * @example
     * // Delete one VisitType
     * const VisitType = await prisma.visitType.delete({
     *   where: {
     *     // ... filter to delete one VisitType
     *   }
     * })
     * 
     */
    delete<T extends VisitTypeDeleteArgs>(args: SelectSubset<T, VisitTypeDeleteArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitType.
     * @param {VisitTypeUpdateArgs} args - Arguments to update one VisitType.
     * @example
     * // Update one VisitType
     * const visitType = await prisma.visitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitTypeUpdateArgs>(args: SelectSubset<T, VisitTypeUpdateArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitTypes.
     * @param {VisitTypeDeleteManyArgs} args - Arguments to filter VisitTypes to delete.
     * @example
     * // Delete a few VisitTypes
     * const { count } = await prisma.visitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitTypeDeleteManyArgs>(args?: SelectSubset<T, VisitTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitTypeUpdateManyArgs>(args: SelectSubset<T, VisitTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes and returns the data updated in the database.
     * @param {VisitTypeUpdateManyAndReturnArgs} args - Arguments to update many VisitTypes.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisitType.
     * @param {VisitTypeUpsertArgs} args - Arguments to update or create a VisitType.
     * @example
     * // Update or create a VisitType
     * const visitType = await prisma.visitType.upsert({
     *   create: {
     *     // ... data to create a VisitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitType we want to update
     *   }
     * })
     */
    upsert<T extends VisitTypeUpsertArgs>(args: SelectSubset<T, VisitTypeUpsertArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeCountArgs} args - Arguments to filter VisitTypes to count.
     * @example
     * // Count the number of VisitTypes
     * const count = await prisma.visitType.count({
     *   where: {
     *     // ... the filter for the VisitTypes we want to count
     *   }
     * })
    **/
    count<T extends VisitTypeCountArgs>(
      args?: Subset<T, VisitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitTypeAggregateArgs>(args: Subset<T, VisitTypeAggregateArgs>): Prisma.PrismaPromise<GetVisitTypeAggregateType<T>>

    /**
     * Group by VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitTypeGroupByArgs['orderBy'] }
        : { orderBy?: VisitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitType model
   */
  readonly fields: VisitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitors<T extends VisitType$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, VisitType$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitType model
   */
  interface VisitTypeFieldRefs {
    readonly id: FieldRef<"VisitType", 'String'>
    readonly code: FieldRef<"VisitType", 'String'>
    readonly name: FieldRef<"VisitType", 'String'>
    readonly description: FieldRef<"VisitType", 'String'>
    readonly color: FieldRef<"VisitType", 'String'>
    readonly createdAt: FieldRef<"VisitType", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitType findUnique
   */
  export type VisitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findUniqueOrThrow
   */
  export type VisitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findFirst
   */
  export type VisitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findFirstOrThrow
   */
  export type VisitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findMany
   */
  export type VisitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitTypes to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType create
   */
  export type VisitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitType.
     */
    data: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
  }

  /**
   * VisitType createMany
   */
  export type VisitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType createManyAndReturn
   */
  export type VisitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType update
   */
  export type VisitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitType.
     */
    data: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
    /**
     * Choose, which VisitType to update.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType updateMany
   */
  export type VisitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to update.
     */
    limit?: number
  }

  /**
   * VisitType updateManyAndReturn
   */
  export type VisitTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to update.
     */
    limit?: number
  }

  /**
   * VisitType upsert
   */
  export type VisitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitType to update in case it exists.
     */
    where: VisitTypeWhereUniqueInput
    /**
     * In case the VisitType found by the `where` argument doesn't exist, create a new VisitType with this data.
     */
    create: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
    /**
     * In case the VisitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
  }

  /**
   * VisitType delete
   */
  export type VisitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter which VisitType to delete.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType deleteMany
   */
  export type VisitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTypes to delete
     */
    where?: VisitTypeWhereInput
    /**
     * Limit how many VisitTypes to delete.
     */
    limit?: number
  }

  /**
   * VisitType.visitors
   */
  export type VisitType$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * VisitType without action
   */
  export type VisitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitType
     */
    omit?: VisitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
  }


  /**
   * Model BadgeStatus
   */

  export type AggregateBadgeStatus = {
    _count: BadgeStatusCountAggregateOutputType | null
    _min: BadgeStatusMinAggregateOutputType | null
    _max: BadgeStatusMaxAggregateOutputType | null
  }

  export type BadgeStatusMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeStatusMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeStatusCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeStatusMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeStatusMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeStatusCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeStatus to aggregate.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BadgeStatuses
    **/
    _count?: true | BadgeStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeStatusMaxAggregateInputType
  }

  export type GetBadgeStatusAggregateType<T extends BadgeStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateBadgeStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadgeStatus[P]>
      : GetScalarType<T[P], AggregateBadgeStatus[P]>
  }




  export type BadgeStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeStatusWhereInput
    orderBy?: BadgeStatusOrderByWithAggregationInput | BadgeStatusOrderByWithAggregationInput[]
    by: BadgeStatusScalarFieldEnum[] | BadgeStatusScalarFieldEnum
    having?: BadgeStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeStatusCountAggregateInputType | true
    _min?: BadgeStatusMinAggregateInputType
    _max?: BadgeStatusMaxAggregateInputType
  }

  export type BadgeStatusGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BadgeStatusCountAggregateOutputType | null
    _min: BadgeStatusMinAggregateOutputType | null
    _max: BadgeStatusMaxAggregateOutputType | null
  }

  type GetBadgeStatusGroupByPayload<T extends BadgeStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeStatusGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeStatusGroupByOutputType[P]>
        }
      >
    >


  export type BadgeStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badges?: boolean | BadgeStatus$badgesArgs<ExtArgs>
    _count?: boolean | BadgeStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeStatus"]>

  export type BadgeStatusSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["badgeStatus"]>
  export type BadgeStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeStatus$badgesArgs<ExtArgs>
    _count?: boolean | BadgeStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgeStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BadgeStatus"
    objects: {
      badges: Prisma.$BadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["badgeStatus"]>
    composites: {}
  }

  type BadgeStatusGetPayload<S extends boolean | null | undefined | BadgeStatusDefaultArgs> = $Result.GetResult<Prisma.$BadgeStatusPayload, S>

  type BadgeStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeStatusCountAggregateInputType | true
    }

  export interface BadgeStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BadgeStatus'], meta: { name: 'BadgeStatus' } }
    /**
     * Find zero or one BadgeStatus that matches the filter.
     * @param {BadgeStatusFindUniqueArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeStatusFindUniqueArgs>(args: SelectSubset<T, BadgeStatusFindUniqueArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BadgeStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeStatusFindUniqueOrThrowArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindFirstArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeStatusFindFirstArgs>(args?: SelectSubset<T, BadgeStatusFindFirstArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindFirstOrThrowArgs} args - Arguments to find a BadgeStatus
     * @example
     * // Get one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BadgeStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BadgeStatuses
     * const badgeStatuses = await prisma.badgeStatus.findMany()
     * 
     * // Get first 10 BadgeStatuses
     * const badgeStatuses = await prisma.badgeStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeStatusFindManyArgs>(args?: SelectSubset<T, BadgeStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BadgeStatus.
     * @param {BadgeStatusCreateArgs} args - Arguments to create a BadgeStatus.
     * @example
     * // Create one BadgeStatus
     * const BadgeStatus = await prisma.badgeStatus.create({
     *   data: {
     *     // ... data to create a BadgeStatus
     *   }
     * })
     * 
     */
    create<T extends BadgeStatusCreateArgs>(args: SelectSubset<T, BadgeStatusCreateArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BadgeStatuses.
     * @param {BadgeStatusCreateManyArgs} args - Arguments to create many BadgeStatuses.
     * @example
     * // Create many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeStatusCreateManyArgs>(args?: SelectSubset<T, BadgeStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BadgeStatuses and returns the data saved in the database.
     * @param {BadgeStatusCreateManyAndReturnArgs} args - Arguments to create many BadgeStatuses.
     * @example
     * // Create many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BadgeStatuses and only return the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BadgeStatus.
     * @param {BadgeStatusDeleteArgs} args - Arguments to delete one BadgeStatus.
     * @example
     * // Delete one BadgeStatus
     * const BadgeStatus = await prisma.badgeStatus.delete({
     *   where: {
     *     // ... filter to delete one BadgeStatus
     *   }
     * })
     * 
     */
    delete<T extends BadgeStatusDeleteArgs>(args: SelectSubset<T, BadgeStatusDeleteArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BadgeStatus.
     * @param {BadgeStatusUpdateArgs} args - Arguments to update one BadgeStatus.
     * @example
     * // Update one BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeStatusUpdateArgs>(args: SelectSubset<T, BadgeStatusUpdateArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BadgeStatuses.
     * @param {BadgeStatusDeleteManyArgs} args - Arguments to filter BadgeStatuses to delete.
     * @example
     * // Delete a few BadgeStatuses
     * const { count } = await prisma.badgeStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeStatusDeleteManyArgs>(args?: SelectSubset<T, BadgeStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeStatusUpdateManyArgs>(args: SelectSubset<T, BadgeStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeStatuses and returns the data updated in the database.
     * @param {BadgeStatusUpdateManyAndReturnArgs} args - Arguments to update many BadgeStatuses.
     * @example
     * // Update many BadgeStatuses
     * const badgeStatus = await prisma.badgeStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BadgeStatuses and only return the `id`
     * const badgeStatusWithIdOnly = await prisma.badgeStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BadgeStatus.
     * @param {BadgeStatusUpsertArgs} args - Arguments to update or create a BadgeStatus.
     * @example
     * // Update or create a BadgeStatus
     * const badgeStatus = await prisma.badgeStatus.upsert({
     *   create: {
     *     // ... data to create a BadgeStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BadgeStatus we want to update
     *   }
     * })
     */
    upsert<T extends BadgeStatusUpsertArgs>(args: SelectSubset<T, BadgeStatusUpsertArgs<ExtArgs>>): Prisma__BadgeStatusClient<$Result.GetResult<Prisma.$BadgeStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BadgeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusCountArgs} args - Arguments to filter BadgeStatuses to count.
     * @example
     * // Count the number of BadgeStatuses
     * const count = await prisma.badgeStatus.count({
     *   where: {
     *     // ... the filter for the BadgeStatuses we want to count
     *   }
     * })
    **/
    count<T extends BadgeStatusCountArgs>(
      args?: Subset<T, BadgeStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BadgeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeStatusAggregateArgs>(args: Subset<T, BadgeStatusAggregateArgs>): Prisma.PrismaPromise<GetBadgeStatusAggregateType<T>>

    /**
     * Group by BadgeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeStatusGroupByArgs['orderBy'] }
        : { orderBy?: BadgeStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BadgeStatus model
   */
  readonly fields: BadgeStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BadgeStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends BadgeStatus$badgesArgs<ExtArgs> = {}>(args?: Subset<T, BadgeStatus$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BadgeStatus model
   */
  interface BadgeStatusFieldRefs {
    readonly id: FieldRef<"BadgeStatus", 'String'>
    readonly code: FieldRef<"BadgeStatus", 'String'>
    readonly name: FieldRef<"BadgeStatus", 'String'>
    readonly description: FieldRef<"BadgeStatus", 'String'>
    readonly color: FieldRef<"BadgeStatus", 'String'>
    readonly createdAt: FieldRef<"BadgeStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"BadgeStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BadgeStatus findUnique
   */
  export type BadgeStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where: BadgeStatusWhereUniqueInput
  }

  /**
   * BadgeStatus findUniqueOrThrow
   */
  export type BadgeStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where: BadgeStatusWhereUniqueInput
  }

  /**
   * BadgeStatus findFirst
   */
  export type BadgeStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeStatuses.
     */
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
  }

  /**
   * BadgeStatus findFirstOrThrow
   */
  export type BadgeStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatus to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeStatuses.
     */
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
  }

  /**
   * BadgeStatus findMany
   */
  export type BadgeStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter, which BadgeStatuses to fetch.
     */
    where?: BadgeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeStatuses to fetch.
     */
    orderBy?: BadgeStatusOrderByWithRelationInput | BadgeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BadgeStatuses.
     */
    cursor?: BadgeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeStatuses.
     */
    skip?: number
    distinct?: BadgeStatusScalarFieldEnum | BadgeStatusScalarFieldEnum[]
  }

  /**
   * BadgeStatus create
   */
  export type BadgeStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a BadgeStatus.
     */
    data: XOR<BadgeStatusCreateInput, BadgeStatusUncheckedCreateInput>
  }

  /**
   * BadgeStatus createMany
   */
  export type BadgeStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BadgeStatuses.
     */
    data: BadgeStatusCreateManyInput | BadgeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeStatus createManyAndReturn
   */
  export type BadgeStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * The data used to create many BadgeStatuses.
     */
    data: BadgeStatusCreateManyInput | BadgeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeStatus update
   */
  export type BadgeStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a BadgeStatus.
     */
    data: XOR<BadgeStatusUpdateInput, BadgeStatusUncheckedUpdateInput>
    /**
     * Choose, which BadgeStatus to update.
     */
    where: BadgeStatusWhereUniqueInput
  }

  /**
   * BadgeStatus updateMany
   */
  export type BadgeStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BadgeStatuses.
     */
    data: XOR<BadgeStatusUpdateManyMutationInput, BadgeStatusUncheckedUpdateManyInput>
    /**
     * Filter which BadgeStatuses to update
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to update.
     */
    limit?: number
  }

  /**
   * BadgeStatus updateManyAndReturn
   */
  export type BadgeStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * The data used to update BadgeStatuses.
     */
    data: XOR<BadgeStatusUpdateManyMutationInput, BadgeStatusUncheckedUpdateManyInput>
    /**
     * Filter which BadgeStatuses to update
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to update.
     */
    limit?: number
  }

  /**
   * BadgeStatus upsert
   */
  export type BadgeStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the BadgeStatus to update in case it exists.
     */
    where: BadgeStatusWhereUniqueInput
    /**
     * In case the BadgeStatus found by the `where` argument doesn't exist, create a new BadgeStatus with this data.
     */
    create: XOR<BadgeStatusCreateInput, BadgeStatusUncheckedCreateInput>
    /**
     * In case the BadgeStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeStatusUpdateInput, BadgeStatusUncheckedUpdateInput>
  }

  /**
   * BadgeStatus delete
   */
  export type BadgeStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
    /**
     * Filter which BadgeStatus to delete.
     */
    where: BadgeStatusWhereUniqueInput
  }

  /**
   * BadgeStatus deleteMany
   */
  export type BadgeStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeStatuses to delete
     */
    where?: BadgeStatusWhereInput
    /**
     * Limit how many BadgeStatuses to delete.
     */
    limit?: number
  }

  /**
   * BadgeStatus.badges
   */
  export type BadgeStatus$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * BadgeStatus without action
   */
  export type BadgeStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeStatus
     */
    select?: BadgeStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeStatus
     */
    omit?: BadgeStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeStatusInclude<ExtArgs> | null
  }


  /**
   * Model ListItem
   */

  export type AggregateListItem = {
    _count: ListItemCountAggregateOutputType | null
    _avg: ListItemAvgAggregateOutputType | null
    _sum: ListItemSumAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  export type ListItemAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ListItemSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ListItemMinAggregateOutputType = {
    id: string | null
    listType: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListItemMaxAggregateOutputType = {
    id: string | null
    listType: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListItemCountAggregateOutputType = {
    id: number
    listType: number
    code: number
    name: number
    displayOrder: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListItemAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ListItemSumAggregateInputType = {
    displayOrder?: true
  }

  export type ListItemMinAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListItemMaxAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListItemCountAggregateInputType = {
    id?: true
    listType?: true
    code?: true
    name?: true
    displayOrder?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItem to aggregate.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListItems
    **/
    _count?: true | ListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListItemMaxAggregateInputType
  }

  export type GetListItemAggregateType<T extends ListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListItem[P]>
      : GetScalarType<T[P], AggregateListItem[P]>
  }




  export type ListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListItemWhereInput
    orderBy?: ListItemOrderByWithAggregationInput | ListItemOrderByWithAggregationInput[]
    by: ListItemScalarFieldEnum[] | ListItemScalarFieldEnum
    having?: ListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListItemCountAggregateInputType | true
    _avg?: ListItemAvgAggregateInputType
    _sum?: ListItemSumAggregateInputType
    _min?: ListItemMinAggregateInputType
    _max?: ListItemMaxAggregateInputType
  }

  export type ListItemGroupByOutputType = {
    id: string
    listType: string
    code: string
    name: string
    displayOrder: number
    description: string | null
    isSystem: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: ListItemCountAggregateOutputType | null
    _avg: ListItemAvgAggregateOutputType | null
    _sum: ListItemSumAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  type GetListItemGroupByPayload<T extends ListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListItemGroupByOutputType[P]>
            : GetScalarType<T[P], ListItemGroupByOutputType[P]>
        }
      >
    >


  export type ListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectScalar = {
    id?: boolean
    listType?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listType" | "code" | "name" | "displayOrder" | "description" | "isSystem" | "createdAt" | "updatedAt", ExtArgs["result"]["listItem"]>

  export type $ListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listType: string
      code: string
      name: string
      displayOrder: number
      description: string | null
      isSystem: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["listItem"]>
    composites: {}
  }

  type ListItemGetPayload<S extends boolean | null | undefined | ListItemDefaultArgs> = $Result.GetResult<Prisma.$ListItemPayload, S>

  type ListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListItemCountAggregateInputType | true
    }

  export interface ListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListItem'], meta: { name: 'ListItem' } }
    /**
     * Find zero or one ListItem that matches the filter.
     * @param {ListItemFindUniqueArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListItemFindUniqueArgs>(args: SelectSubset<T, ListItemFindUniqueArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListItemFindUniqueOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListItemFindFirstArgs>(args?: SelectSubset<T, ListItemFindFirstArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListItems
     * const listItems = await prisma.listItem.findMany()
     * 
     * // Get first 10 ListItems
     * const listItems = await prisma.listItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listItemWithIdOnly = await prisma.listItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListItemFindManyArgs>(args?: SelectSubset<T, ListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListItem.
     * @param {ListItemCreateArgs} args - Arguments to create a ListItem.
     * @example
     * // Create one ListItem
     * const ListItem = await prisma.listItem.create({
     *   data: {
     *     // ... data to create a ListItem
     *   }
     * })
     * 
     */
    create<T extends ListItemCreateArgs>(args: SelectSubset<T, ListItemCreateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListItems.
     * @param {ListItemCreateManyArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListItemCreateManyArgs>(args?: SelectSubset<T, ListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListItems and returns the data saved in the database.
     * @param {ListItemCreateManyAndReturnArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ListItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListItem.
     * @param {ListItemDeleteArgs} args - Arguments to delete one ListItem.
     * @example
     * // Delete one ListItem
     * const ListItem = await prisma.listItem.delete({
     *   where: {
     *     // ... filter to delete one ListItem
     *   }
     * })
     * 
     */
    delete<T extends ListItemDeleteArgs>(args: SelectSubset<T, ListItemDeleteArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListItem.
     * @param {ListItemUpdateArgs} args - Arguments to update one ListItem.
     * @example
     * // Update one ListItem
     * const listItem = await prisma.listItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListItemUpdateArgs>(args: SelectSubset<T, ListItemUpdateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListItems.
     * @param {ListItemDeleteManyArgs} args - Arguments to filter ListItems to delete.
     * @example
     * // Delete a few ListItems
     * const { count } = await prisma.listItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListItemDeleteManyArgs>(args?: SelectSubset<T, ListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListItemUpdateManyArgs>(args: SelectSubset<T, ListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems and returns the data updated in the database.
     * @param {ListItemUpdateManyAndReturnArgs} args - Arguments to update many ListItems.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ListItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListItem.
     * @param {ListItemUpsertArgs} args - Arguments to update or create a ListItem.
     * @example
     * // Update or create a ListItem
     * const listItem = await prisma.listItem.upsert({
     *   create: {
     *     // ... data to create a ListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListItem we want to update
     *   }
     * })
     */
    upsert<T extends ListItemUpsertArgs>(args: SelectSubset<T, ListItemUpsertArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemCountArgs} args - Arguments to filter ListItems to count.
     * @example
     * // Count the number of ListItems
     * const count = await prisma.listItem.count({
     *   where: {
     *     // ... the filter for the ListItems we want to count
     *   }
     * })
    **/
    count<T extends ListItemCountArgs>(
      args?: Subset<T, ListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListItemAggregateArgs>(args: Subset<T, ListItemAggregateArgs>): Prisma.PrismaPromise<GetListItemAggregateType<T>>

    /**
     * Group by ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListItemGroupByArgs['orderBy'] }
        : { orderBy?: ListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListItem model
   */
  readonly fields: ListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListItem model
   */
  interface ListItemFieldRefs {
    readonly id: FieldRef<"ListItem", 'String'>
    readonly listType: FieldRef<"ListItem", 'String'>
    readonly code: FieldRef<"ListItem", 'String'>
    readonly name: FieldRef<"ListItem", 'String'>
    readonly displayOrder: FieldRef<"ListItem", 'Int'>
    readonly description: FieldRef<"ListItem", 'String'>
    readonly isSystem: FieldRef<"ListItem", 'Boolean'>
    readonly createdAt: FieldRef<"ListItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ListItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListItem findUnique
   */
  export type ListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem findUniqueOrThrow
   */
  export type ListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem findFirst
   */
  export type ListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem findFirstOrThrow
   */
  export type ListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem findMany
   */
  export type ListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter, which ListItems to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem create
   */
  export type ListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data needed to create a ListItem.
     */
    data: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
  }

  /**
   * ListItem createMany
   */
  export type ListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListItem createManyAndReturn
   */
  export type ListItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListItem update
   */
  export type ListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data needed to update a ListItem.
     */
    data: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
    /**
     * Choose, which ListItem to update.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem updateMany
   */
  export type ListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
  }

  /**
   * ListItem updateManyAndReturn
   */
  export type ListItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
  }

  /**
   * ListItem upsert
   */
  export type ListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The filter to search for the ListItem to update in case it exists.
     */
    where: ListItemWhereUniqueInput
    /**
     * In case the ListItem found by the `where` argument doesn't exist, create a new ListItem with this data.
     */
    create: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
    /**
     * In case the ListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
  }

  /**
   * ListItem delete
   */
  export type ListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Filter which ListItem to delete.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem deleteMany
   */
  export type ListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItems to delete
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to delete.
     */
    limit?: number
  }

  /**
   * ListItem without action
   */
  export type ListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    role: string | null
    badgeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    role: string | null
    badgeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    name: number
    image: number
    role: number
    badgeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    role?: true
    badgeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: boolean
    name: string | null
    image: string | null
    role: string
    badgeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    badgeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "name" | "image" | "role" | "badgeId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: boolean
      name: string | null
      image: string | null
      role: string
      badgeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly badgeId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    expiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "expiresAt" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      expiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'Json'>
    readonly category: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model AlertConfig
   */

  export type AggregateAlertConfig = {
    _count: AlertConfigCountAggregateOutputType | null
    _min: AlertConfigMinAggregateOutputType | null
    _max: AlertConfigMaxAggregateOutputType | null
  }

  export type AlertConfigMinAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type AlertConfigMaxAggregateOutputType = {
    key: string | null
    updatedAt: Date | null
  }

  export type AlertConfigCountAggregateOutputType = {
    key: number
    config: number
    updatedAt: number
    _all: number
  }


  export type AlertConfigMinAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type AlertConfigMaxAggregateInputType = {
    key?: true
    updatedAt?: true
  }

  export type AlertConfigCountAggregateInputType = {
    key?: true
    config?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertConfig to aggregate.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertConfigs
    **/
    _count?: true | AlertConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertConfigMaxAggregateInputType
  }

  export type GetAlertConfigAggregateType<T extends AlertConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertConfig[P]>
      : GetScalarType<T[P], AggregateAlertConfig[P]>
  }




  export type AlertConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertConfigWhereInput
    orderBy?: AlertConfigOrderByWithAggregationInput | AlertConfigOrderByWithAggregationInput[]
    by: AlertConfigScalarFieldEnum[] | AlertConfigScalarFieldEnum
    having?: AlertConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertConfigCountAggregateInputType | true
    _min?: AlertConfigMinAggregateInputType
    _max?: AlertConfigMaxAggregateInputType
  }

  export type AlertConfigGroupByOutputType = {
    key: string
    config: JsonValue
    updatedAt: Date
    _count: AlertConfigCountAggregateOutputType | null
    _min: AlertConfigMinAggregateOutputType | null
    _max: AlertConfigMaxAggregateOutputType | null
  }

  type GetAlertConfigGroupByPayload<T extends AlertConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AlertConfigGroupByOutputType[P]>
        }
      >
    >


  export type AlertConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertConfig"]>

  export type AlertConfigSelectScalar = {
    key?: boolean
    config?: boolean
    updatedAt?: boolean
  }

  export type AlertConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "config" | "updatedAt", ExtArgs["result"]["alertConfig"]>

  export type $AlertConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      config: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["alertConfig"]>
    composites: {}
  }

  type AlertConfigGetPayload<S extends boolean | null | undefined | AlertConfigDefaultArgs> = $Result.GetResult<Prisma.$AlertConfigPayload, S>

  type AlertConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertConfigCountAggregateInputType | true
    }

  export interface AlertConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertConfig'], meta: { name: 'AlertConfig' } }
    /**
     * Find zero or one AlertConfig that matches the filter.
     * @param {AlertConfigFindUniqueArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertConfigFindUniqueArgs>(args: SelectSubset<T, AlertConfigFindUniqueArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlertConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertConfigFindUniqueOrThrowArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindFirstArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertConfigFindFirstArgs>(args?: SelectSubset<T, AlertConfigFindFirstArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindFirstOrThrowArgs} args - Arguments to find a AlertConfig
     * @example
     * // Get one AlertConfig
     * const alertConfig = await prisma.alertConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlertConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertConfigs
     * const alertConfigs = await prisma.alertConfig.findMany()
     * 
     * // Get first 10 AlertConfigs
     * const alertConfigs = await prisma.alertConfig.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends AlertConfigFindManyArgs>(args?: SelectSubset<T, AlertConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlertConfig.
     * @param {AlertConfigCreateArgs} args - Arguments to create a AlertConfig.
     * @example
     * // Create one AlertConfig
     * const AlertConfig = await prisma.alertConfig.create({
     *   data: {
     *     // ... data to create a AlertConfig
     *   }
     * })
     * 
     */
    create<T extends AlertConfigCreateArgs>(args: SelectSubset<T, AlertConfigCreateArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlertConfigs.
     * @param {AlertConfigCreateManyArgs} args - Arguments to create many AlertConfigs.
     * @example
     * // Create many AlertConfigs
     * const alertConfig = await prisma.alertConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertConfigCreateManyArgs>(args?: SelectSubset<T, AlertConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertConfigs and returns the data saved in the database.
     * @param {AlertConfigCreateManyAndReturnArgs} args - Arguments to create many AlertConfigs.
     * @example
     * // Create many AlertConfigs
     * const alertConfig = await prisma.alertConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertConfigs and only return the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlertConfig.
     * @param {AlertConfigDeleteArgs} args - Arguments to delete one AlertConfig.
     * @example
     * // Delete one AlertConfig
     * const AlertConfig = await prisma.alertConfig.delete({
     *   where: {
     *     // ... filter to delete one AlertConfig
     *   }
     * })
     * 
     */
    delete<T extends AlertConfigDeleteArgs>(args: SelectSubset<T, AlertConfigDeleteArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlertConfig.
     * @param {AlertConfigUpdateArgs} args - Arguments to update one AlertConfig.
     * @example
     * // Update one AlertConfig
     * const alertConfig = await prisma.alertConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertConfigUpdateArgs>(args: SelectSubset<T, AlertConfigUpdateArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlertConfigs.
     * @param {AlertConfigDeleteManyArgs} args - Arguments to filter AlertConfigs to delete.
     * @example
     * // Delete a few AlertConfigs
     * const { count } = await prisma.alertConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertConfigDeleteManyArgs>(args?: SelectSubset<T, AlertConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertConfigs
     * const alertConfig = await prisma.alertConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertConfigUpdateManyArgs>(args: SelectSubset<T, AlertConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConfigs and returns the data updated in the database.
     * @param {AlertConfigUpdateManyAndReturnArgs} args - Arguments to update many AlertConfigs.
     * @example
     * // Update many AlertConfigs
     * const alertConfig = await prisma.alertConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertConfigs and only return the `key`
     * const alertConfigWithKeyOnly = await prisma.alertConfig.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlertConfig.
     * @param {AlertConfigUpsertArgs} args - Arguments to update or create a AlertConfig.
     * @example
     * // Update or create a AlertConfig
     * const alertConfig = await prisma.alertConfig.upsert({
     *   create: {
     *     // ... data to create a AlertConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertConfig we want to update
     *   }
     * })
     */
    upsert<T extends AlertConfigUpsertArgs>(args: SelectSubset<T, AlertConfigUpsertArgs<ExtArgs>>): Prisma__AlertConfigClient<$Result.GetResult<Prisma.$AlertConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlertConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigCountArgs} args - Arguments to filter AlertConfigs to count.
     * @example
     * // Count the number of AlertConfigs
     * const count = await prisma.alertConfig.count({
     *   where: {
     *     // ... the filter for the AlertConfigs we want to count
     *   }
     * })
    **/
    count<T extends AlertConfigCountArgs>(
      args?: Subset<T, AlertConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertConfigAggregateArgs>(args: Subset<T, AlertConfigAggregateArgs>): Prisma.PrismaPromise<GetAlertConfigAggregateType<T>>

    /**
     * Group by AlertConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertConfigGroupByArgs['orderBy'] }
        : { orderBy?: AlertConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertConfig model
   */
  readonly fields: AlertConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertConfig model
   */
  interface AlertConfigFieldRefs {
    readonly key: FieldRef<"AlertConfig", 'String'>
    readonly config: FieldRef<"AlertConfig", 'Json'>
    readonly updatedAt: FieldRef<"AlertConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertConfig findUnique
   */
  export type AlertConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where: AlertConfigWhereUniqueInput
  }

  /**
   * AlertConfig findUniqueOrThrow
   */
  export type AlertConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where: AlertConfigWhereUniqueInput
  }

  /**
   * AlertConfig findFirst
   */
  export type AlertConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConfigs.
     */
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
  }

  /**
   * AlertConfig findFirstOrThrow
   */
  export type AlertConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfig to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConfigs.
     */
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
  }

  /**
   * AlertConfig findMany
   */
  export type AlertConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter, which AlertConfigs to fetch.
     */
    where?: AlertConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConfigs to fetch.
     */
    orderBy?: AlertConfigOrderByWithRelationInput | AlertConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertConfigs.
     */
    cursor?: AlertConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConfigs.
     */
    skip?: number
    distinct?: AlertConfigScalarFieldEnum | AlertConfigScalarFieldEnum[]
  }

  /**
   * AlertConfig create
   */
  export type AlertConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AlertConfig.
     */
    data: XOR<AlertConfigCreateInput, AlertConfigUncheckedCreateInput>
  }

  /**
   * AlertConfig createMany
   */
  export type AlertConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertConfigs.
     */
    data: AlertConfigCreateManyInput | AlertConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertConfig createManyAndReturn
   */
  export type AlertConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AlertConfigs.
     */
    data: AlertConfigCreateManyInput | AlertConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertConfig update
   */
  export type AlertConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AlertConfig.
     */
    data: XOR<AlertConfigUpdateInput, AlertConfigUncheckedUpdateInput>
    /**
     * Choose, which AlertConfig to update.
     */
    where: AlertConfigWhereUniqueInput
  }

  /**
   * AlertConfig updateMany
   */
  export type AlertConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertConfigs.
     */
    data: XOR<AlertConfigUpdateManyMutationInput, AlertConfigUncheckedUpdateManyInput>
    /**
     * Filter which AlertConfigs to update
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to update.
     */
    limit?: number
  }

  /**
   * AlertConfig updateManyAndReturn
   */
  export type AlertConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The data used to update AlertConfigs.
     */
    data: XOR<AlertConfigUpdateManyMutationInput, AlertConfigUncheckedUpdateManyInput>
    /**
     * Filter which AlertConfigs to update
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to update.
     */
    limit?: number
  }

  /**
   * AlertConfig upsert
   */
  export type AlertConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AlertConfig to update in case it exists.
     */
    where: AlertConfigWhereUniqueInput
    /**
     * In case the AlertConfig found by the `where` argument doesn't exist, create a new AlertConfig with this data.
     */
    create: XOR<AlertConfigCreateInput, AlertConfigUncheckedCreateInput>
    /**
     * In case the AlertConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertConfigUpdateInput, AlertConfigUncheckedUpdateInput>
  }

  /**
   * AlertConfig delete
   */
  export type AlertConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
    /**
     * Filter which AlertConfig to delete.
     */
    where: AlertConfigWhereUniqueInput
  }

  /**
   * AlertConfig deleteMany
   */
  export type AlertConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertConfigs to delete
     */
    where?: AlertConfigWhereInput
    /**
     * Limit how many AlertConfigs to delete.
     */
    limit?: number
  }

  /**
   * AlertConfig without action
   */
  export type AlertConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConfig
     */
    select?: AlertConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertConfig
     */
    omit?: AlertConfigOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    fullName: 'fullName',
    role: 'role',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    first_name: 'first_name',
    last_name: 'last_name',
    updated_at: 'updated_at',
    disabled: 'disabled',
    disabledAt: 'disabledAt',
    disabledBy: 'disabledBy',
    updatedBy: 'updatedBy'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    adminUserId: 'adminUserId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    assignmentType: 'assignmentType',
    assignedToId: 'assignedToId',
    status: 'status',
    badgeStatusId: 'badgeStatusId',
    lastUsed: 'lastUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CheckinScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    badgeId: 'badgeId',
    direction: 'direction',
    timestamp: 'timestamp',
    kioskId: 'kioskId',
    synced: 'synced',
    createdAt: 'createdAt',
    flagged_for_review: 'flagged_for_review',
    flag_reason: 'flag_reason',
    method: 'method',
    created_by_admin: 'created_by_admin'
  };

  export type CheckinScalarFieldEnum = (typeof CheckinScalarFieldEnum)[keyof typeof CheckinScalarFieldEnum]


  export const DivisionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DivisionScalarFieldEnum = (typeof DivisionScalarFieldEnum)[keyof typeof DivisionScalarFieldEnum]


  export const EventAttendeeScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    rank: 'rank',
    organization: 'organization',
    role: 'role',
    badgeId: 'badgeId',
    badgeAssignedAt: 'badgeAssignedAt',
    accessStart: 'accessStart',
    accessEnd: 'accessEnd',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventAttendeeScalarFieldEnum = (typeof EventAttendeeScalarFieldEnum)[keyof typeof EventAttendeeScalarFieldEnum]


  export const EventCheckinScalarFieldEnum: {
    id: 'id',
    eventAttendeeId: 'eventAttendeeId',
    badgeId: 'badgeId',
    direction: 'direction',
    timestamp: 'timestamp',
    kioskId: 'kioskId',
    createdAt: 'createdAt'
  };

  export type EventCheckinScalarFieldEnum = (typeof EventCheckinScalarFieldEnum)[keyof typeof EventCheckinScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    autoExpireBadges: 'autoExpireBadges',
    customRoles: 'customRoles',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    serviceNumber: 'serviceNumber',
    rank: 'rank',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    mobilePhone: 'mobilePhone',
    divisionId: 'divisionId',
    badgeId: 'badgeId',
    memberType: 'memberType',
    status: 'status',
    memberTypeId: 'memberTypeId',
    memberStatusId: 'memberStatusId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employeeNumber: 'employeeNumber',
    initials: 'initials',
    mess: 'mess',
    moc: 'moc',
    classDetails: 'classDetails',
    homePhone: 'homePhone',
    notes: 'notes',
    contract_start: 'contract_start',
    contract_end: 'contract_end'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    description: 'description',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const MemberTagScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type MemberTagScalarFieldEnum = (typeof MemberTagScalarFieldEnum)[keyof typeof MemberTagScalarFieldEnum]


  export const SecurityAlertScalarFieldEnum: {
    id: 'id',
    alertType: 'alertType',
    severity: 'severity',
    badgeSerial: 'badgeSerial',
    memberId: 'memberId',
    kioskId: 'kioskId',
    message: 'message',
    details: 'details',
    status: 'status',
    acknowledgedBy: 'acknowledgedBy',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgeNote: 'acknowledgeNote',
    createdAt: 'createdAt'
  };

  export type SecurityAlertScalarFieldEnum = (typeof SecurityAlertScalarFieldEnum)[keyof typeof SecurityAlertScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organization: 'organization',
    visitType: 'visitType',
    visitTypeId: 'visitTypeId',
    visitReason: 'visitReason',
    eventId: 'eventId',
    hostMemberId: 'hostMemberId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    temporaryBadgeId: 'temporaryBadgeId',
    kioskId: 'kioskId',
    createdAt: 'createdAt',
    adminNotes: 'adminNotes',
    checkInMethod: 'checkInMethod',
    createdByAdmin: 'createdByAdmin'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const BmqCourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    trainingStartTime: 'trainingStartTime',
    trainingEndTime: 'trainingEndTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    trainingDays: 'trainingDays'
  };

  export type BmqCourseScalarFieldEnum = (typeof BmqCourseScalarFieldEnum)[keyof typeof BmqCourseScalarFieldEnum]


  export const BmqEnrollmentScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    bmqCourseId: 'bmqCourseId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    status: 'status'
  };

  export type BmqEnrollmentScalarFieldEnum = (typeof BmqEnrollmentScalarFieldEnum)[keyof typeof BmqEnrollmentScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    applied_at: 'applied_at'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const Report_audit_logScalarFieldEnum: {
    id: 'id',
    report_type: 'report_type',
    report_config: 'report_config',
    generated_by: 'generated_by',
    is_scheduled: 'is_scheduled',
    scheduled_report_id: 'scheduled_report_id',
    generated_at: 'generated_at',
    file_size_bytes: 'file_size_bytes',
    generation_time_ms: 'generation_time_ms'
  };

  export type Report_audit_logScalarFieldEnum = (typeof Report_audit_logScalarFieldEnum)[keyof typeof Report_audit_logScalarFieldEnum]


  export const ReportSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type ReportSettingScalarFieldEnum = (typeof ReportSettingScalarFieldEnum)[keyof typeof ReportSettingScalarFieldEnum]


  export const TrainingYearScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    holidayExclusions: 'holidayExclusions',
    dayExceptions: 'dayExceptions',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingYearScalarFieldEnum = (typeof TrainingYearScalarFieldEnum)[keyof typeof TrainingYearScalarFieldEnum]


  export const DdsAssignmentScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    assignedDate: 'assignedDate',
    acceptedAt: 'acceptedAt',
    releasedAt: 'releasedAt',
    transferredTo: 'transferredTo',
    assignedBy: 'assignedBy',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DdsAssignmentScalarFieldEnum = (typeof DdsAssignmentScalarFieldEnum)[keyof typeof DdsAssignmentScalarFieldEnum]


  export const ResponsibilityAuditLogScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    tagName: 'tagName',
    action: 'action',
    fromMemberId: 'fromMemberId',
    toMemberId: 'toMemberId',
    performedBy: 'performedBy',
    performedByType: 'performedByType',
    timestamp: 'timestamp',
    notes: 'notes'
  };

  export type ResponsibilityAuditLogScalarFieldEnum = (typeof ResponsibilityAuditLogScalarFieldEnum)[keyof typeof ResponsibilityAuditLogScalarFieldEnum]


  export const MemberStatusScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberStatusScalarFieldEnum = (typeof MemberStatusScalarFieldEnum)[keyof typeof MemberStatusScalarFieldEnum]


  export const MemberTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberTypeScalarFieldEnum = (typeof MemberTypeScalarFieldEnum)[keyof typeof MemberTypeScalarFieldEnum]


  export const VisitTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitTypeScalarFieldEnum = (typeof VisitTypeScalarFieldEnum)[keyof typeof VisitTypeScalarFieldEnum]


  export const BadgeStatusScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeStatusScalarFieldEnum = (typeof BadgeStatusScalarFieldEnum)[keyof typeof BadgeStatusScalarFieldEnum]


  export const ListItemScalarFieldEnum: {
    id: 'id',
    listType: 'listType',
    code: 'code',
    name: 'name',
    displayOrder: 'displayOrder',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListItemScalarFieldEnum = (typeof ListItemScalarFieldEnum)[keyof typeof ListItemScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    image: 'image',
    role: 'role',
    badgeId: 'badgeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    expiresAt: 'expiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const AlertConfigScalarFieldEnum: {
    key: 'key',
    config: 'config',
    updatedAt: 'updatedAt'
  };

  export type AlertConfigScalarFieldEnum = (typeof AlertConfigScalarFieldEnum)[keyof typeof AlertConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: UuidFilter<"AdminUser"> | string
    username?: StringFilter<"AdminUser"> | string
    email?: StringNullableFilter<"AdminUser"> | string | null
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckinListRelationFilter
    report_audit_log?: Report_audit_logListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    visitors?: VisitorListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    disabledByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    updatedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    disabledUsers?: AdminUserListRelationFilter
    updatedUsers?: AdminUserListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    checkins?: CheckinOrderByRelationAggregateInput
    report_audit_log?: report_audit_logOrderByRelationAggregateInput
    securityAlerts?: SecurityAlertOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    ddsAssignments?: DdsAssignmentOrderByRelationAggregateInput
    disabledByAdmin?: AdminUserOrderByWithRelationInput
    updatedByAdmin?: AdminUserOrderByWithRelationInput
    disabledUsers?: AdminUserOrderByRelationAggregateInput
    updatedUsers?: AdminUserOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckinListRelationFilter
    report_audit_log?: Report_audit_logListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    visitors?: VisitorListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    disabledByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    updatedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    disabledUsers?: AdminUserListRelationFilter
    updatedUsers?: AdminUserListRelationFilter
  }, "id" | "username" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdminUser"> | string
    username?: StringWithAggregatesFilter<"AdminUser"> | string
    email?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    passwordHash?: StringWithAggregatesFilter<"AdminUser"> | string
    displayName?: StringWithAggregatesFilter<"AdminUser"> | string
    fullName?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    role?: StringWithAggregatesFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    disabled?: BoolWithAggregatesFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableWithAggregatesFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"AdminUser"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    adminUser?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminUser?: AdminUserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    adminUser?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    adminUserId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AuditLog"> | Date | string | null
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: UuidFilter<"Badge"> | string
    serialNumber?: StringFilter<"Badge"> | string
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    checkins?: CheckinListRelationFilter
    eventAttendees?: EventAttendeeListRelationFilter
    eventCheckins?: EventCheckinListRelationFilter
    members?: MemberListRelationFilter
    visitors?: VisitorListRelationFilter
    badgeStatusRef?: XOR<BadgeStatusNullableScalarRelationFilter, BadgeStatusWhereInput> | null
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    checkins?: CheckinOrderByRelationAggregateInput
    eventAttendees?: EventAttendeeOrderByRelationAggregateInput
    eventCheckins?: EventCheckinOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    badgeStatusRef?: BadgeStatusOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    checkins?: CheckinListRelationFilter
    eventAttendees?: EventAttendeeListRelationFilter
    eventCheckins?: EventCheckinListRelationFilter
    members?: MemberListRelationFilter
    visitors?: VisitorListRelationFilter
    badgeStatusRef?: XOR<BadgeStatusNullableScalarRelationFilter, BadgeStatusWhereInput> | null
  }, "id" | "serialNumber">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Badge"> | string
    serialNumber?: StringWithAggregatesFilter<"Badge"> | string
    assignmentType?: StringWithAggregatesFilter<"Badge"> | string
    assignedToId?: UuidNullableWithAggregatesFilter<"Badge"> | string | null
    status?: StringWithAggregatesFilter<"Badge"> | string
    badgeStatusId?: UuidNullableWithAggregatesFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Badge"> | Date | string | null
  }

  export type CheckinWhereInput = {
    AND?: CheckinWhereInput | CheckinWhereInput[]
    OR?: CheckinWhereInput[]
    NOT?: CheckinWhereInput | CheckinWhereInput[]
    id?: UuidFilter<"Checkin"> | string
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }

  export type CheckinOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    flagged_for_review?: SortOrderInput | SortOrder
    flag_reason?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    created_by_admin?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    admin_users?: AdminUserOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type CheckinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckinWhereInput | CheckinWhereInput[]
    OR?: CheckinWhereInput[]
    NOT?: CheckinWhereInput | CheckinWhereInput[]
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }, "id">

  export type CheckinOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    flagged_for_review?: SortOrderInput | SortOrder
    flag_reason?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    created_by_admin?: SortOrderInput | SortOrder
    _count?: CheckinCountOrderByAggregateInput
    _max?: CheckinMaxOrderByAggregateInput
    _min?: CheckinMinOrderByAggregateInput
  }

  export type CheckinScalarWhereWithAggregatesInput = {
    AND?: CheckinScalarWhereWithAggregatesInput | CheckinScalarWhereWithAggregatesInput[]
    OR?: CheckinScalarWhereWithAggregatesInput[]
    NOT?: CheckinScalarWhereWithAggregatesInput | CheckinScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Checkin"> | string
    memberId?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
    badgeId?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
    direction?: StringWithAggregatesFilter<"Checkin"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Checkin"> | Date | string
    kioskId?: StringWithAggregatesFilter<"Checkin"> | string
    synced?: BoolNullableWithAggregatesFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableWithAggregatesFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableWithAggregatesFilter<"Checkin"> | string | null
    method?: StringNullableWithAggregatesFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableWithAggregatesFilter<"Checkin"> | string | null
  }

  export type DivisionWhereInput = {
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    id?: UuidFilter<"Division"> | string
    name?: StringFilter<"Division"> | string
    code?: StringFilter<"Division"> | string
    description?: StringNullableFilter<"Division"> | string | null
    createdAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type DivisionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type DivisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    name?: StringFilter<"Division"> | string
    description?: StringNullableFilter<"Division"> | string | null
    createdAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Division"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type DivisionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DivisionCountOrderByAggregateInput
    _max?: DivisionMaxOrderByAggregateInput
    _min?: DivisionMinOrderByAggregateInput
  }

  export type DivisionScalarWhereWithAggregatesInput = {
    AND?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    OR?: DivisionScalarWhereWithAggregatesInput[]
    NOT?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Division"> | string
    name?: StringWithAggregatesFilter<"Division"> | string
    code?: StringWithAggregatesFilter<"Division"> | string
    description?: StringNullableWithAggregatesFilter<"Division"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Division"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Division"> | Date | string | null
  }

  export type EventAttendeeWhereInput = {
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    id?: UuidFilter<"EventAttendee"> | string
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    eventCheckins?: EventCheckinListRelationFilter
  }

  export type EventAttendeeOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrderInput | SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    badgeAssignedAt?: SortOrderInput | SortOrder
    accessStart?: SortOrderInput | SortOrder
    accessEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    eventCheckins?: EventCheckinOrderByRelationAggregateInput
  }

  export type EventAttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    eventCheckins?: EventCheckinListRelationFilter
  }, "id">

  export type EventAttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrderInput | SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    badgeAssignedAt?: SortOrderInput | SortOrder
    accessStart?: SortOrderInput | SortOrder
    accessEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EventAttendeeCountOrderByAggregateInput
    _max?: EventAttendeeMaxOrderByAggregateInput
    _min?: EventAttendeeMinOrderByAggregateInput
  }

  export type EventAttendeeScalarWhereWithAggregatesInput = {
    AND?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    OR?: EventAttendeeScalarWhereWithAggregatesInput[]
    NOT?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventAttendee"> | string
    eventId?: UuidWithAggregatesFilter<"EventAttendee"> | string
    name?: StringWithAggregatesFilter<"EventAttendee"> | string
    rank?: StringNullableWithAggregatesFilter<"EventAttendee"> | string | null
    organization?: StringWithAggregatesFilter<"EventAttendee"> | string
    role?: StringWithAggregatesFilter<"EventAttendee"> | string
    badgeId?: UuidNullableWithAggregatesFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    status?: StringWithAggregatesFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"EventAttendee"> | Date | string | null
  }

  export type EventCheckinWhereInput = {
    AND?: EventCheckinWhereInput | EventCheckinWhereInput[]
    OR?: EventCheckinWhereInput[]
    NOT?: EventCheckinWhereInput | EventCheckinWhereInput[]
    id?: UuidFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
    eventAttendee?: XOR<EventAttendeeScalarRelationFilter, EventAttendeeWhereInput>
  }

  export type EventCheckinOrderByWithRelationInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    eventAttendee?: EventAttendeeOrderByWithRelationInput
  }

  export type EventCheckinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventCheckinWhereInput | EventCheckinWhereInput[]
    OR?: EventCheckinWhereInput[]
    NOT?: EventCheckinWhereInput | EventCheckinWhereInput[]
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
    eventAttendee?: XOR<EventAttendeeScalarRelationFilter, EventAttendeeWhereInput>
  }, "id">

  export type EventCheckinOrderByWithAggregationInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: EventCheckinCountOrderByAggregateInput
    _max?: EventCheckinMaxOrderByAggregateInput
    _min?: EventCheckinMinOrderByAggregateInput
  }

  export type EventCheckinScalarWhereWithAggregatesInput = {
    AND?: EventCheckinScalarWhereWithAggregatesInput | EventCheckinScalarWhereWithAggregatesInput[]
    OR?: EventCheckinScalarWhereWithAggregatesInput[]
    NOT?: EventCheckinScalarWhereWithAggregatesInput | EventCheckinScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidWithAggregatesFilter<"EventCheckin"> | string
    badgeId?: UuidWithAggregatesFilter<"EventCheckin"> | string
    direction?: StringWithAggregatesFilter<"EventCheckin"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EventCheckin"> | Date | string
    kioskId?: StringWithAggregatesFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"EventCheckin"> | Date | string | null
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: UuidFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    code?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    status?: StringFilter<"Event"> | string
    autoExpireBadges?: BoolNullableFilter<"Event"> | boolean | null
    customRoles?: JsonNullableFilter<"Event">
    createdBy?: UuidNullableFilter<"Event"> | string | null
    createdAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventAttendees?: EventAttendeeListRelationFilter
    visitors?: VisitorListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrderInput | SortOrder
    customRoles?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    eventAttendees?: EventAttendeeOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    name?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    status?: StringFilter<"Event"> | string
    autoExpireBadges?: BoolNullableFilter<"Event"> | boolean | null
    customRoles?: JsonNullableFilter<"Event">
    createdBy?: UuidNullableFilter<"Event"> | string | null
    createdAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventAttendees?: EventAttendeeListRelationFilter
    visitors?: VisitorListRelationFilter
  }, "id" | "code">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrderInput | SortOrder
    customRoles?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    code?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    status?: StringWithAggregatesFilter<"Event"> | string
    autoExpireBadges?: BoolNullableWithAggregatesFilter<"Event"> | boolean | null
    customRoles?: JsonNullableWithAggregatesFilter<"Event">
    createdBy?: UuidNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: UuidFilter<"Member"> | string
    serviceNumber?: StringFilter<"Member"> | string
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    bmqEnrollments?: BmqEnrollmentListRelationFilter
    checkins?: CheckinListRelationFilter
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    visitors?: VisitorListRelationFilter
    memberTags?: MemberTagListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    ddsTransfers?: DdsAssignmentListRelationFilter
    memberTypeRef?: XOR<MemberTypeNullableScalarRelationFilter, MemberTypeWhereInput> | null
    memberStatusRef?: XOR<MemberStatusNullableScalarRelationFilter, MemberStatusWhereInput> | null
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    divisionId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrderInput | SortOrder
    memberStatusId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    mess?: SortOrderInput | SortOrder
    moc?: SortOrderInput | SortOrder
    classDetails?: SortOrderInput | SortOrder
    homePhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    contract_start?: SortOrderInput | SortOrder
    contract_end?: SortOrderInput | SortOrder
    badge?: BadgeOrderByWithRelationInput
    bmqEnrollments?: BmqEnrollmentOrderByRelationAggregateInput
    checkins?: CheckinOrderByRelationAggregateInput
    division?: DivisionOrderByWithRelationInput
    visitors?: VisitorOrderByRelationAggregateInput
    memberTags?: MemberTagOrderByRelationAggregateInput
    ddsAssignments?: DdsAssignmentOrderByRelationAggregateInput
    ddsTransfers?: DdsAssignmentOrderByRelationAggregateInput
    memberTypeRef?: MemberTypeOrderByWithRelationInput
    memberStatusRef?: MemberStatusOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceNumber?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    bmqEnrollments?: BmqEnrollmentListRelationFilter
    checkins?: CheckinListRelationFilter
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    visitors?: VisitorListRelationFilter
    memberTags?: MemberTagListRelationFilter
    ddsAssignments?: DdsAssignmentListRelationFilter
    ddsTransfers?: DdsAssignmentListRelationFilter
    memberTypeRef?: XOR<MemberTypeNullableScalarRelationFilter, MemberTypeWhereInput> | null
    memberStatusRef?: XOR<MemberStatusNullableScalarRelationFilter, MemberStatusWhereInput> | null
  }, "id" | "serviceNumber">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    divisionId?: SortOrderInput | SortOrder
    badgeId?: SortOrderInput | SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrderInput | SortOrder
    memberStatusId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    mess?: SortOrderInput | SortOrder
    moc?: SortOrderInput | SortOrder
    classDetails?: SortOrderInput | SortOrder
    homePhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    contract_start?: SortOrderInput | SortOrder
    contract_end?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Member"> | string
    serviceNumber?: StringWithAggregatesFilter<"Member"> | string
    rank?: StringWithAggregatesFilter<"Member"> | string
    firstName?: StringWithAggregatesFilter<"Member"> | string
    lastName?: StringWithAggregatesFilter<"Member"> | string
    email?: StringNullableWithAggregatesFilter<"Member"> | string | null
    mobilePhone?: StringNullableWithAggregatesFilter<"Member"> | string | null
    divisionId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    badgeId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    memberType?: StringWithAggregatesFilter<"Member"> | string
    status?: StringWithAggregatesFilter<"Member"> | string
    memberTypeId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    memberStatusId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableWithAggregatesFilter<"Member"> | string | null
    initials?: StringNullableWithAggregatesFilter<"Member"> | string | null
    mess?: StringNullableWithAggregatesFilter<"Member"> | string | null
    moc?: StringNullableWithAggregatesFilter<"Member"> | string | null
    classDetails?: StringNullableWithAggregatesFilter<"Member"> | string | null
    homePhone?: StringNullableWithAggregatesFilter<"Member"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Member"> | string | null
    contract_start?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    displayOrder?: IntFilter<"Tag"> | number
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    memberTags?: MemberTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    memberTags?: MemberTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    displayOrder?: IntFilter<"Tag"> | number
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    memberTags?: MemberTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Tag"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
  }

  export type MemberTagWhereInput = {
    AND?: MemberTagWhereInput | MemberTagWhereInput[]
    OR?: MemberTagWhereInput[]
    NOT?: MemberTagWhereInput | MemberTagWhereInput[]
    id?: UuidFilter<"MemberTag"> | string
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type MemberTagOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type MemberTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_tagId?: MemberTagMemberIdTagIdCompoundUniqueInput
    AND?: MemberTagWhereInput | MemberTagWhereInput[]
    OR?: MemberTagWhereInput[]
    NOT?: MemberTagWhereInput | MemberTagWhereInput[]
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "memberId_tagId">

  export type MemberTagOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: MemberTagCountOrderByAggregateInput
    _max?: MemberTagMaxOrderByAggregateInput
    _min?: MemberTagMinOrderByAggregateInput
  }

  export type MemberTagScalarWhereWithAggregatesInput = {
    AND?: MemberTagScalarWhereWithAggregatesInput | MemberTagScalarWhereWithAggregatesInput[]
    OR?: MemberTagScalarWhereWithAggregatesInput[]
    NOT?: MemberTagScalarWhereWithAggregatesInput | MemberTagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberTag"> | string
    memberId?: UuidWithAggregatesFilter<"MemberTag"> | string
    tagId?: UuidWithAggregatesFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberTag"> | Date | string | null
  }

  export type SecurityAlertWhereInput = {
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    id?: UuidFilter<"SecurityAlert"> | string
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    acknowledgedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type SecurityAlertOrderByWithRelationInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgeNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    acknowledgedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type SecurityAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    acknowledgedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type SecurityAlertOrderByWithAggregationInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgeNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityAlertCountOrderByAggregateInput
    _max?: SecurityAlertMaxOrderByAggregateInput
    _min?: SecurityAlertMinOrderByAggregateInput
  }

  export type SecurityAlertScalarWhereWithAggregatesInput = {
    AND?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    OR?: SecurityAlertScalarWhereWithAggregatesInput[]
    NOT?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SecurityAlert"> | string
    alertType?: StringWithAggregatesFilter<"SecurityAlert"> | string
    severity?: StringWithAggregatesFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    kioskId?: StringWithAggregatesFilter<"SecurityAlert"> | string
    message?: StringWithAggregatesFilter<"SecurityAlert"> | string
    details?: JsonNullableWithAggregatesFilter<"SecurityAlert">
    status?: StringWithAggregatesFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityAlert"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: UuidFilter<"Visitor"> | string
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    hostMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    visitTypeRef?: XOR<VisitTypeNullableScalarRelationFilter, VisitTypeWhereInput> | null
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrderInput | SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitReason?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    hostMemberId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    temporaryBadgeId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    checkInMethod?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrderInput | SortOrder
    admin_users?: AdminUserOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    hostMember?: MemberOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
    visitTypeRef?: VisitTypeOrderByWithRelationInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    hostMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    badge?: XOR<BadgeNullableScalarRelationFilter, BadgeWhereInput> | null
    visitTypeRef?: XOR<VisitTypeNullableScalarRelationFilter, VisitTypeWhereInput> | null
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrderInput | SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitReason?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    hostMemberId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    temporaryBadgeId?: SortOrderInput | SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    checkInMethod?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrderInput | SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Visitor"> | string
    name?: StringWithAggregatesFilter<"Visitor"> | string
    organization?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    visitType?: StringWithAggregatesFilter<"Visitor"> | string
    visitTypeId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    visitReason?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    eventId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    checkInTime?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
    kioskId?: StringWithAggregatesFilter<"Visitor"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableWithAggregatesFilter<"Visitor"> | string | null
  }

  export type BmqCourseWhereInput = {
    AND?: BmqCourseWhereInput | BmqCourseWhereInput[]
    OR?: BmqCourseWhereInput[]
    NOT?: BmqCourseWhereInput | BmqCourseWhereInput[]
    id?: UuidFilter<"BmqCourse"> | string
    name?: StringFilter<"BmqCourse"> | string
    startDate?: DateTimeFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeFilter<"BmqCourse"> | Date | string
    isActive?: BoolFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
    bmqEnrollments?: BmqEnrollmentListRelationFilter
  }

  export type BmqCourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
    bmqEnrollments?: BmqEnrollmentOrderByRelationAggregateInput
  }

  export type BmqCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BmqCourseWhereInput | BmqCourseWhereInput[]
    OR?: BmqCourseWhereInput[]
    NOT?: BmqCourseWhereInput | BmqCourseWhereInput[]
    name?: StringFilter<"BmqCourse"> | string
    startDate?: DateTimeFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeFilter<"BmqCourse"> | Date | string
    isActive?: BoolFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
    bmqEnrollments?: BmqEnrollmentListRelationFilter
  }, "id">

  export type BmqCourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
    _count?: BmqCourseCountOrderByAggregateInput
    _max?: BmqCourseMaxOrderByAggregateInput
    _min?: BmqCourseMinOrderByAggregateInput
  }

  export type BmqCourseScalarWhereWithAggregatesInput = {
    AND?: BmqCourseScalarWhereWithAggregatesInput | BmqCourseScalarWhereWithAggregatesInput[]
    OR?: BmqCourseScalarWhereWithAggregatesInput[]
    NOT?: BmqCourseScalarWhereWithAggregatesInput | BmqCourseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BmqCourse"> | string
    name?: StringWithAggregatesFilter<"BmqCourse"> | string
    startDate?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingStartTime?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingEndTime?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    isActive?: BoolWithAggregatesFilter<"BmqCourse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BmqCourse"> | Date | string
    trainingDays?: StringNullableListFilter<"BmqCourse">
  }

  export type BmqEnrollmentWhereInput = {
    AND?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    OR?: BmqEnrollmentWhereInput[]
    NOT?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    id?: UuidFilter<"BmqEnrollment"> | string
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
    bmqCourse?: XOR<BmqCourseScalarRelationFilter, BmqCourseWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type BmqEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    bmqCourse?: BmqCourseOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type BmqEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_bmqCourseId?: BmqEnrollmentMemberIdBmqCourseIdCompoundUniqueInput
    AND?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    OR?: BmqEnrollmentWhereInput[]
    NOT?: BmqEnrollmentWhereInput | BmqEnrollmentWhereInput[]
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
    bmqCourse?: XOR<BmqCourseScalarRelationFilter, BmqCourseWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId_bmqCourseId">

  export type BmqEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: BmqEnrollmentCountOrderByAggregateInput
    _max?: BmqEnrollmentMaxOrderByAggregateInput
    _min?: BmqEnrollmentMinOrderByAggregateInput
  }

  export type BmqEnrollmentScalarWhereWithAggregatesInput = {
    AND?: BmqEnrollmentScalarWhereWithAggregatesInput | BmqEnrollmentScalarWhereWithAggregatesInput[]
    OR?: BmqEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: BmqEnrollmentScalarWhereWithAggregatesInput | BmqEnrollmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    memberId?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidWithAggregatesFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"BmqEnrollment"> | Date | string | null
    status?: StringWithAggregatesFilter<"BmqEnrollment"> | string
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    name?: StringFilter<"migrations"> | string
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }, "id" | "name">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    name?: StringWithAggregatesFilter<"migrations"> | string
    applied_at?: DateTimeNullableWithAggregatesFilter<"migrations"> | Date | string | null
  }

  export type report_audit_logWhereInput = {
    AND?: report_audit_logWhereInput | report_audit_logWhereInput[]
    OR?: report_audit_logWhereInput[]
    NOT?: report_audit_logWhereInput | report_audit_logWhereInput[]
    id?: UuidFilter<"report_audit_log"> | string
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type report_audit_logOrderByWithRelationInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrderInput | SortOrder
    is_scheduled?: SortOrderInput | SortOrder
    scheduled_report_id?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    file_size_bytes?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    admin_users?: AdminUserOrderByWithRelationInput
  }

  export type report_audit_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: report_audit_logWhereInput | report_audit_logWhereInput[]
    OR?: report_audit_logWhereInput[]
    NOT?: report_audit_logWhereInput | report_audit_logWhereInput[]
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
    admin_users?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type report_audit_logOrderByWithAggregationInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrderInput | SortOrder
    is_scheduled?: SortOrderInput | SortOrder
    scheduled_report_id?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    file_size_bytes?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    _count?: report_audit_logCountOrderByAggregateInput
    _avg?: report_audit_logAvgOrderByAggregateInput
    _max?: report_audit_logMaxOrderByAggregateInput
    _min?: report_audit_logMinOrderByAggregateInput
    _sum?: report_audit_logSumOrderByAggregateInput
  }

  export type report_audit_logScalarWhereWithAggregatesInput = {
    AND?: report_audit_logScalarWhereWithAggregatesInput | report_audit_logScalarWhereWithAggregatesInput[]
    OR?: report_audit_logScalarWhereWithAggregatesInput[]
    NOT?: report_audit_logScalarWhereWithAggregatesInput | report_audit_logScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"report_audit_log"> | string
    report_type?: StringWithAggregatesFilter<"report_audit_log"> | string
    report_config?: JsonWithAggregatesFilter<"report_audit_log">
    generated_by?: UuidNullableWithAggregatesFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableWithAggregatesFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableWithAggregatesFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableWithAggregatesFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableWithAggregatesFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableWithAggregatesFilter<"report_audit_log"> | number | null
  }

  export type ReportSettingWhereInput = {
    AND?: ReportSettingWhereInput | ReportSettingWhereInput[]
    OR?: ReportSettingWhereInput[]
    NOT?: ReportSettingWhereInput | ReportSettingWhereInput[]
    key?: StringFilter<"ReportSetting"> | string
    value?: JsonFilter<"ReportSetting">
    updatedAt?: DateTimeFilter<"ReportSetting"> | Date | string
  }

  export type ReportSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: ReportSettingWhereInput | ReportSettingWhereInput[]
    OR?: ReportSettingWhereInput[]
    NOT?: ReportSettingWhereInput | ReportSettingWhereInput[]
    value?: JsonFilter<"ReportSetting">
    updatedAt?: DateTimeFilter<"ReportSetting"> | Date | string
  }, "key">

  export type ReportSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportSettingCountOrderByAggregateInput
    _max?: ReportSettingMaxOrderByAggregateInput
    _min?: ReportSettingMinOrderByAggregateInput
  }

  export type ReportSettingScalarWhereWithAggregatesInput = {
    AND?: ReportSettingScalarWhereWithAggregatesInput | ReportSettingScalarWhereWithAggregatesInput[]
    OR?: ReportSettingScalarWhereWithAggregatesInput[]
    NOT?: ReportSettingScalarWhereWithAggregatesInput | ReportSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"ReportSetting"> | string
    value?: JsonWithAggregatesFilter<"ReportSetting">
    updatedAt?: DateTimeWithAggregatesFilter<"ReportSetting"> | Date | string
  }

  export type TrainingYearWhereInput = {
    AND?: TrainingYearWhereInput | TrainingYearWhereInput[]
    OR?: TrainingYearWhereInput[]
    NOT?: TrainingYearWhereInput | TrainingYearWhereInput[]
    id?: UuidFilter<"TrainingYear"> | string
    name?: StringFilter<"TrainingYear"> | string
    startDate?: DateTimeFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonFilter<"TrainingYear">
    dayExceptions?: JsonFilter<"TrainingYear">
    isCurrent?: BoolFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingYear"> | Date | string
  }

  export type TrainingYearOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingYearWhereInput | TrainingYearWhereInput[]
    OR?: TrainingYearWhereInput[]
    NOT?: TrainingYearWhereInput | TrainingYearWhereInput[]
    name?: StringFilter<"TrainingYear"> | string
    startDate?: DateTimeFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonFilter<"TrainingYear">
    dayExceptions?: JsonFilter<"TrainingYear">
    isCurrent?: BoolFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingYear"> | Date | string
  }, "id">

  export type TrainingYearOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingYearCountOrderByAggregateInput
    _max?: TrainingYearMaxOrderByAggregateInput
    _min?: TrainingYearMinOrderByAggregateInput
  }

  export type TrainingYearScalarWhereWithAggregatesInput = {
    AND?: TrainingYearScalarWhereWithAggregatesInput | TrainingYearScalarWhereWithAggregatesInput[]
    OR?: TrainingYearScalarWhereWithAggregatesInput[]
    NOT?: TrainingYearScalarWhereWithAggregatesInput | TrainingYearScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TrainingYear"> | string
    name?: StringWithAggregatesFilter<"TrainingYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    holidayExclusions?: JsonWithAggregatesFilter<"TrainingYear">
    dayExceptions?: JsonWithAggregatesFilter<"TrainingYear">
    isCurrent?: BoolWithAggregatesFilter<"TrainingYear"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingYear"> | Date | string
  }

  export type DdsAssignmentWhereInput = {
    AND?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    OR?: DdsAssignmentWhereInput[]
    NOT?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    id?: UuidFilter<"DdsAssignment"> | string
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    transferredToMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    assignedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }

  export type DdsAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    transferredTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
    transferredToMember?: MemberOrderByWithRelationInput
    assignedByAdmin?: AdminUserOrderByWithRelationInput
  }

  export type DdsAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    OR?: DdsAssignmentWhereInput[]
    NOT?: DdsAssignmentWhereInput | DdsAssignmentWhereInput[]
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    transferredToMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    assignedByAdmin?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
  }, "id">

  export type DdsAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    transferredTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DdsAssignmentCountOrderByAggregateInput
    _max?: DdsAssignmentMaxOrderByAggregateInput
    _min?: DdsAssignmentMinOrderByAggregateInput
  }

  export type DdsAssignmentScalarWhereWithAggregatesInput = {
    AND?: DdsAssignmentScalarWhereWithAggregatesInput | DdsAssignmentScalarWhereWithAggregatesInput[]
    OR?: DdsAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DdsAssignmentScalarWhereWithAggregatesInput | DdsAssignmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DdsAssignment"> | string
    memberId?: UuidWithAggregatesFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    status?: StringWithAggregatesFilter<"DdsAssignment"> | string
    notes?: StringNullableWithAggregatesFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DdsAssignment"> | Date | string
  }

  export type ResponsibilityAuditLogWhereInput = {
    AND?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    OR?: ResponsibilityAuditLogWhereInput[]
    NOT?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    id?: UuidFilter<"ResponsibilityAuditLog"> | string
    memberId?: UuidFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringFilter<"ResponsibilityAuditLog"> | string
    action?: StringFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableFilter<"ResponsibilityAuditLog"> | string | null
  }

  export type ResponsibilityAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrderInput | SortOrder
    toMemberId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type ResponsibilityAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    OR?: ResponsibilityAuditLogWhereInput[]
    NOT?: ResponsibilityAuditLogWhereInput | ResponsibilityAuditLogWhereInput[]
    memberId?: UuidFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringFilter<"ResponsibilityAuditLog"> | string
    action?: StringFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableFilter<"ResponsibilityAuditLog"> | string | null
  }, "id">

  export type ResponsibilityAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrderInput | SortOrder
    toMemberId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ResponsibilityAuditLogCountOrderByAggregateInput
    _max?: ResponsibilityAuditLogMaxOrderByAggregateInput
    _min?: ResponsibilityAuditLogMinOrderByAggregateInput
  }

  export type ResponsibilityAuditLogScalarWhereWithAggregatesInput = {
    AND?: ResponsibilityAuditLogScalarWhereWithAggregatesInput | ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    OR?: ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    NOT?: ResponsibilityAuditLogScalarWhereWithAggregatesInput | ResponsibilityAuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    memberId?: UuidWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    tagName?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    action?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    fromMemberId?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    toMemberId?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    performedBy?: UuidNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
    performedByType?: StringWithAggregatesFilter<"ResponsibilityAuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ResponsibilityAuditLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ResponsibilityAuditLog"> | string | null
  }

  export type MemberStatusWhereInput = {
    AND?: MemberStatusWhereInput | MemberStatusWhereInput[]
    OR?: MemberStatusWhereInput[]
    NOT?: MemberStatusWhereInput | MemberStatusWhereInput[]
    id?: UuidFilter<"MemberStatus"> | string
    code?: StringFilter<"MemberStatus"> | string
    name?: StringFilter<"MemberStatus"> | string
    description?: StringNullableFilter<"MemberStatus"> | string | null
    color?: StringNullableFilter<"MemberStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type MemberStatusOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type MemberStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: MemberStatusWhereInput | MemberStatusWhereInput[]
    OR?: MemberStatusWhereInput[]
    NOT?: MemberStatusWhereInput | MemberStatusWhereInput[]
    name?: StringFilter<"MemberStatus"> | string
    description?: StringNullableFilter<"MemberStatus"> | string | null
    color?: StringNullableFilter<"MemberStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberStatus"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type MemberStatusOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberStatusCountOrderByAggregateInput
    _max?: MemberStatusMaxOrderByAggregateInput
    _min?: MemberStatusMinOrderByAggregateInput
  }

  export type MemberStatusScalarWhereWithAggregatesInput = {
    AND?: MemberStatusScalarWhereWithAggregatesInput | MemberStatusScalarWhereWithAggregatesInput[]
    OR?: MemberStatusScalarWhereWithAggregatesInput[]
    NOT?: MemberStatusScalarWhereWithAggregatesInput | MemberStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberStatus"> | string
    code?: StringWithAggregatesFilter<"MemberStatus"> | string
    name?: StringWithAggregatesFilter<"MemberStatus"> | string
    description?: StringNullableWithAggregatesFilter<"MemberStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"MemberStatus"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberStatus"> | Date | string | null
  }

  export type MemberTypeWhereInput = {
    AND?: MemberTypeWhereInput | MemberTypeWhereInput[]
    OR?: MemberTypeWhereInput[]
    NOT?: MemberTypeWhereInput | MemberTypeWhereInput[]
    id?: UuidFilter<"MemberType"> | string
    code?: StringFilter<"MemberType"> | string
    name?: StringFilter<"MemberType"> | string
    description?: StringNullableFilter<"MemberType"> | string | null
    color?: StringNullableFilter<"MemberType"> | string | null
    createdAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    members?: MemberListRelationFilter
  }

  export type MemberTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
  }

  export type MemberTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: MemberTypeWhereInput | MemberTypeWhereInput[]
    OR?: MemberTypeWhereInput[]
    NOT?: MemberTypeWhereInput | MemberTypeWhereInput[]
    name?: StringFilter<"MemberType"> | string
    description?: StringNullableFilter<"MemberType"> | string | null
    color?: StringNullableFilter<"MemberType"> | string | null
    createdAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberType"> | Date | string | null
    members?: MemberListRelationFilter
  }, "id" | "code">

  export type MemberTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberTypeCountOrderByAggregateInput
    _max?: MemberTypeMaxOrderByAggregateInput
    _min?: MemberTypeMinOrderByAggregateInput
  }

  export type MemberTypeScalarWhereWithAggregatesInput = {
    AND?: MemberTypeScalarWhereWithAggregatesInput | MemberTypeScalarWhereWithAggregatesInput[]
    OR?: MemberTypeScalarWhereWithAggregatesInput[]
    NOT?: MemberTypeScalarWhereWithAggregatesInput | MemberTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MemberType"> | string
    code?: StringWithAggregatesFilter<"MemberType"> | string
    name?: StringWithAggregatesFilter<"MemberType"> | string
    description?: StringNullableWithAggregatesFilter<"MemberType"> | string | null
    color?: StringNullableWithAggregatesFilter<"MemberType"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberType"> | Date | string | null
  }

  export type VisitTypeWhereInput = {
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    id?: UuidFilter<"VisitType"> | string
    code?: StringFilter<"VisitType"> | string
    name?: StringFilter<"VisitType"> | string
    description?: StringNullableFilter<"VisitType"> | string | null
    color?: StringNullableFilter<"VisitType"> | string | null
    createdAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    visitors?: VisitorListRelationFilter
  }

  export type VisitTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    visitors?: VisitorOrderByRelationAggregateInput
  }

  export type VisitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    name?: StringFilter<"VisitType"> | string
    description?: StringNullableFilter<"VisitType"> | string | null
    color?: StringNullableFilter<"VisitType"> | string | null
    createdAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VisitType"> | Date | string | null
    visitors?: VisitorListRelationFilter
  }, "id" | "code">

  export type VisitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VisitTypeCountOrderByAggregateInput
    _max?: VisitTypeMaxOrderByAggregateInput
    _min?: VisitTypeMinOrderByAggregateInput
  }

  export type VisitTypeScalarWhereWithAggregatesInput = {
    AND?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    OR?: VisitTypeScalarWhereWithAggregatesInput[]
    NOT?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VisitType"> | string
    code?: StringWithAggregatesFilter<"VisitType"> | string
    name?: StringWithAggregatesFilter<"VisitType"> | string
    description?: StringNullableWithAggregatesFilter<"VisitType"> | string | null
    color?: StringNullableWithAggregatesFilter<"VisitType"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"VisitType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"VisitType"> | Date | string | null
  }

  export type BadgeStatusWhereInput = {
    AND?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    OR?: BadgeStatusWhereInput[]
    NOT?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    id?: UuidFilter<"BadgeStatus"> | string
    code?: StringFilter<"BadgeStatus"> | string
    name?: StringFilter<"BadgeStatus"> | string
    description?: StringNullableFilter<"BadgeStatus"> | string | null
    color?: StringNullableFilter<"BadgeStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    badges?: BadgeListRelationFilter
  }

  export type BadgeStatusOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badges?: BadgeOrderByRelationAggregateInput
  }

  export type BadgeStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    OR?: BadgeStatusWhereInput[]
    NOT?: BadgeStatusWhereInput | BadgeStatusWhereInput[]
    name?: StringFilter<"BadgeStatus"> | string
    description?: StringNullableFilter<"BadgeStatus"> | string | null
    color?: StringNullableFilter<"BadgeStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BadgeStatus"> | Date | string | null
    badges?: BadgeListRelationFilter
  }, "id" | "code">

  export type BadgeStatusOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BadgeStatusCountOrderByAggregateInput
    _max?: BadgeStatusMaxOrderByAggregateInput
    _min?: BadgeStatusMinOrderByAggregateInput
  }

  export type BadgeStatusScalarWhereWithAggregatesInput = {
    AND?: BadgeStatusScalarWhereWithAggregatesInput | BadgeStatusScalarWhereWithAggregatesInput[]
    OR?: BadgeStatusScalarWhereWithAggregatesInput[]
    NOT?: BadgeStatusScalarWhereWithAggregatesInput | BadgeStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BadgeStatus"> | string
    code?: StringWithAggregatesFilter<"BadgeStatus"> | string
    name?: StringWithAggregatesFilter<"BadgeStatus"> | string
    description?: StringNullableWithAggregatesFilter<"BadgeStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"BadgeStatus"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"BadgeStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BadgeStatus"> | Date | string | null
  }

  export type ListItemWhereInput = {
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    id?: UuidFilter<"ListItem"> | string
    listType?: StringFilter<"ListItem"> | string
    code?: StringFilter<"ListItem"> | string
    name?: StringFilter<"ListItem"> | string
    displayOrder?: IntFilter<"ListItem"> | number
    description?: StringNullableFilter<"ListItem"> | string | null
    isSystem?: BoolFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
  }

  export type ListItemOrderByWithRelationInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type ListItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listType_code?: ListItemListTypeCodeCompoundUniqueInput
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    listType?: StringFilter<"ListItem"> | string
    code?: StringFilter<"ListItem"> | string
    name?: StringFilter<"ListItem"> | string
    displayOrder?: IntFilter<"ListItem"> | number
    description?: StringNullableFilter<"ListItem"> | string | null
    isSystem?: BoolFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ListItem"> | Date | string | null
  }, "id" | "listType_code">

  export type ListItemOrderByWithAggregationInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ListItemCountOrderByAggregateInput
    _avg?: ListItemAvgOrderByAggregateInput
    _max?: ListItemMaxOrderByAggregateInput
    _min?: ListItemMinOrderByAggregateInput
    _sum?: ListItemSumOrderByAggregateInput
  }

  export type ListItemScalarWhereWithAggregatesInput = {
    AND?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    OR?: ListItemScalarWhereWithAggregatesInput[]
    NOT?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ListItem"> | string
    listType?: StringWithAggregatesFilter<"ListItem"> | string
    code?: StringWithAggregatesFilter<"ListItem"> | string
    name?: StringWithAggregatesFilter<"ListItem"> | string
    displayOrder?: IntWithAggregatesFilter<"ListItem"> | number
    description?: StringNullableWithAggregatesFilter<"ListItem"> | string | null
    isSystem?: BoolWithAggregatesFilter<"ListItem"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"ListItem"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ListItem"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    badgeId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    badgeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }, "id" | "email" | "badgeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    badgeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    badgeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: UuidFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    userId?: UuidWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Account"> | string
    userId?: UuidWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: UuidFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_value?: VerificationIdentifierValueCompoundUniqueInput
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "identifier_value">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: UuidFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: JsonFilter<"Setting">
    category?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: JsonFilter<"Setting">
    category?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: JsonWithAggregatesFilter<"Setting">
    category?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type AlertConfigWhereInput = {
    AND?: AlertConfigWhereInput | AlertConfigWhereInput[]
    OR?: AlertConfigWhereInput[]
    NOT?: AlertConfigWhereInput | AlertConfigWhereInput[]
    key?: StringFilter<"AlertConfig"> | string
    config?: JsonFilter<"AlertConfig">
    updatedAt?: DateTimeFilter<"AlertConfig"> | Date | string
  }

  export type AlertConfigOrderByWithRelationInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: AlertConfigWhereInput | AlertConfigWhereInput[]
    OR?: AlertConfigWhereInput[]
    NOT?: AlertConfigWhereInput | AlertConfigWhereInput[]
    config?: JsonFilter<"AlertConfig">
    updatedAt?: DateTimeFilter<"AlertConfig"> | Date | string
  }, "key">

  export type AlertConfigOrderByWithAggregationInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertConfigCountOrderByAggregateInput
    _max?: AlertConfigMaxOrderByAggregateInput
    _min?: AlertConfigMinOrderByAggregateInput
  }

  export type AlertConfigScalarWhereWithAggregatesInput = {
    AND?: AlertConfigScalarWhereWithAggregatesInput | AlertConfigScalarWhereWithAggregatesInput[]
    OR?: AlertConfigScalarWhereWithAggregatesInput[]
    NOT?: AlertConfigScalarWhereWithAggregatesInput | AlertConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"AlertConfig"> | string
    config?: JsonWithAggregatesFilter<"AlertConfig">
    updatedAt?: DateTimeWithAggregatesFilter<"AlertConfig"> | Date | string
  }

  export type AdminUserCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
    adminUser?: AdminUserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    adminUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminUser?: AdminUserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    adminUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeCreateInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckinCreateInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinCreateManyInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DivisionCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DivisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    event: EventCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeCreateManyInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventAttendeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    badge: BadgeCreateNestedOneWithoutEventCheckinsInput
    eventAttendee: EventAttendeeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateInput = {
    id?: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput
    eventAttendee?: EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateManyInput = {
    id?: string
    eventAttendeeId: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutEventInput
    visitors?: VisitorCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutEventNestedInput
    visitors?: VisitorUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    displayOrder?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    displayOrder?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberTags?: MemberTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    displayOrder?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagCreateInput = {
    id?: string
    createdAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberTagsInput
    tag: TagCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateInput = {
    id?: string
    memberId: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagCreateManyInput = {
    id?: string
    memberId: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityAlertCreateInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
    acknowledgedByAdmin?: AdminUserCreateNestedOneWithoutSecurityAlertsInput
  }

  export type SecurityAlertUncheckedCreateInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedByAdmin?: AdminUserUpdateOneWithoutSecurityAlertsNestedInput
  }

  export type SecurityAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertCreateManyInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorCreateManyInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmqCourseCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutBmqCourseInput
  }

  export type BmqCourseUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutBmqCourseInput
  }

  export type BmqCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutBmqCourseNestedInput
  }

  export type BmqCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseNestedInput
  }

  export type BmqCourseCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    bmqCourse: BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput
    member: MemberCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateInput = {
    id?: string
    memberId: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    bmqCourse?: BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
    member?: MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentCreateManyInput = {
    id?: string
    memberId: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsCreateInput = {
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateManyInput = {
    id?: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type report_audit_logCreateInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
    admin_users?: AdminUserCreateNestedOneWithoutReport_audit_logInput
  }

  export type report_audit_logUncheckedCreateInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    generated_by?: string | null
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users?: AdminUserUpdateOneWithoutReport_audit_logNestedInput
  }

  export type report_audit_logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logCreateManyInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    generated_by?: string | null
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    generated_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportSettingCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUncheckedCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingCreateManyInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ReportSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    holidayExclusions?: JsonNullValueInput | InputJsonValue
    dayExceptions?: JsonNullValueInput | InputJsonValue
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentCreateInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentCreateManyInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponsibilityAuditLogCreateInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUncheckedCreateInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogCreateManyInput = {
    id?: string
    memberId: string
    tagName: string
    action: string
    fromMemberId?: string | null
    toMemberId?: string | null
    performedBy?: string | null
    performedByType: string
    timestamp?: Date | string
    notes?: string | null
  }

  export type ResponsibilityAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsibilityAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    fromMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    toMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedByType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberStatusCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutMemberStatusRefInput
  }

  export type MemberStatusUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutMemberStatusRefInput
  }

  export type MemberStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutMemberStatusRefNestedInput
  }

  export type MemberStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutMemberStatusRefNestedInput
  }

  export type MemberStatusCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutMemberTypeRefInput
  }

  export type MemberTypeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutMemberTypeRefInput
  }

  export type MemberTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutMemberTypeRefNestedInput
  }

  export type MemberTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutMemberTypeRefNestedInput
  }

  export type MemberTypeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorCreateNestedManyWithoutVisitTypeRefInput
  }

  export type VisitTypeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorUncheckedCreateNestedManyWithoutVisitTypeRefInput
  }

  export type VisitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUpdateManyWithoutVisitTypeRefNestedInput
  }

  export type VisitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUncheckedUpdateManyWithoutVisitTypeRefNestedInput
  }

  export type VisitTypeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badges?: BadgeCreateNestedManyWithoutBadgeStatusRefInput
  }

  export type BadgeStatusUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badges?: BadgeUncheckedCreateNestedManyWithoutBadgeStatusRefInput
  }

  export type BadgeStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: BadgeUpdateManyWithoutBadgeStatusRefNestedInput
  }

  export type BadgeStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: BadgeUncheckedUpdateManyWithoutBadgeStatusRefNestedInput
  }

  export type BadgeStatusCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemCreateInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUncheckedCreateInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemCreateManyInput = {
    id?: string
    listType: string
    code: string
    name: string
    displayOrder?: number
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ListItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listType?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigCreateInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUncheckedCreateInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigCreateManyInput = {
    key: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AlertConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CheckinListRelationFilter = {
    every?: CheckinWhereInput
    some?: CheckinWhereInput
    none?: CheckinWhereInput
  }

  export type Report_audit_logListRelationFilter = {
    every?: report_audit_logWhereInput
    some?: report_audit_logWhereInput
    none?: report_audit_logWhereInput
  }

  export type SecurityAlertListRelationFilter = {
    every?: SecurityAlertWhereInput
    some?: SecurityAlertWhereInput
    none?: SecurityAlertWhereInput
  }

  export type VisitorListRelationFilter = {
    every?: VisitorWhereInput
    some?: VisitorWhereInput
    none?: VisitorWhereInput
  }

  export type DdsAssignmentListRelationFilter = {
    every?: DdsAssignmentWhereInput
    some?: DdsAssignmentWhereInput
    none?: DdsAssignmentWhereInput
  }

  export type AdminUserNullableScalarRelationFilter = {
    is?: AdminUserWhereInput | null
    isNot?: AdminUserWhereInput | null
  }

  export type AdminUserListRelationFilter = {
    every?: AdminUserWhereInput
    some?: AdminUserWhereInput
    none?: AdminUserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type report_audit_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DdsAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    updated_at?: SortOrder
    disabled?: SortOrder
    disabledAt?: SortOrder
    disabledBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EventAttendeeListRelationFilter = {
    every?: EventAttendeeWhereInput
    some?: EventAttendeeWhereInput
    none?: EventAttendeeWhereInput
  }

  export type EventCheckinListRelationFilter = {
    every?: EventCheckinWhereInput
    some?: EventCheckinWhereInput
    none?: EventCheckinWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type BadgeStatusNullableScalarRelationFilter = {
    is?: BadgeStatusWhereInput | null
    isNot?: BadgeStatusWhereInput | null
  }

  export type EventAttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCheckinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    assignmentType?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    badgeStatusId?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BadgeNullableScalarRelationFilter = {
    is?: BadgeWhereInput | null
    isNot?: BadgeWhereInput | null
  }

  export type MemberNullableScalarRelationFilter = {
    is?: MemberWhereInput | null
    isNot?: MemberWhereInput | null
  }

  export type CheckinCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type CheckinMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type CheckinMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    flagged_for_review?: SortOrder
    flag_reason?: SortOrder
    method?: SortOrder
    created_by_admin?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DivisionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DivisionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DivisionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventAttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    organization?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    badgeAssignedAt?: SortOrder
    accessStart?: SortOrder
    accessEnd?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type EventAttendeeScalarRelationFilter = {
    is?: EventAttendeeWhereInput
    isNot?: EventAttendeeWhereInput
  }

  export type EventCheckinCountOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCheckinMaxOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCheckinMinOrderByAggregateInput = {
    id?: SortOrder
    eventAttendeeId?: SortOrder
    badgeId?: SortOrder
    direction?: SortOrder
    timestamp?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    customRoles?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoExpireBadges?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BmqEnrollmentListRelationFilter = {
    every?: BmqEnrollmentWhereInput
    some?: BmqEnrollmentWhereInput
    none?: BmqEnrollmentWhereInput
  }

  export type DivisionNullableScalarRelationFilter = {
    is?: DivisionWhereInput | null
    isNot?: DivisionWhereInput | null
  }

  export type MemberTagListRelationFilter = {
    every?: MemberTagWhereInput
    some?: MemberTagWhereInput
    none?: MemberTagWhereInput
  }

  export type MemberTypeNullableScalarRelationFilter = {
    is?: MemberTypeWhereInput | null
    isNot?: MemberTypeWhereInput | null
  }

  export type MemberStatusNullableScalarRelationFilter = {
    is?: MemberStatusWhereInput | null
    isNot?: MemberStatusWhereInput | null
  }

  export type BmqEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    serviceNumber?: SortOrder
    rank?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    mobilePhone?: SortOrder
    divisionId?: SortOrder
    badgeId?: SortOrder
    memberType?: SortOrder
    status?: SortOrder
    memberTypeId?: SortOrder
    memberStatusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeNumber?: SortOrder
    initials?: SortOrder
    mess?: SortOrder
    moc?: SortOrder
    classDetails?: SortOrder
    homePhone?: SortOrder
    notes?: SortOrder
    contract_start?: SortOrder
    contract_end?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type MemberTagMemberIdTagIdCompoundUniqueInput = {
    memberId: string
    tagId: string
  }

  export type MemberTagCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberTagMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberTagMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertCountOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    details?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMinOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    badgeSerial?: SortOrder
    memberId?: SortOrder
    kioskId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgeNote?: SortOrder
    createdAt?: SortOrder
  }

  export type EventNullableScalarRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type VisitTypeNullableScalarRelationFilter = {
    is?: VisitTypeWhereInput | null
    isNot?: VisitTypeWhereInput | null
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    visitType?: SortOrder
    visitTypeId?: SortOrder
    visitReason?: SortOrder
    eventId?: SortOrder
    hostMemberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    temporaryBadgeId?: SortOrder
    kioskId?: SortOrder
    createdAt?: SortOrder
    adminNotes?: SortOrder
    checkInMethod?: SortOrder
    createdByAdmin?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BmqCourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingDays?: SortOrder
  }

  export type BmqCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BmqCourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingStartTime?: SortOrder
    trainingEndTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BmqCourseScalarRelationFilter = {
    is?: BmqCourseWhereInput
    isNot?: BmqCourseWhereInput
  }

  export type BmqEnrollmentMemberIdBmqCourseIdCompoundUniqueInput = {
    memberId: string
    bmqCourseId: string
  }

  export type BmqEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type BmqEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type BmqEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    bmqCourseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type report_audit_logCountOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    report_config?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logAvgOrderByAggregateInput = {
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logMaxOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logMinOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    generated_by?: SortOrder
    is_scheduled?: SortOrder
    scheduled_report_id?: SortOrder
    generated_at?: SortOrder
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type report_audit_logSumOrderByAggregateInput = {
    file_size_bytes?: SortOrder
    generation_time_ms?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReportSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSettingMinOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    holidayExclusions?: SortOrder
    dayExceptions?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingYearMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DdsAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    assignedDate?: SortOrder
    acceptedAt?: SortOrder
    releasedAt?: SortOrder
    transferredTo?: SortOrder
    assignedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponsibilityAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type ResponsibilityAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type ResponsibilityAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    tagName?: SortOrder
    action?: SortOrder
    fromMemberId?: SortOrder
    toMemberId?: SortOrder
    performedBy?: SortOrder
    performedByType?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
  }

  export type MemberStatusCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberStatusMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeStatusCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeStatusMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemListTypeCodeCompoundUniqueInput = {
    listType: string
    code: string
  }

  export type ListItemCountOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ListItemMaxOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemMinOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListItemSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationIdentifierValueCompoundUniqueInput = {
    identifier: string
    value: string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigCountOrderByAggregateInput = {
    key?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertConfigMinOrderByAggregateInput = {
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckinCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type report_audit_logCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
  }

  export type SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type AdminUserCreateNestedOneWithoutDisabledUsersInput = {
    create?: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledUsersInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutUpdatedUsersInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedUsersInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserCreateNestedManyWithoutDisabledByAdminInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type AdminUserCreateNestedManyWithoutUpdatedByAdminInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
  }

  export type SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AuditLogUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminUserInput | AuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckinUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput | CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput | CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutAdmin_usersInput | CheckinUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type report_audit_logUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    set?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    disconnect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    delete?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    update?: report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput | report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
  }

  export type SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput | SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput | VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput | VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutAdmin_usersInput | VisitorUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput | DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type AdminUserUpdateOneWithoutDisabledUsersNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledUsersInput
    upsert?: AdminUserUpsertWithoutDisabledUsersInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutDisabledUsersInput, AdminUserUpdateWithoutDisabledUsersInput>, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
  }

  export type AdminUserUpdateOneWithoutUpdatedUsersNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedUsersInput
    upsert?: AdminUserUpsertWithoutUpdatedUsersInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUpdatedUsersInput, AdminUserUpdateWithoutUpdatedUsersInput>, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type AdminUserUpdateManyWithoutDisabledByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput | AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AdminUserUpdateManyWithoutUpdatedByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput | AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput> | AuditLogCreateWithoutAdminUserInput[] | AuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminUserInput | AuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AuditLogCreateManyAdminUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminUserInput | AuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput> | CheckinCreateWithoutAdmin_usersInput[] | CheckinUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutAdmin_usersInput | CheckinCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput | CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: CheckinCreateManyAdmin_usersInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput | CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutAdmin_usersInput | CheckinUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput> | report_audit_logCreateWithoutAdmin_usersInput[] | report_audit_logUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: report_audit_logCreateOrConnectWithoutAdmin_usersInput | report_audit_logCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: report_audit_logCreateManyAdmin_usersInputEnvelope
    set?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    disconnect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    delete?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    connect?: report_audit_logWhereUniqueInput | report_audit_logWhereUniqueInput[]
    update?: report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput | report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput | report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
  }

  export type SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput> | SecurityAlertCreateWithoutAcknowledgedByAdminInput[] | SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput | SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    createMany?: SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput | SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput | SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput> | VisitorCreateWithoutAdmin_usersInput[] | VisitorUncheckedCreateWithoutAdmin_usersInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutAdmin_usersInput | VisitorCreateOrConnectWithoutAdmin_usersInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput | VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput[]
    createMany?: VisitorCreateManyAdmin_usersInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput | VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutAdmin_usersInput | VisitorUpdateManyWithWhereWithoutAdmin_usersInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput> | DdsAssignmentCreateWithoutAssignedByAdminInput[] | DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput | DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput[]
    createMany?: DdsAssignmentCreateManyAssignedByAdminInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput | DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput | DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput> | AdminUserCreateWithoutDisabledByAdminInput[] | AdminUserUncheckedCreateWithoutDisabledByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutDisabledByAdminInput | AdminUserCreateOrConnectWithoutDisabledByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput[]
    createMany?: AdminUserCreateManyDisabledByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput | AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput | AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput = {
    create?: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput> | AdminUserCreateWithoutUpdatedByAdminInput[] | AdminUserUncheckedCreateWithoutUpdatedByAdminInput[]
    connectOrCreate?: AdminUserCreateOrConnectWithoutUpdatedByAdminInput | AdminUserCreateOrConnectWithoutUpdatedByAdminInput[]
    upsert?: AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput[]
    createMany?: AdminUserCreateManyUpdatedByAdminInputEnvelope
    set?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    disconnect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    delete?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    connect?: AdminUserWhereUniqueInput | AdminUserWhereUniqueInput[]
    update?: AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput | AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput[]
    updateMany?: AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput | AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput[]
    deleteMany?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
  }

  export type AdminUserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUserUpsertWithoutAuditLogsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutAuditLogsInput, AdminUserUpdateWithoutAuditLogsInput>, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CheckinCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type EventAttendeeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EventCheckinCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutBadgeInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutBadgeInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type BadgeStatusCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeStatusCreateOrConnectWithoutBadgesInput
    connect?: BadgeStatusWhereUniqueInput
  }

  export type CheckinUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EventCheckinUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type CheckinUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutBadgeInput | CheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutBadgeInput | CheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutBadgeInput | CheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type EventAttendeeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput | EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput | EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutBadgeInput | EventAttendeeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type EventCheckinUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutBadgeInput | EventCheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutBadgeInput | EventCheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutBadgeInput | EventCheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBadgeInput | MemberUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBadgeInput | MemberUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBadgeInput | MemberUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutBadgeInput | VisitorUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutBadgeInput | VisitorUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutBadgeInput | VisitorUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeStatusUpdateOneWithoutBadgesNestedInput = {
    create?: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeStatusCreateOrConnectWithoutBadgesInput
    upsert?: BadgeStatusUpsertWithoutBadgesInput
    disconnect?: BadgeStatusWhereInput | boolean
    delete?: BadgeStatusWhereInput | boolean
    connect?: BadgeStatusWhereUniqueInput
    update?: XOR<XOR<BadgeStatusUpdateToOneWithWhereWithoutBadgesInput, BadgeStatusUpdateWithoutBadgesInput>, BadgeStatusUncheckedUpdateWithoutBadgesInput>
  }

  export type CheckinUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput> | CheckinCreateWithoutBadgeInput[] | CheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutBadgeInput | CheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutBadgeInput | CheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: CheckinCreateManyBadgeInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutBadgeInput | CheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutBadgeInput | CheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput> | EventAttendeeCreateWithoutBadgeInput[] | EventAttendeeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutBadgeInput | EventAttendeeCreateOrConnectWithoutBadgeInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput | EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventAttendeeCreateManyBadgeInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput | EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutBadgeInput | EventAttendeeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput> | EventCheckinCreateWithoutBadgeInput[] | EventCheckinUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutBadgeInput | EventCheckinCreateOrConnectWithoutBadgeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutBadgeInput | EventCheckinUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: EventCheckinCreateManyBadgeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutBadgeInput | EventCheckinUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutBadgeInput | EventCheckinUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput> | MemberCreateWithoutBadgeInput[] | MemberUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBadgeInput | MemberCreateOrConnectWithoutBadgeInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBadgeInput | MemberUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: MemberCreateManyBadgeInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBadgeInput | MemberUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBadgeInput | MemberUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput> | VisitorCreateWithoutBadgeInput[] | VisitorUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutBadgeInput | VisitorCreateOrConnectWithoutBadgeInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutBadgeInput | VisitorUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: VisitorCreateManyBadgeInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutBadgeInput | VisitorUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutBadgeInput | VisitorUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCheckinsInput
    connect?: BadgeWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutCheckinsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheckinsInput
    connect?: MemberWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BadgeUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutCheckinsInput
    upsert?: BadgeUpsertWithoutCheckinsInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutCheckinsInput, BadgeUpdateWithoutCheckinsInput>, BadgeUncheckedUpdateWithoutCheckinsInput>
  }

  export type AdminUserUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutCheckinsInput
    upsert?: AdminUserUpsertWithoutCheckinsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutCheckinsInput, AdminUserUpdateWithoutCheckinsInput>, AdminUserUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberUpdateOneWithoutCheckinsNestedInput = {
    create?: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheckinsInput
    upsert?: MemberUpsertWithoutCheckinsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCheckinsInput, MemberUpdateWithoutCheckinsInput>, MemberUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberCreateNestedManyWithoutDivisionInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutDivisionInput | MemberUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutDivisionInput | MemberUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutDivisionInput | MemberUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput> | MemberCreateWithoutDivisionInput[] | MemberUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutDivisionInput | MemberCreateOrConnectWithoutDivisionInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutDivisionInput | MemberUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: MemberCreateManyDivisionInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutDivisionInput | MemberUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutDivisionInput | MemberUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutEventAttendeesInput = {
    create?: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventAttendeesInput
    connect?: BadgeWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutEventAttendeesInput = {
    create?: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventAttendeesInput
    connect?: EventWhereUniqueInput
  }

  export type EventCheckinCreateNestedManyWithoutEventAttendeeInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
  }

  export type BadgeUpdateOneWithoutEventAttendeesNestedInput = {
    create?: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventAttendeesInput
    upsert?: BadgeUpsertWithoutEventAttendeesInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutEventAttendeesInput, BadgeUpdateWithoutEventAttendeesInput>, BadgeUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventUpdateOneRequiredWithoutEventAttendeesNestedInput = {
    create?: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventAttendeesInput
    upsert?: EventUpsertWithoutEventAttendeesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventAttendeesInput, EventUpdateWithoutEventAttendeesInput>, EventUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventCheckinUpdateManyWithoutEventAttendeeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput | EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput = {
    create?: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput> | EventCheckinCreateWithoutEventAttendeeInput[] | EventCheckinUncheckedCreateWithoutEventAttendeeInput[]
    connectOrCreate?: EventCheckinCreateOrConnectWithoutEventAttendeeInput | EventCheckinCreateOrConnectWithoutEventAttendeeInput[]
    upsert?: EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput[]
    createMany?: EventCheckinCreateManyEventAttendeeInputEnvelope
    set?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    disconnect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    delete?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    connect?: EventCheckinWhereUniqueInput | EventCheckinWhereUniqueInput[]
    update?: EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput | EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput[]
    updateMany?: EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput | EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput[]
    deleteMany?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutEventCheckinsInput = {
    create?: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventCheckinsInput
    connect?: BadgeWhereUniqueInput
  }

  export type EventAttendeeCreateNestedOneWithoutEventCheckinsInput = {
    create?: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventCheckinsInput
    connect?: EventAttendeeWhereUniqueInput
  }

  export type BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput = {
    create?: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutEventCheckinsInput
    upsert?: BadgeUpsertWithoutEventCheckinsInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutEventCheckinsInput, BadgeUpdateWithoutEventCheckinsInput>, BadgeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventCheckinsInput
    upsert?: EventAttendeeUpsertWithoutEventCheckinsInput
    connect?: EventAttendeeWhereUniqueInput
    update?: XOR<XOR<EventAttendeeUpdateToOneWithWhereWithoutEventCheckinsInput, EventAttendeeUpdateWithoutEventCheckinsInput>, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutEventInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type EventAttendeeUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutEventNestedInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutEventInput | VisitorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutEventInput | VisitorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutEventInput | VisitorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput> | VisitorCreateWithoutEventInput[] | VisitorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutEventInput | VisitorCreateOrConnectWithoutEventInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutEventInput | VisitorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: VisitorCreateManyEventInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutEventInput | VisitorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutEventInput | VisitorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutMembersInput = {
    create?: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutMembersInput
    connect?: BadgeWhereUniqueInput
  }

  export type BmqEnrollmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type CheckinCreateNestedManyWithoutMemberInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type DivisionCreateNestedOneWithoutMembersInput = {
    create?: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutMembersInput
    connect?: DivisionWhereUniqueInput
  }

  export type VisitorCreateNestedManyWithoutHostMemberInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type MemberTagCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type MemberTypeCreateNestedOneWithoutMembersInput = {
    create?: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberTypeCreateOrConnectWithoutMembersInput
    connect?: MemberTypeWhereUniqueInput
  }

  export type MemberStatusCreateNestedOneWithoutMembersInput = {
    create?: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberStatusCreateOrConnectWithoutMembersInput
    connect?: MemberStatusWhereUniqueInput
  }

  export type BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type CheckinUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutHostMemberInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type MemberTagUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
  }

  export type BadgeUpdateOneWithoutMembersNestedInput = {
    create?: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutMembersInput
    upsert?: BadgeUpsertWithoutMembersInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutMembersInput, BadgeUpdateWithoutMembersInput>, BadgeUncheckedUpdateWithoutMembersInput>
  }

  export type BmqEnrollmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutMemberInput | BmqEnrollmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type CheckinUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutMemberInput | CheckinUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutMemberInput | CheckinUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutMemberInput | CheckinUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type DivisionUpdateOneWithoutMembersNestedInput = {
    create?: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutMembersInput
    upsert?: DivisionUpsertWithoutMembersInput
    disconnect?: DivisionWhereInput | boolean
    delete?: DivisionWhereInput | boolean
    connect?: DivisionWhereUniqueInput
    update?: XOR<XOR<DivisionUpdateToOneWithWhereWithoutMembersInput, DivisionUpdateWithoutMembersInput>, DivisionUncheckedUpdateWithoutMembersInput>
  }

  export type VisitorUpdateManyWithoutHostMemberNestedInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutHostMemberInput | VisitorUpsertWithWhereUniqueWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutHostMemberInput | VisitorUpdateWithWhereUniqueWithoutHostMemberInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutHostMemberInput | VisitorUpdateManyWithWhereWithoutHostMemberInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type MemberTagUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutMemberInput | MemberTagUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutMemberInput | MemberTagUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutMemberInput | MemberTagUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutMemberInput | DdsAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput | DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type MemberTypeUpdateOneWithoutMembersNestedInput = {
    create?: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberTypeCreateOrConnectWithoutMembersInput
    upsert?: MemberTypeUpsertWithoutMembersInput
    disconnect?: MemberTypeWhereInput | boolean
    delete?: MemberTypeWhereInput | boolean
    connect?: MemberTypeWhereUniqueInput
    update?: XOR<XOR<MemberTypeUpdateToOneWithWhereWithoutMembersInput, MemberTypeUpdateWithoutMembersInput>, MemberTypeUncheckedUpdateWithoutMembersInput>
  }

  export type MemberStatusUpdateOneWithoutMembersNestedInput = {
    create?: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MemberStatusCreateOrConnectWithoutMembersInput
    upsert?: MemberStatusUpsertWithoutMembersInput
    disconnect?: MemberStatusWhereInput | boolean
    delete?: MemberStatusWhereInput | boolean
    connect?: MemberStatusWhereUniqueInput
    update?: XOR<XOR<MemberStatusUpdateToOneWithWhereWithoutMembersInput, MemberStatusUpdateWithoutMembersInput>, MemberStatusUncheckedUpdateWithoutMembersInput>
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput> | BmqEnrollmentCreateWithoutMemberInput[] | BmqEnrollmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutMemberInput | BmqEnrollmentCreateOrConnectWithoutMemberInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BmqEnrollmentCreateManyMemberInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput | BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutMemberInput | BmqEnrollmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type CheckinUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput> | CheckinCreateWithoutMemberInput[] | CheckinUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CheckinCreateOrConnectWithoutMemberInput | CheckinCreateOrConnectWithoutMemberInput[]
    upsert?: CheckinUpsertWithWhereUniqueWithoutMemberInput | CheckinUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CheckinCreateManyMemberInputEnvelope
    set?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    disconnect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    delete?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    connect?: CheckinWhereUniqueInput | CheckinWhereUniqueInput[]
    update?: CheckinUpdateWithWhereUniqueWithoutMemberInput | CheckinUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CheckinUpdateManyWithWhereWithoutMemberInput | CheckinUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutHostMemberNestedInput = {
    create?: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput> | VisitorCreateWithoutHostMemberInput[] | VisitorUncheckedCreateWithoutHostMemberInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutHostMemberInput | VisitorCreateOrConnectWithoutHostMemberInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutHostMemberInput | VisitorUpsertWithWhereUniqueWithoutHostMemberInput[]
    createMany?: VisitorCreateManyHostMemberInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutHostMemberInput | VisitorUpdateWithWhereUniqueWithoutHostMemberInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutHostMemberInput | VisitorUpdateManyWithWhereWithoutHostMemberInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type MemberTagUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput> | MemberTagCreateWithoutMemberInput[] | MemberTagUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutMemberInput | MemberTagCreateOrConnectWithoutMemberInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutMemberInput | MemberTagUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberTagCreateManyMemberInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutMemberInput | MemberTagUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutMemberInput | MemberTagUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput> | DdsAssignmentCreateWithoutMemberInput[] | DdsAssignmentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutMemberInput | DdsAssignmentCreateOrConnectWithoutMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DdsAssignmentCreateManyMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutMemberInput | DdsAssignmentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput = {
    create?: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput> | DdsAssignmentCreateWithoutTransferredToMemberInput[] | DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput[]
    connectOrCreate?: DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput | DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput[]
    upsert?: DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput[]
    createMany?: DdsAssignmentCreateManyTransferredToMemberInputEnvelope
    set?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    disconnect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    delete?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    connect?: DdsAssignmentWhereUniqueInput | DdsAssignmentWhereUniqueInput[]
    update?: DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput | DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput[]
    updateMany?: DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput | DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput[]
    deleteMany?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
  }

  export type MemberTagCreateNestedManyWithoutTagInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type MemberTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutTagInput | MemberTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutTagInput | MemberTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutTagInput | MemberTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type MemberTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput> | MemberTagCreateWithoutTagInput[] | MemberTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MemberTagCreateOrConnectWithoutTagInput | MemberTagCreateOrConnectWithoutTagInput[]
    upsert?: MemberTagUpsertWithWhereUniqueWithoutTagInput | MemberTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MemberTagCreateManyTagInputEnvelope
    set?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    disconnect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    delete?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    connect?: MemberTagWhereUniqueInput | MemberTagWhereUniqueInput[]
    update?: MemberTagUpdateWithWhereUniqueWithoutTagInput | MemberTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MemberTagUpdateManyWithWhereWithoutTagInput | MemberTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutMemberTagsInput = {
    create?: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTagsInput
    connect?: MemberWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutMemberTagsInput = {
    create?: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMemberTagsInput
    connect?: TagWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberTagsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTagsInput
    upsert?: MemberUpsertWithoutMemberTagsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberTagsInput, MemberUpdateWithoutMemberTagsInput>, MemberUncheckedUpdateWithoutMemberTagsInput>
  }

  export type TagUpdateOneRequiredWithoutMemberTagsNestedInput = {
    create?: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMemberTagsInput
    upsert?: TagUpsertWithoutMemberTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutMemberTagsInput, TagUpdateWithoutMemberTagsInput>, TagUncheckedUpdateWithoutMemberTagsInput>
  }

  export type AdminUserCreateNestedOneWithoutSecurityAlertsInput = {
    create?: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSecurityAlertsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutSecurityAlertsNestedInput = {
    create?: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSecurityAlertsInput
    upsert?: AdminUserUpsertWithoutSecurityAlertsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutSecurityAlertsInput, AdminUserUpdateWithoutSecurityAlertsInput>, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type AdminUserCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutVisitorsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutVisitorsInput
    connect?: EventWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutVisitorsInput
    connect?: MemberWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutVisitorsInput
    connect?: BadgeWhereUniqueInput
  }

  export type VisitTypeCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutVisitorsInput
    connect?: VisitTypeWhereUniqueInput
  }

  export type AdminUserUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutVisitorsInput
    upsert?: AdminUserUpsertWithoutVisitorsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutVisitorsInput, AdminUserUpdateWithoutVisitorsInput>, AdminUserUncheckedUpdateWithoutVisitorsInput>
  }

  export type EventUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutVisitorsInput
    upsert?: EventUpsertWithoutVisitorsInput
    disconnect?: EventWhereInput | boolean
    delete?: EventWhereInput | boolean
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutVisitorsInput, EventUpdateWithoutVisitorsInput>, EventUncheckedUpdateWithoutVisitorsInput>
  }

  export type MemberUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutVisitorsInput
    upsert?: MemberUpsertWithoutVisitorsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutVisitorsInput, MemberUpdateWithoutVisitorsInput>, MemberUncheckedUpdateWithoutVisitorsInput>
  }

  export type BadgeUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutVisitorsInput
    upsert?: BadgeUpsertWithoutVisitorsInput
    disconnect?: BadgeWhereInput | boolean
    delete?: BadgeWhereInput | boolean
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutVisitorsInput, BadgeUpdateWithoutVisitorsInput>, BadgeUncheckedUpdateWithoutVisitorsInput>
  }

  export type VisitTypeUpdateOneWithoutVisitorsNestedInput = {
    create?: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutVisitorsInput
    upsert?: VisitTypeUpsertWithoutVisitorsInput
    disconnect?: VisitTypeWhereInput | boolean
    delete?: VisitTypeWhereInput | boolean
    connect?: VisitTypeWhereUniqueInput
    update?: XOR<XOR<VisitTypeUpdateToOneWithWhereWithoutVisitorsInput, VisitTypeUpdateWithoutVisitorsInput>, VisitTypeUncheckedUpdateWithoutVisitorsInput>
  }

  export type BmqCourseCreatetrainingDaysInput = {
    set: string[]
  }

  export type BmqEnrollmentCreateNestedManyWithoutBmqCourseInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type BmqEnrollmentUncheckedCreateNestedManyWithoutBmqCourseInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
  }

  export type BmqCourseUpdatetrainingDaysInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BmqEnrollmentUpdateManyWithoutBmqCourseNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput | BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseNestedInput = {
    create?: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput> | BmqEnrollmentCreateWithoutBmqCourseInput[] | BmqEnrollmentUncheckedCreateWithoutBmqCourseInput[]
    connectOrCreate?: BmqEnrollmentCreateOrConnectWithoutBmqCourseInput | BmqEnrollmentCreateOrConnectWithoutBmqCourseInput[]
    upsert?: BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput[]
    createMany?: BmqEnrollmentCreateManyBmqCourseInputEnvelope
    set?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    disconnect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    delete?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    connect?: BmqEnrollmentWhereUniqueInput | BmqEnrollmentWhereUniqueInput[]
    update?: BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput | BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput[]
    updateMany?: BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput | BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput[]
    deleteMany?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
  }

  export type BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput = {
    create?: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput
    connect?: BmqCourseWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutBmqEnrollmentsInput = {
    create?: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBmqEnrollmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput = {
    create?: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput
    upsert?: BmqCourseUpsertWithoutBmqEnrollmentsInput
    connect?: BmqCourseWhereUniqueInput
    update?: XOR<XOR<BmqCourseUpdateToOneWithWhereWithoutBmqEnrollmentsInput, BmqCourseUpdateWithoutBmqEnrollmentsInput>, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput = {
    create?: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBmqEnrollmentsInput
    upsert?: MemberUpsertWithoutBmqEnrollmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutBmqEnrollmentsInput, MemberUpdateWithoutBmqEnrollmentsInput>, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type AdminUserCreateNestedOneWithoutReport_audit_logInput = {
    create?: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutReport_audit_logInput
    connect?: AdminUserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUserUpdateOneWithoutReport_audit_logNestedInput = {
    create?: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutReport_audit_logInput
    upsert?: AdminUserUpsertWithoutReport_audit_logInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutReport_audit_logInput, AdminUserUpdateWithoutReport_audit_logInput>, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
  }

  export type MemberCreateNestedOneWithoutDdsAssignmentsInput = {
    create?: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsAssignmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutDdsTransfersInput = {
    create?: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsTransfersInput
    connect?: MemberWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutDdsAssignmentsInput = {
    create?: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDdsAssignmentsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput = {
    create?: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsAssignmentsInput
    upsert?: MemberUpsertWithoutDdsAssignmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutDdsAssignmentsInput, MemberUpdateWithoutDdsAssignmentsInput>, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberUpdateOneWithoutDdsTransfersNestedInput = {
    create?: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutDdsTransfersInput
    upsert?: MemberUpsertWithoutDdsTransfersInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutDdsTransfersInput, MemberUpdateWithoutDdsTransfersInput>, MemberUncheckedUpdateWithoutDdsTransfersInput>
  }

  export type AdminUserUpdateOneWithoutDdsAssignmentsNestedInput = {
    create?: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutDdsAssignmentsInput
    upsert?: AdminUserUpsertWithoutDdsAssignmentsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutDdsAssignmentsInput, AdminUserUpdateWithoutDdsAssignmentsInput>, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberCreateNestedManyWithoutMemberStatusRefInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutMemberStatusRefInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutMemberStatusRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput | MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput | MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberStatusRefInput | MemberUpdateManyWithWhereWithoutMemberStatusRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutMemberStatusRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput> | MemberCreateWithoutMemberStatusRefInput[] | MemberUncheckedCreateWithoutMemberStatusRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberStatusRefInput | MemberCreateOrConnectWithoutMemberStatusRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput | MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput[]
    createMany?: MemberCreateManyMemberStatusRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput | MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberStatusRefInput | MemberUpdateManyWithWhereWithoutMemberStatusRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberCreateNestedManyWithoutMemberTypeRefInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutMemberTypeRefInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutMemberTypeRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput | MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput | MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberTypeRefInput | MemberUpdateManyWithWhereWithoutMemberTypeRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutMemberTypeRefNestedInput = {
    create?: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput> | MemberCreateWithoutMemberTypeRefInput[] | MemberUncheckedCreateWithoutMemberTypeRefInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutMemberTypeRefInput | MemberCreateOrConnectWithoutMemberTypeRefInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput | MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput[]
    createMany?: MemberCreateManyMemberTypeRefInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput | MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutMemberTypeRefInput | MemberUpdateManyWithWhereWithoutMemberTypeRefInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VisitorCreateNestedManyWithoutVisitTypeRefInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutVisitTypeRefInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type VisitorUpdateManyWithoutVisitTypeRefNestedInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutVisitTypeRefInput | VisitorUpdateManyWithWhereWithoutVisitTypeRefInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutVisitTypeRefNestedInput = {
    create?: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput> | VisitorCreateWithoutVisitTypeRefInput[] | VisitorUncheckedCreateWithoutVisitTypeRefInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutVisitTypeRefInput | VisitorCreateOrConnectWithoutVisitTypeRefInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput[]
    createMany?: VisitorCreateManyVisitTypeRefInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput | VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutVisitTypeRefInput | VisitorUpdateManyWithWhereWithoutVisitTypeRefInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type BadgeCreateNestedManyWithoutBadgeStatusRefInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutBadgeStatusRefInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUpdateManyWithoutBadgeStatusRefNestedInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput | BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutBadgeStatusRefNestedInput = {
    create?: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput> | BadgeCreateWithoutBadgeStatusRefInput[] | BadgeUncheckedCreateWithoutBadgeStatusRefInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgeStatusRefInput | BadgeCreateOrConnectWithoutBadgeStatusRefInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput[]
    createMany?: BadgeCreateManyBadgeStatusRefInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput | BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput | BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AuditLogCreateWithoutAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogUncheckedCreateWithoutAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogCreateOrConnectWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AuditLogCreateManyAdminUserInputEnvelope = {
    data: AuditLogCreateManyAdminUserInput | AuditLogCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type CheckinCreateWithoutAdmin_usersInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
  }

  export type CheckinCreateOrConnectWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput>
  }

  export type CheckinCreateManyAdmin_usersInputEnvelope = {
    data: CheckinCreateManyAdmin_usersInput | CheckinCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type report_audit_logCreateWithoutAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type report_audit_logCreateOrConnectWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    create: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput>
  }

  export type report_audit_logCreateManyAdmin_usersInputEnvelope = {
    data: report_audit_logCreateManyAdmin_usersInput | report_audit_logCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type SecurityAlertCreateWithoutAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type SecurityAlertCreateOrConnectWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    create: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertCreateManyAcknowledgedByAdminInputEnvelope = {
    data: SecurityAlertCreateManyAcknowledgedByAdminInput | SecurityAlertCreateManyAcknowledgedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
  }

  export type VisitorCreateOrConnectWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput>
  }

  export type VisitorCreateManyAdmin_usersInputEnvelope = {
    data: VisitorCreateManyAdmin_usersInput | VisitorCreateManyAdmin_usersInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutAssignedByAdminInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
  }

  export type DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentCreateManyAssignedByAdminInputEnvelope = {
    data: DdsAssignmentCreateManyAssignedByAdminInput | DdsAssignmentCreateManyAssignedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserCreateWithoutDisabledUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDisabledUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDisabledUsersInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
  }

  export type AdminUserCreateWithoutUpdatedUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutUpdatedUsersInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutUpdatedUsersInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
  }

  export type AdminUserCreateWithoutDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput>
  }

  export type AdminUserCreateManyDisabledByAdminInputEnvelope = {
    data: AdminUserCreateManyDisabledByAdminInput | AdminUserCreateManyDisabledByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserCreateWithoutUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput>
  }

  export type AdminUserCreateManyUpdatedByAdminInputEnvelope = {
    data: AdminUserCreateManyUpdatedByAdminInput | AdminUserCreateManyUpdatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutAdminUserInput, AuditLogUncheckedUpdateWithoutAdminUserInput>
    create: XOR<AuditLogCreateWithoutAdminUserInput, AuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutAdminUserInput, AuditLogUncheckedUpdateWithoutAdminUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutAdminUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    adminUserId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
  }

  export type CheckinUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutAdmin_usersInput, CheckinUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<CheckinCreateWithoutAdmin_usersInput, CheckinUncheckedCreateWithoutAdmin_usersInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutAdmin_usersInput, CheckinUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type CheckinUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type CheckinScalarWhereInput = {
    AND?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
    OR?: CheckinScalarWhereInput[]
    NOT?: CheckinScalarWhereInput | CheckinScalarWhereInput[]
    id?: UuidFilter<"Checkin"> | string
    memberId?: UuidNullableFilter<"Checkin"> | string | null
    badgeId?: UuidNullableFilter<"Checkin"> | string | null
    direction?: StringFilter<"Checkin"> | string
    timestamp?: DateTimeFilter<"Checkin"> | Date | string
    kioskId?: StringFilter<"Checkin"> | string
    synced?: BoolNullableFilter<"Checkin"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Checkin"> | Date | string | null
    flagged_for_review?: BoolNullableFilter<"Checkin"> | boolean | null
    flag_reason?: StringNullableFilter<"Checkin"> | string | null
    method?: StringNullableFilter<"Checkin"> | string | null
    created_by_admin?: UuidNullableFilter<"Checkin"> | string | null
  }

  export type report_audit_logUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    update: XOR<report_audit_logUpdateWithoutAdmin_usersInput, report_audit_logUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<report_audit_logCreateWithoutAdmin_usersInput, report_audit_logUncheckedCreateWithoutAdmin_usersInput>
  }

  export type report_audit_logUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: report_audit_logWhereUniqueInput
    data: XOR<report_audit_logUpdateWithoutAdmin_usersInput, report_audit_logUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type report_audit_logUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: report_audit_logScalarWhereInput
    data: XOR<report_audit_logUpdateManyMutationInput, report_audit_logUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type report_audit_logScalarWhereInput = {
    AND?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
    OR?: report_audit_logScalarWhereInput[]
    NOT?: report_audit_logScalarWhereInput | report_audit_logScalarWhereInput[]
    id?: UuidFilter<"report_audit_log"> | string
    report_type?: StringFilter<"report_audit_log"> | string
    report_config?: JsonFilter<"report_audit_log">
    generated_by?: UuidNullableFilter<"report_audit_log"> | string | null
    is_scheduled?: BoolNullableFilter<"report_audit_log"> | boolean | null
    scheduled_report_id?: UuidNullableFilter<"report_audit_log"> | string | null
    generated_at?: DateTimeNullableFilter<"report_audit_log"> | Date | string | null
    file_size_bytes?: IntNullableFilter<"report_audit_log"> | number | null
    generation_time_ms?: IntNullableFilter<"report_audit_log"> | number | null
  }

  export type SecurityAlertUpsertWithWhereUniqueWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    update: XOR<SecurityAlertUpdateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput>
    create: XOR<SecurityAlertCreateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedCreateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertUpdateWithWhereUniqueWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertWhereUniqueInput
    data: XOR<SecurityAlertUpdateWithoutAcknowledgedByAdminInput, SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertUpdateManyWithWhereWithoutAcknowledgedByAdminInput = {
    where: SecurityAlertScalarWhereInput
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminInput>
  }

  export type SecurityAlertScalarWhereInput = {
    AND?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    OR?: SecurityAlertScalarWhereInput[]
    NOT?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    id?: UuidFilter<"SecurityAlert"> | string
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    badgeSerial?: StringNullableFilter<"SecurityAlert"> | string | null
    memberId?: UuidNullableFilter<"SecurityAlert"> | string | null
    kioskId?: StringFilter<"SecurityAlert"> | string
    message?: StringFilter<"SecurityAlert"> | string
    details?: JsonNullableFilter<"SecurityAlert">
    status?: StringFilter<"SecurityAlert"> | string
    acknowledgedBy?: UuidNullableFilter<"SecurityAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"SecurityAlert"> | Date | string | null
    acknowledgeNote?: StringNullableFilter<"SecurityAlert"> | string | null
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
  }

  export type VisitorUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutAdmin_usersInput, VisitorUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<VisitorCreateWithoutAdmin_usersInput, VisitorUncheckedCreateWithoutAdmin_usersInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutAdmin_usersInput, VisitorUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type VisitorUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type VisitorScalarWhereInput = {
    AND?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    OR?: VisitorScalarWhereInput[]
    NOT?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    id?: UuidFilter<"Visitor"> | string
    name?: StringFilter<"Visitor"> | string
    organization?: StringNullableFilter<"Visitor"> | string | null
    visitType?: StringFilter<"Visitor"> | string
    visitTypeId?: UuidNullableFilter<"Visitor"> | string | null
    visitReason?: StringNullableFilter<"Visitor"> | string | null
    eventId?: UuidNullableFilter<"Visitor"> | string | null
    hostMemberId?: UuidNullableFilter<"Visitor"> | string | null
    checkInTime?: DateTimeFilter<"Visitor"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    temporaryBadgeId?: UuidNullableFilter<"Visitor"> | string | null
    kioskId?: StringFilter<"Visitor"> | string
    createdAt?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    adminNotes?: StringNullableFilter<"Visitor"> | string | null
    checkInMethod?: StringNullableFilter<"Visitor"> | string | null
    createdByAdmin?: UuidNullableFilter<"Visitor"> | string | null
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutAssignedByAdminInput, DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput>
    create: XOR<DdsAssignmentCreateWithoutAssignedByAdminInput, DdsAssignmentUncheckedCreateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutAssignedByAdminInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutAssignedByAdminInput, DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutAssignedByAdminInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminInput>
  }

  export type DdsAssignmentScalarWhereInput = {
    AND?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
    OR?: DdsAssignmentScalarWhereInput[]
    NOT?: DdsAssignmentScalarWhereInput | DdsAssignmentScalarWhereInput[]
    id?: UuidFilter<"DdsAssignment"> | string
    memberId?: UuidFilter<"DdsAssignment"> | string
    assignedDate?: DateTimeFilter<"DdsAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DdsAssignment"> | Date | string | null
    transferredTo?: UuidNullableFilter<"DdsAssignment"> | string | null
    assignedBy?: UuidNullableFilter<"DdsAssignment"> | string | null
    status?: StringFilter<"DdsAssignment"> | string
    notes?: StringNullableFilter<"DdsAssignment"> | string | null
    createdAt?: DateTimeFilter<"DdsAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DdsAssignment"> | Date | string
  }

  export type AdminUserUpsertWithoutDisabledUsersInput = {
    update: XOR<AdminUserUpdateWithoutDisabledUsersInput, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
    create: XOR<AdminUserCreateWithoutDisabledUsersInput, AdminUserUncheckedCreateWithoutDisabledUsersInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutDisabledUsersInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutDisabledUsersInput, AdminUserUncheckedUpdateWithoutDisabledUsersInput>
  }

  export type AdminUserUpdateWithoutDisabledUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDisabledUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUpsertWithoutUpdatedUsersInput = {
    update: XOR<AdminUserUpdateWithoutUpdatedUsersInput, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
    create: XOR<AdminUserCreateWithoutUpdatedUsersInput, AdminUserUncheckedCreateWithoutUpdatedUsersInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutUpdatedUsersInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutUpdatedUsersInput, AdminUserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type AdminUserUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
  }

  export type AdminUserUpsertWithWhereUniqueWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    update: XOR<AdminUserUpdateWithoutDisabledByAdminInput, AdminUserUncheckedUpdateWithoutDisabledByAdminInput>
    create: XOR<AdminUserCreateWithoutDisabledByAdminInput, AdminUserUncheckedCreateWithoutDisabledByAdminInput>
  }

  export type AdminUserUpdateWithWhereUniqueWithoutDisabledByAdminInput = {
    where: AdminUserWhereUniqueInput
    data: XOR<AdminUserUpdateWithoutDisabledByAdminInput, AdminUserUncheckedUpdateWithoutDisabledByAdminInput>
  }

  export type AdminUserUpdateManyWithWhereWithoutDisabledByAdminInput = {
    where: AdminUserScalarWhereInput
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyWithoutDisabledByAdminInput>
  }

  export type AdminUserScalarWhereInput = {
    AND?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
    OR?: AdminUserScalarWhereInput[]
    NOT?: AdminUserScalarWhereInput | AdminUserScalarWhereInput[]
    id?: UuidFilter<"AdminUser"> | string
    username?: StringFilter<"AdminUser"> | string
    email?: StringNullableFilter<"AdminUser"> | string | null
    passwordHash?: StringFilter<"AdminUser"> | string
    displayName?: StringFilter<"AdminUser"> | string
    fullName?: StringNullableFilter<"AdminUser"> | string | null
    role?: StringFilter<"AdminUser"> | string
    lastLogin?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    first_name?: StringNullableFilter<"AdminUser"> | string | null
    last_name?: StringNullableFilter<"AdminUser"> | string | null
    updated_at?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabled?: BoolFilter<"AdminUser"> | boolean
    disabledAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    disabledBy?: UuidNullableFilter<"AdminUser"> | string | null
    updatedBy?: UuidNullableFilter<"AdminUser"> | string | null
  }

  export type AdminUserUpsertWithWhereUniqueWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    update: XOR<AdminUserUpdateWithoutUpdatedByAdminInput, AdminUserUncheckedUpdateWithoutUpdatedByAdminInput>
    create: XOR<AdminUserCreateWithoutUpdatedByAdminInput, AdminUserUncheckedCreateWithoutUpdatedByAdminInput>
  }

  export type AdminUserUpdateWithWhereUniqueWithoutUpdatedByAdminInput = {
    where: AdminUserWhereUniqueInput
    data: XOR<AdminUserUpdateWithoutUpdatedByAdminInput, AdminUserUncheckedUpdateWithoutUpdatedByAdminInput>
  }

  export type AdminUserUpdateManyWithWhereWithoutUpdatedByAdminInput = {
    where: AdminUserScalarWhereInput
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyWithoutUpdatedByAdminInput>
  }

  export type AdminUserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutAuditLogsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminUserUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type CheckinCreateWithoutBadgeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
    member?: MemberCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutBadgeInput = {
    id?: string
    memberId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinCreateOrConnectWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput>
  }

  export type CheckinCreateManyBadgeInputEnvelope = {
    data: CheckinCreateManyBadgeInput | CheckinCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type EventAttendeeCreateWithoutBadgeInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    event: EventCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateWithoutBadgeInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeCreateOrConnectWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput>
  }

  export type EventAttendeeCreateManyBadgeInputEnvelope = {
    data: EventAttendeeCreateManyBadgeInput | EventAttendeeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type EventCheckinCreateWithoutBadgeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    eventAttendee: EventAttendeeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateWithoutBadgeInput = {
    id?: string
    eventAttendeeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinCreateOrConnectWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    create: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput>
  }

  export type EventCheckinCreateManyBadgeInputEnvelope = {
    data: EventCheckinCreateManyBadgeInput | EventCheckinCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutBadgeInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutBadgeInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput>
  }

  export type MemberCreateManyBadgeInputEnvelope = {
    data: MemberCreateManyBadgeInput | MemberCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput>
  }

  export type VisitorCreateManyBadgeInputEnvelope = {
    data: VisitorCreateManyBadgeInput | VisitorCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeStatusCreateWithoutBadgesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusUncheckedCreateWithoutBadgesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeStatusCreateOrConnectWithoutBadgesInput = {
    where: BadgeStatusWhereUniqueInput
    create: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
  }

  export type CheckinUpsertWithWhereUniqueWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutBadgeInput, CheckinUncheckedUpdateWithoutBadgeInput>
    create: XOR<CheckinCreateWithoutBadgeInput, CheckinUncheckedCreateWithoutBadgeInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutBadgeInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutBadgeInput, CheckinUncheckedUpdateWithoutBadgeInput>
  }

  export type CheckinUpdateManyWithWhereWithoutBadgeInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutBadgeInput, EventAttendeeUncheckedUpdateWithoutBadgeInput>
    create: XOR<EventAttendeeCreateWithoutBadgeInput, EventAttendeeUncheckedCreateWithoutBadgeInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutBadgeInput, EventAttendeeUncheckedUpdateWithoutBadgeInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutBadgeInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventAttendeeScalarWhereInput = {
    AND?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    OR?: EventAttendeeScalarWhereInput[]
    NOT?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    id?: UuidFilter<"EventAttendee"> | string
    eventId?: UuidFilter<"EventAttendee"> | string
    name?: StringFilter<"EventAttendee"> | string
    rank?: StringNullableFilter<"EventAttendee"> | string | null
    organization?: StringFilter<"EventAttendee"> | string
    role?: StringFilter<"EventAttendee"> | string
    badgeId?: UuidNullableFilter<"EventAttendee"> | string | null
    badgeAssignedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessStart?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    accessEnd?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    status?: StringFilter<"EventAttendee"> | string
    createdAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EventAttendee"> | Date | string | null
  }

  export type EventCheckinUpsertWithWhereUniqueWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    update: XOR<EventCheckinUpdateWithoutBadgeInput, EventCheckinUncheckedUpdateWithoutBadgeInput>
    create: XOR<EventCheckinCreateWithoutBadgeInput, EventCheckinUncheckedCreateWithoutBadgeInput>
  }

  export type EventCheckinUpdateWithWhereUniqueWithoutBadgeInput = {
    where: EventCheckinWhereUniqueInput
    data: XOR<EventCheckinUpdateWithoutBadgeInput, EventCheckinUncheckedUpdateWithoutBadgeInput>
  }

  export type EventCheckinUpdateManyWithWhereWithoutBadgeInput = {
    where: EventCheckinScalarWhereInput
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyWithoutBadgeInput>
  }

  export type EventCheckinScalarWhereInput = {
    AND?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
    OR?: EventCheckinScalarWhereInput[]
    NOT?: EventCheckinScalarWhereInput | EventCheckinScalarWhereInput[]
    id?: UuidFilter<"EventCheckin"> | string
    eventAttendeeId?: UuidFilter<"EventCheckin"> | string
    badgeId?: UuidFilter<"EventCheckin"> | string
    direction?: StringFilter<"EventCheckin"> | string
    timestamp?: DateTimeFilter<"EventCheckin"> | Date | string
    kioskId?: StringFilter<"EventCheckin"> | string
    createdAt?: DateTimeNullableFilter<"EventCheckin"> | Date | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutBadgeInput, MemberUncheckedUpdateWithoutBadgeInput>
    create: XOR<MemberCreateWithoutBadgeInput, MemberUncheckedCreateWithoutBadgeInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutBadgeInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutBadgeInput, MemberUncheckedUpdateWithoutBadgeInput>
  }

  export type MemberUpdateManyWithWhereWithoutBadgeInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutBadgeInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: UuidFilter<"Member"> | string
    serviceNumber?: StringFilter<"Member"> | string
    rank?: StringFilter<"Member"> | string
    firstName?: StringFilter<"Member"> | string
    lastName?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    mobilePhone?: StringNullableFilter<"Member"> | string | null
    divisionId?: UuidNullableFilter<"Member"> | string | null
    badgeId?: UuidNullableFilter<"Member"> | string | null
    memberType?: StringFilter<"Member"> | string
    status?: StringFilter<"Member"> | string
    memberTypeId?: UuidNullableFilter<"Member"> | string | null
    memberStatusId?: UuidNullableFilter<"Member"> | string | null
    createdAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    employeeNumber?: StringNullableFilter<"Member"> | string | null
    initials?: StringNullableFilter<"Member"> | string | null
    mess?: StringNullableFilter<"Member"> | string | null
    moc?: StringNullableFilter<"Member"> | string | null
    classDetails?: StringNullableFilter<"Member"> | string | null
    homePhone?: StringNullableFilter<"Member"> | string | null
    notes?: StringNullableFilter<"Member"> | string | null
    contract_start?: DateTimeNullableFilter<"Member"> | Date | string | null
    contract_end?: DateTimeNullableFilter<"Member"> | Date | string | null
  }

  export type VisitorUpsertWithWhereUniqueWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutBadgeInput, VisitorUncheckedUpdateWithoutBadgeInput>
    create: XOR<VisitorCreateWithoutBadgeInput, VisitorUncheckedCreateWithoutBadgeInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutBadgeInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutBadgeInput, VisitorUncheckedUpdateWithoutBadgeInput>
  }

  export type VisitorUpdateManyWithWhereWithoutBadgeInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutBadgeInput>
  }

  export type BadgeStatusUpsertWithoutBadgesInput = {
    update: XOR<BadgeStatusUpdateWithoutBadgesInput, BadgeStatusUncheckedUpdateWithoutBadgesInput>
    create: XOR<BadgeStatusCreateWithoutBadgesInput, BadgeStatusUncheckedCreateWithoutBadgesInput>
    where?: BadgeStatusWhereInput
  }

  export type BadgeStatusUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BadgeStatusWhereInput
    data: XOR<BadgeStatusUpdateWithoutBadgesInput, BadgeStatusUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeStatusUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeStatusUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeCreateWithoutCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutCheckinsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
  }

  export type AdminUserCreateWithoutCheckinsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutCheckinsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutCheckinsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
  }

  export type MemberCreateWithoutCheckinsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutCheckinsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutCheckinsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
  }

  export type BadgeUpsertWithoutCheckinsInput = {
    update: XOR<BadgeUpdateWithoutCheckinsInput, BadgeUncheckedUpdateWithoutCheckinsInput>
    create: XOR<BadgeCreateWithoutCheckinsInput, BadgeUncheckedCreateWithoutCheckinsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutCheckinsInput, BadgeUncheckedUpdateWithoutCheckinsInput>
  }

  export type BadgeUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type AdminUserUpsertWithoutCheckinsInput = {
    update: XOR<AdminUserUpdateWithoutCheckinsInput, AdminUserUncheckedUpdateWithoutCheckinsInput>
    create: XOR<AdminUserCreateWithoutCheckinsInput, AdminUserUncheckedCreateWithoutCheckinsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutCheckinsInput, AdminUserUncheckedUpdateWithoutCheckinsInput>
  }

  export type AdminUserUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type MemberUpsertWithoutCheckinsInput = {
    update: XOR<MemberUpdateWithoutCheckinsInput, MemberUncheckedUpdateWithoutCheckinsInput>
    create: XOR<MemberCreateWithoutCheckinsInput, MemberUncheckedCreateWithoutCheckinsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCheckinsInput, MemberUncheckedUpdateWithoutCheckinsInput>
  }

  export type MemberUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberCreateWithoutDivisionInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutDivisionInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput>
  }

  export type MemberCreateManyDivisionInputEnvelope = {
    data: MemberCreateManyDivisionInput | MemberCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutDivisionInput, MemberUncheckedUpdateWithoutDivisionInput>
    create: XOR<MemberCreateWithoutDivisionInput, MemberUncheckedCreateWithoutDivisionInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutDivisionInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutDivisionInput, MemberUncheckedUpdateWithoutDivisionInput>
  }

  export type MemberUpdateManyWithWhereWithoutDivisionInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutDivisionInput>
  }

  export type BadgeCreateWithoutEventAttendeesInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutEventAttendeesInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutEventAttendeesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
  }

  export type EventCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventAttendeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    visitors?: VisitorUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventAttendeesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
  }

  export type EventCheckinCreateWithoutEventAttendeeInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
    badge: BadgeCreateNestedOneWithoutEventCheckinsInput
  }

  export type EventCheckinUncheckedCreateWithoutEventAttendeeInput = {
    id?: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinCreateOrConnectWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    create: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput>
  }

  export type EventCheckinCreateManyEventAttendeeInputEnvelope = {
    data: EventCheckinCreateManyEventAttendeeInput | EventCheckinCreateManyEventAttendeeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithoutEventAttendeesInput = {
    update: XOR<BadgeUpdateWithoutEventAttendeesInput, BadgeUncheckedUpdateWithoutEventAttendeesInput>
    create: XOR<BadgeCreateWithoutEventAttendeesInput, BadgeUncheckedCreateWithoutEventAttendeesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutEventAttendeesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutEventAttendeesInput, BadgeUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type BadgeUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type EventUpsertWithoutEventAttendeesInput = {
    update: XOR<EventUpdateWithoutEventAttendeesInput, EventUncheckedUpdateWithoutEventAttendeesInput>
    create: XOR<EventCreateWithoutEventAttendeesInput, EventUncheckedCreateWithoutEventAttendeesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventAttendeesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventAttendeesInput, EventUncheckedUpdateWithoutEventAttendeesInput>
  }

  export type EventUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitors?: VisitorUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCheckinUpsertWithWhereUniqueWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    update: XOR<EventCheckinUpdateWithoutEventAttendeeInput, EventCheckinUncheckedUpdateWithoutEventAttendeeInput>
    create: XOR<EventCheckinCreateWithoutEventAttendeeInput, EventCheckinUncheckedCreateWithoutEventAttendeeInput>
  }

  export type EventCheckinUpdateWithWhereUniqueWithoutEventAttendeeInput = {
    where: EventCheckinWhereUniqueInput
    data: XOR<EventCheckinUpdateWithoutEventAttendeeInput, EventCheckinUncheckedUpdateWithoutEventAttendeeInput>
  }

  export type EventCheckinUpdateManyWithWhereWithoutEventAttendeeInput = {
    where: EventCheckinScalarWhereInput
    data: XOR<EventCheckinUpdateManyMutationInput, EventCheckinUncheckedUpdateManyWithoutEventAttendeeInput>
  }

  export type BadgeCreateWithoutEventCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutEventCheckinsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutEventCheckinsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
  }

  export type EventAttendeeCreateWithoutEventCheckinsInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    event: EventCreateNestedOneWithoutEventAttendeesInput
  }

  export type EventAttendeeUncheckedCreateWithoutEventCheckinsInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventAttendeeCreateOrConnectWithoutEventCheckinsInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
  }

  export type BadgeUpsertWithoutEventCheckinsInput = {
    update: XOR<BadgeUpdateWithoutEventCheckinsInput, BadgeUncheckedUpdateWithoutEventCheckinsInput>
    create: XOR<BadgeCreateWithoutEventCheckinsInput, BadgeUncheckedCreateWithoutEventCheckinsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutEventCheckinsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutEventCheckinsInput, BadgeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type BadgeUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type EventAttendeeUpsertWithoutEventCheckinsInput = {
    update: XOR<EventAttendeeUpdateWithoutEventCheckinsInput, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
    create: XOR<EventAttendeeCreateWithoutEventCheckinsInput, EventAttendeeUncheckedCreateWithoutEventCheckinsInput>
    where?: EventAttendeeWhereInput
  }

  export type EventAttendeeUpdateToOneWithWhereWithoutEventCheckinsInput = {
    where?: EventAttendeeWhereInput
    data: XOR<EventAttendeeUpdateWithoutEventCheckinsInput, EventAttendeeUncheckedUpdateWithoutEventCheckinsInput>
  }

  export type EventAttendeeUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutEventCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateWithoutEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutEventAttendeesInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutEventAttendeeInput
  }

  export type EventAttendeeCreateOrConnectWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeCreateManyEventInputEnvelope = {
    data: EventAttendeeCreateManyEventInput | EventAttendeeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutEventInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput>
  }

  export type VisitorCreateManyEventInputEnvelope = {
    data: VisitorCreateManyEventInput | VisitorCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutEventInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutEventInput>
  }

  export type VisitorUpsertWithWhereUniqueWithoutEventInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutEventInput, VisitorUncheckedUpdateWithoutEventInput>
    create: XOR<VisitorCreateWithoutEventInput, VisitorUncheckedCreateWithoutEventInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutEventInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutEventInput, VisitorUncheckedUpdateWithoutEventInput>
  }

  export type VisitorUpdateManyWithWhereWithoutEventInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutEventInput>
  }

  export type BadgeCreateWithoutMembersInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutMembersInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutMembersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
  }

  export type BmqEnrollmentCreateWithoutMemberInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    bmqCourse: BmqCourseCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateWithoutMemberInput = {
    id?: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentCreateOrConnectWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    create: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput>
  }

  export type BmqEnrollmentCreateManyMemberInputEnvelope = {
    data: BmqEnrollmentCreateManyMemberInput | BmqEnrollmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type CheckinCreateWithoutMemberInput = {
    id?: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    badge?: BadgeCreateNestedOneWithoutCheckinsInput
    admin_users?: AdminUserCreateNestedOneWithoutCheckinsInput
  }

  export type CheckinUncheckedCreateWithoutMemberInput = {
    id?: string
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type CheckinCreateOrConnectWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    create: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput>
  }

  export type CheckinCreateManyMemberInputEnvelope = {
    data: CheckinCreateManyMemberInput | CheckinCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DivisionCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DivisionCreateOrConnectWithoutMembersInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
  }

  export type VisitorCreateWithoutHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
    visitTypeRef?: VisitTypeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput>
  }

  export type VisitorCreateManyHostMemberInputEnvelope = {
    data: VisitorCreateManyHostMemberInput | VisitorCreateManyHostMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberTagCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string | null
    tag: TagCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateWithoutMemberInput = {
    id?: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type MemberTagCreateOrConnectWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    create: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput>
  }

  export type MemberTagCreateManyMemberInputEnvelope = {
    data: MemberTagCreateManyMemberInput | MemberTagCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferredToMember?: MemberCreateNestedOneWithoutDdsTransfersInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateWithoutMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type DdsAssignmentCreateManyMemberInputEnvelope = {
    data: DdsAssignmentCreateManyMemberInput | DdsAssignmentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type DdsAssignmentCreateWithoutTransferredToMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutDdsAssignmentsInput
    assignedByAdmin?: AdminUserCreateNestedOneWithoutDdsAssignmentsInput
  }

  export type DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateOrConnectWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    create: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentCreateManyTransferredToMemberInputEnvelope = {
    data: DdsAssignmentCreateManyTransferredToMemberInput | DdsAssignmentCreateManyTransferredToMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberTypeCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeUncheckedCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTypeCreateOrConnectWithoutMembersInput = {
    where: MemberTypeWhereUniqueInput
    create: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
  }

  export type MemberStatusCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusUncheckedCreateWithoutMembersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberStatusCreateOrConnectWithoutMembersInput = {
    where: MemberStatusWhereUniqueInput
    create: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
  }

  export type BadgeUpsertWithoutMembersInput = {
    update: XOR<BadgeUpdateWithoutMembersInput, BadgeUncheckedUpdateWithoutMembersInput>
    create: XOR<BadgeCreateWithoutMembersInput, BadgeUncheckedCreateWithoutMembersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutMembersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutMembersInput, BadgeUncheckedUpdateWithoutMembersInput>
  }

  export type BadgeUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BmqEnrollmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    update: XOR<BmqEnrollmentUpdateWithoutMemberInput, BmqEnrollmentUncheckedUpdateWithoutMemberInput>
    create: XOR<BmqEnrollmentCreateWithoutMemberInput, BmqEnrollmentUncheckedCreateWithoutMemberInput>
  }

  export type BmqEnrollmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: BmqEnrollmentWhereUniqueInput
    data: XOR<BmqEnrollmentUpdateWithoutMemberInput, BmqEnrollmentUncheckedUpdateWithoutMemberInput>
  }

  export type BmqEnrollmentUpdateManyWithWhereWithoutMemberInput = {
    where: BmqEnrollmentScalarWhereInput
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type BmqEnrollmentScalarWhereInput = {
    AND?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
    OR?: BmqEnrollmentScalarWhereInput[]
    NOT?: BmqEnrollmentScalarWhereInput | BmqEnrollmentScalarWhereInput[]
    id?: UuidFilter<"BmqEnrollment"> | string
    memberId?: UuidFilter<"BmqEnrollment"> | string
    bmqCourseId?: UuidFilter<"BmqEnrollment"> | string
    enrolledAt?: DateTimeFilter<"BmqEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BmqEnrollment"> | Date | string | null
    status?: StringFilter<"BmqEnrollment"> | string
  }

  export type CheckinUpsertWithWhereUniqueWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    update: XOR<CheckinUpdateWithoutMemberInput, CheckinUncheckedUpdateWithoutMemberInput>
    create: XOR<CheckinCreateWithoutMemberInput, CheckinUncheckedCreateWithoutMemberInput>
  }

  export type CheckinUpdateWithWhereUniqueWithoutMemberInput = {
    where: CheckinWhereUniqueInput
    data: XOR<CheckinUpdateWithoutMemberInput, CheckinUncheckedUpdateWithoutMemberInput>
  }

  export type CheckinUpdateManyWithWhereWithoutMemberInput = {
    where: CheckinScalarWhereInput
    data: XOR<CheckinUpdateManyMutationInput, CheckinUncheckedUpdateManyWithoutMemberInput>
  }

  export type DivisionUpsertWithoutMembersInput = {
    update: XOR<DivisionUpdateWithoutMembersInput, DivisionUncheckedUpdateWithoutMembersInput>
    create: XOR<DivisionCreateWithoutMembersInput, DivisionUncheckedCreateWithoutMembersInput>
    where?: DivisionWhereInput
  }

  export type DivisionUpdateToOneWithWhereWithoutMembersInput = {
    where?: DivisionWhereInput
    data: XOR<DivisionUpdateWithoutMembersInput, DivisionUncheckedUpdateWithoutMembersInput>
  }

  export type DivisionUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DivisionUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpsertWithWhereUniqueWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutHostMemberInput, VisitorUncheckedUpdateWithoutHostMemberInput>
    create: XOR<VisitorCreateWithoutHostMemberInput, VisitorUncheckedCreateWithoutHostMemberInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutHostMemberInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutHostMemberInput, VisitorUncheckedUpdateWithoutHostMemberInput>
  }

  export type VisitorUpdateManyWithWhereWithoutHostMemberInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutHostMemberInput>
  }

  export type MemberTagUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    update: XOR<MemberTagUpdateWithoutMemberInput, MemberTagUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberTagCreateWithoutMemberInput, MemberTagUncheckedCreateWithoutMemberInput>
  }

  export type MemberTagUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberTagWhereUniqueInput
    data: XOR<MemberTagUpdateWithoutMemberInput, MemberTagUncheckedUpdateWithoutMemberInput>
  }

  export type MemberTagUpdateManyWithWhereWithoutMemberInput = {
    where: MemberTagScalarWhereInput
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberTagScalarWhereInput = {
    AND?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
    OR?: MemberTagScalarWhereInput[]
    NOT?: MemberTagScalarWhereInput | MemberTagScalarWhereInput[]
    id?: UuidFilter<"MemberTag"> | string
    memberId?: UuidFilter<"MemberTag"> | string
    tagId?: UuidFilter<"MemberTag"> | string
    createdAt?: DateTimeNullableFilter<"MemberTag"> | Date | string | null
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutMemberInput, DdsAssignmentUncheckedUpdateWithoutMemberInput>
    create: XOR<DdsAssignmentCreateWithoutMemberInput, DdsAssignmentUncheckedCreateWithoutMemberInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutMemberInput, DdsAssignmentUncheckedUpdateWithoutMemberInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutMemberInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutMemberInput>
  }

  export type DdsAssignmentUpsertWithWhereUniqueWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    update: XOR<DdsAssignmentUpdateWithoutTransferredToMemberInput, DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput>
    create: XOR<DdsAssignmentCreateWithoutTransferredToMemberInput, DdsAssignmentUncheckedCreateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentUpdateWithWhereUniqueWithoutTransferredToMemberInput = {
    where: DdsAssignmentWhereUniqueInput
    data: XOR<DdsAssignmentUpdateWithoutTransferredToMemberInput, DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput>
  }

  export type DdsAssignmentUpdateManyWithWhereWithoutTransferredToMemberInput = {
    where: DdsAssignmentScalarWhereInput
    data: XOR<DdsAssignmentUpdateManyMutationInput, DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberInput>
  }

  export type MemberTypeUpsertWithoutMembersInput = {
    update: XOR<MemberTypeUpdateWithoutMembersInput, MemberTypeUncheckedUpdateWithoutMembersInput>
    create: XOR<MemberTypeCreateWithoutMembersInput, MemberTypeUncheckedCreateWithoutMembersInput>
    where?: MemberTypeWhereInput
  }

  export type MemberTypeUpdateToOneWithWhereWithoutMembersInput = {
    where?: MemberTypeWhereInput
    data: XOR<MemberTypeUpdateWithoutMembersInput, MemberTypeUncheckedUpdateWithoutMembersInput>
  }

  export type MemberTypeUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTypeUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUpsertWithoutMembersInput = {
    update: XOR<MemberStatusUpdateWithoutMembersInput, MemberStatusUncheckedUpdateWithoutMembersInput>
    create: XOR<MemberStatusCreateWithoutMembersInput, MemberStatusUncheckedCreateWithoutMembersInput>
    where?: MemberStatusWhereInput
  }

  export type MemberStatusUpdateToOneWithWhereWithoutMembersInput = {
    where?: MemberStatusWhereInput
    data: XOR<MemberStatusUpdateWithoutMembersInput, MemberStatusUncheckedUpdateWithoutMembersInput>
  }

  export type MemberStatusUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberStatusUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberTagsInput
  }

  export type MemberTagUncheckedCreateWithoutTagInput = {
    id?: string
    memberId: string
    createdAt?: Date | string | null
  }

  export type MemberTagCreateOrConnectWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    create: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput>
  }

  export type MemberTagCreateManyTagInputEnvelope = {
    data: MemberTagCreateManyTagInput | MemberTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type MemberTagUpsertWithWhereUniqueWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    update: XOR<MemberTagUpdateWithoutTagInput, MemberTagUncheckedUpdateWithoutTagInput>
    create: XOR<MemberTagCreateWithoutTagInput, MemberTagUncheckedCreateWithoutTagInput>
  }

  export type MemberTagUpdateWithWhereUniqueWithoutTagInput = {
    where: MemberTagWhereUniqueInput
    data: XOR<MemberTagUpdateWithoutTagInput, MemberTagUncheckedUpdateWithoutTagInput>
  }

  export type MemberTagUpdateManyWithWhereWithoutTagInput = {
    where: MemberTagScalarWhereInput
    data: XOR<MemberTagUpdateManyMutationInput, MemberTagUncheckedUpdateManyWithoutTagInput>
  }

  export type MemberCreateWithoutMemberTagsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutMemberTagsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberTagsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
  }

  export type TagCreateWithoutMemberTagsInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    displayOrder?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagUncheckedCreateWithoutMemberTagsInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    displayOrder?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagCreateOrConnectWithoutMemberTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
  }

  export type MemberUpsertWithoutMemberTagsInput = {
    update: XOR<MemberUpdateWithoutMemberTagsInput, MemberUncheckedUpdateWithoutMemberTagsInput>
    create: XOR<MemberCreateWithoutMemberTagsInput, MemberUncheckedCreateWithoutMemberTagsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberTagsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberTagsInput, MemberUncheckedUpdateWithoutMemberTagsInput>
  }

  export type MemberUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type TagUpsertWithoutMemberTagsInput = {
    update: XOR<TagUpdateWithoutMemberTagsInput, TagUncheckedUpdateWithoutMemberTagsInput>
    create: XOR<TagCreateWithoutMemberTagsInput, TagUncheckedCreateWithoutMemberTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutMemberTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutMemberTagsInput, TagUncheckedUpdateWithoutMemberTagsInput>
  }

  export type TagUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUncheckedUpdateWithoutMemberTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUserCreateWithoutSecurityAlertsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutSecurityAlertsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutSecurityAlertsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
  }

  export type AdminUserUpsertWithoutSecurityAlertsInput = {
    update: XOR<AdminUserUpdateWithoutSecurityAlertsInput, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
    create: XOR<AdminUserCreateWithoutSecurityAlertsInput, AdminUserUncheckedCreateWithoutSecurityAlertsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutSecurityAlertsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutSecurityAlertsInput, AdminUserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type AdminUserUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserCreateWithoutVisitorsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutVisitorsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutVisitorsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
  }

  export type EventCreateWithoutVisitorsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutVisitorsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    autoExpireBadges?: boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutVisitorsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
  }

  export type MemberCreateWithoutVisitorsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutVisitorsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutVisitorsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
  }

  export type BadgeCreateWithoutVisitorsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    badgeStatusRef?: BadgeStatusCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutVisitorsInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    badgeStatusId?: string | null
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutVisitorsInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
  }

  export type VisitTypeCreateWithoutVisitorsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeUncheckedCreateWithoutVisitorsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitTypeCreateOrConnectWithoutVisitorsInput = {
    where: VisitTypeWhereUniqueInput
    create: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
  }

  export type AdminUserUpsertWithoutVisitorsInput = {
    update: XOR<AdminUserUpdateWithoutVisitorsInput, AdminUserUncheckedUpdateWithoutVisitorsInput>
    create: XOR<AdminUserCreateWithoutVisitorsInput, AdminUserUncheckedCreateWithoutVisitorsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutVisitorsInput, AdminUserUncheckedUpdateWithoutVisitorsInput>
  }

  export type AdminUserUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type EventUpsertWithoutVisitorsInput = {
    update: XOR<EventUpdateWithoutVisitorsInput, EventUncheckedUpdateWithoutVisitorsInput>
    create: XOR<EventCreateWithoutVisitorsInput, EventUncheckedCreateWithoutVisitorsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutVisitorsInput, EventUncheckedUpdateWithoutVisitorsInput>
  }

  export type EventUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    autoExpireBadges?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customRoles?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type MemberUpsertWithoutVisitorsInput = {
    update: XOR<MemberUpdateWithoutVisitorsInput, MemberUncheckedUpdateWithoutVisitorsInput>
    create: XOR<MemberCreateWithoutVisitorsInput, MemberUncheckedCreateWithoutVisitorsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutVisitorsInput, MemberUncheckedUpdateWithoutVisitorsInput>
  }

  export type MemberUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type BadgeUpsertWithoutVisitorsInput = {
    update: XOR<BadgeUpdateWithoutVisitorsInput, BadgeUncheckedUpdateWithoutVisitorsInput>
    create: XOR<BadgeCreateWithoutVisitorsInput, BadgeUncheckedCreateWithoutVisitorsInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutVisitorsInput, BadgeUncheckedUpdateWithoutVisitorsInput>
  }

  export type BadgeUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    badgeStatusRef?: BadgeStatusUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    badgeStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type VisitTypeUpsertWithoutVisitorsInput = {
    update: XOR<VisitTypeUpdateWithoutVisitorsInput, VisitTypeUncheckedUpdateWithoutVisitorsInput>
    create: XOR<VisitTypeCreateWithoutVisitorsInput, VisitTypeUncheckedCreateWithoutVisitorsInput>
    where?: VisitTypeWhereInput
  }

  export type VisitTypeUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: VisitTypeWhereInput
    data: XOR<VisitTypeUpdateWithoutVisitorsInput, VisitTypeUncheckedUpdateWithoutVisitorsInput>
  }

  export type VisitTypeUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitTypeUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BmqEnrollmentCreateWithoutBmqCourseInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    member: MemberCreateNestedOneWithoutBmqEnrollmentsInput
  }

  export type BmqEnrollmentUncheckedCreateWithoutBmqCourseInput = {
    id?: string
    memberId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentCreateOrConnectWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    create: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentCreateManyBmqCourseInputEnvelope = {
    data: BmqEnrollmentCreateManyBmqCourseInput | BmqEnrollmentCreateManyBmqCourseInput[]
    skipDuplicates?: boolean
  }

  export type BmqEnrollmentUpsertWithWhereUniqueWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    update: XOR<BmqEnrollmentUpdateWithoutBmqCourseInput, BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput>
    create: XOR<BmqEnrollmentCreateWithoutBmqCourseInput, BmqEnrollmentUncheckedCreateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentUpdateWithWhereUniqueWithoutBmqCourseInput = {
    where: BmqEnrollmentWhereUniqueInput
    data: XOR<BmqEnrollmentUpdateWithoutBmqCourseInput, BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput>
  }

  export type BmqEnrollmentUpdateManyWithWhereWithoutBmqCourseInput = {
    where: BmqEnrollmentScalarWhereInput
    data: XOR<BmqEnrollmentUpdateManyMutationInput, BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseInput>
  }

  export type BmqCourseCreateWithoutBmqEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    trainingStartTime: Date | string
    trainingEndTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingDays?: BmqCourseCreatetrainingDaysInput | string[]
  }

  export type BmqCourseCreateOrConnectWithoutBmqEnrollmentsInput = {
    where: BmqCourseWhereUniqueInput
    create: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
  }

  export type MemberCreateWithoutBmqEnrollmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutBmqEnrollmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutBmqEnrollmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
  }

  export type BmqCourseUpsertWithoutBmqEnrollmentsInput = {
    update: XOR<BmqCourseUpdateWithoutBmqEnrollmentsInput, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
    create: XOR<BmqCourseCreateWithoutBmqEnrollmentsInput, BmqCourseUncheckedCreateWithoutBmqEnrollmentsInput>
    where?: BmqCourseWhereInput
  }

  export type BmqCourseUpdateToOneWithWhereWithoutBmqEnrollmentsInput = {
    where?: BmqCourseWhereInput
    data: XOR<BmqCourseUpdateWithoutBmqEnrollmentsInput, BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type BmqCourseUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type BmqCourseUncheckedUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingDays?: BmqCourseUpdatetrainingDaysInput | string[]
  }

  export type MemberUpsertWithoutBmqEnrollmentsInput = {
    update: XOR<MemberUpdateWithoutBmqEnrollmentsInput, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
    create: XOR<MemberCreateWithoutBmqEnrollmentsInput, MemberUncheckedCreateWithoutBmqEnrollmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutBmqEnrollmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutBmqEnrollmentsInput, MemberUncheckedUpdateWithoutBmqEnrollmentsInput>
  }

  export type MemberUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutBmqEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type AdminUserCreateWithoutReport_audit_logInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutAssignedByAdminInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutReport_audit_logInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutAssignedByAdminInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutReport_audit_logInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
  }

  export type AdminUserUpsertWithoutReport_audit_logInput = {
    update: XOR<AdminUserUpdateWithoutReport_audit_logInput, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
    create: XOR<AdminUserCreateWithoutReport_audit_logInput, AdminUserUncheckedCreateWithoutReport_audit_logInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutReport_audit_logInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutReport_audit_logInput, AdminUserUncheckedUpdateWithoutReport_audit_logInput>
  }

  export type AdminUserUpdateWithoutReport_audit_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutReport_audit_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type MemberCreateWithoutDdsAssignmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutDdsAssignmentsInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutDdsAssignmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
  }

  export type MemberCreateWithoutDdsTransfersInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutDdsTransfersInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutDdsTransfersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
  }

  export type AdminUserCreateWithoutDdsAssignmentsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorCreateNestedManyWithoutAdmin_usersInput
    disabledByAdmin?: AdminUserCreateNestedOneWithoutDisabledUsersInput
    updatedByAdmin?: AdminUserCreateNestedOneWithoutUpdatedUsersInput
    disabledUsers?: AdminUserCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserUncheckedCreateWithoutDdsAssignmentsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutAdmin_usersInput
    report_audit_log?: report_audit_logUncheckedCreateNestedManyWithoutAdmin_usersInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutAcknowledgedByAdminInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutAdmin_usersInput
    disabledUsers?: AdminUserUncheckedCreateNestedManyWithoutDisabledByAdminInput
    updatedUsers?: AdminUserUncheckedCreateNestedManyWithoutUpdatedByAdminInput
  }

  export type AdminUserCreateOrConnectWithoutDdsAssignmentsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
  }

  export type MemberUpsertWithoutDdsAssignmentsInput = {
    update: XOR<MemberUpdateWithoutDdsAssignmentsInput, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
    create: XOR<MemberCreateWithoutDdsAssignmentsInput, MemberUncheckedCreateWithoutDdsAssignmentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutDdsAssignmentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutDdsAssignmentsInput, MemberUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type MemberUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberUpsertWithoutDdsTransfersInput = {
    update: XOR<MemberUpdateWithoutDdsTransfersInput, MemberUncheckedUpdateWithoutDdsTransfersInput>
    create: XOR<MemberCreateWithoutDdsTransfersInput, MemberUncheckedCreateWithoutDdsTransfersInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutDdsTransfersInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutDdsTransfersInput, MemberUncheckedUpdateWithoutDdsTransfersInput>
  }

  export type MemberUpdateWithoutDdsTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutDdsTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AdminUserUpsertWithoutDdsAssignmentsInput = {
    update: XOR<AdminUserUpdateWithoutDdsAssignmentsInput, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
    create: XOR<AdminUserCreateWithoutDdsAssignmentsInput, AdminUserUncheckedCreateWithoutDdsAssignmentsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutDdsAssignmentsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutDdsAssignmentsInput, AdminUserUncheckedUpdateWithoutDdsAssignmentsInput>
  }

  export type AdminUserUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDdsAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type MemberCreateWithoutMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberTypeRef?: MemberTypeCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput>
  }

  export type MemberCreateManyMemberStatusRefInputEnvelope = {
    data: MemberCreateManyMemberStatusRefInput | MemberCreateManyMemberStatusRefInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutMemberStatusRefInput, MemberUncheckedUpdateWithoutMemberStatusRefInput>
    create: XOR<MemberCreateWithoutMemberStatusRefInput, MemberUncheckedCreateWithoutMemberStatusRefInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutMemberStatusRefInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutMemberStatusRefInput, MemberUncheckedUpdateWithoutMemberStatusRefInput>
  }

  export type MemberUpdateManyWithWhereWithoutMemberStatusRefInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberStatusRefInput>
  }

  export type MemberCreateWithoutMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    memberType: string
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    badge?: BadgeCreateNestedOneWithoutMembersInput
    bmqEnrollments?: BmqEnrollmentCreateNestedManyWithoutMemberInput
    checkins?: CheckinCreateNestedManyWithoutMemberInput
    division?: DivisionCreateNestedOneWithoutMembersInput
    visitors?: VisitorCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentCreateNestedManyWithoutTransferredToMemberInput
    memberStatusRef?: MemberStatusCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedCreateNestedManyWithoutMemberInput
    checkins?: CheckinUncheckedCreateNestedManyWithoutMemberInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutHostMemberInput
    memberTags?: MemberTagUncheckedCreateNestedManyWithoutMemberInput
    ddsAssignments?: DdsAssignmentUncheckedCreateNestedManyWithoutMemberInput
    ddsTransfers?: DdsAssignmentUncheckedCreateNestedManyWithoutTransferredToMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput>
  }

  export type MemberCreateManyMemberTypeRefInputEnvelope = {
    data: MemberCreateManyMemberTypeRefInput | MemberCreateManyMemberTypeRefInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutMemberTypeRefInput, MemberUncheckedUpdateWithoutMemberTypeRefInput>
    create: XOR<MemberCreateWithoutMemberTypeRefInput, MemberUncheckedCreateWithoutMemberTypeRefInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutMemberTypeRefInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutMemberTypeRefInput, MemberUncheckedUpdateWithoutMemberTypeRefInput>
  }

  export type MemberUpdateManyWithWhereWithoutMemberTypeRefInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberTypeRefInput>
  }

  export type VisitorCreateWithoutVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    admin_users?: AdminUserCreateNestedOneWithoutVisitorsInput
    event?: EventCreateNestedOneWithoutVisitorsInput
    hostMember?: MemberCreateNestedOneWithoutVisitorsInput
    badge?: BadgeCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorCreateOrConnectWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput>
  }

  export type VisitorCreateManyVisitTypeRefInputEnvelope = {
    data: VisitorCreateManyVisitTypeRefInput | VisitorCreateManyVisitTypeRefInput[]
    skipDuplicates?: boolean
  }

  export type VisitorUpsertWithWhereUniqueWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutVisitTypeRefInput, VisitorUncheckedUpdateWithoutVisitTypeRefInput>
    create: XOR<VisitorCreateWithoutVisitTypeRefInput, VisitorUncheckedCreateWithoutVisitTypeRefInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutVisitTypeRefInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutVisitTypeRefInput, VisitorUncheckedUpdateWithoutVisitTypeRefInput>
  }

  export type VisitorUpdateManyWithWhereWithoutVisitTypeRefInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutVisitTypeRefInput>
  }

  export type BadgeCreateWithoutBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinCreateNestedManyWithoutBadgeInput
    members?: MemberCreateNestedManyWithoutBadgeInput
    visitors?: VisitorCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateWithoutBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    checkins?: CheckinUncheckedCreateNestedManyWithoutBadgeInput
    eventAttendees?: EventAttendeeUncheckedCreateNestedManyWithoutBadgeInput
    eventCheckins?: EventCheckinUncheckedCreateNestedManyWithoutBadgeInput
    members?: MemberUncheckedCreateNestedManyWithoutBadgeInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput>
  }

  export type BadgeCreateManyBadgeStatusRefInputEnvelope = {
    data: BadgeCreateManyBadgeStatusRefInput | BadgeCreateManyBadgeStatusRefInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithWhereUniqueWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutBadgeStatusRefInput, BadgeUncheckedUpdateWithoutBadgeStatusRefInput>
    create: XOR<BadgeCreateWithoutBadgeStatusRefInput, BadgeUncheckedCreateWithoutBadgeStatusRefInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutBadgeStatusRefInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutBadgeStatusRefInput, BadgeUncheckedUpdateWithoutBadgeStatusRefInput>
  }

  export type BadgeUpdateManyWithWhereWithoutBadgeStatusRefInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutBadgeStatusRefInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: UuidFilter<"Badge"> | string
    serialNumber?: StringFilter<"Badge"> | string
    assignmentType?: StringFilter<"Badge"> | string
    assignedToId?: UuidNullableFilter<"Badge"> | string | null
    status?: StringFilter<"Badge"> | string
    badgeStatusId?: UuidNullableFilter<"Badge"> | string | null
    lastUsed?: DateTimeNullableFilter<"Badge"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Badge"> | Date | string | null
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    role?: string
    badgeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogCreateManyAdminUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string | null
  }

  export type CheckinCreateManyAdmin_usersInput = {
    id?: string
    memberId?: string | null
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
  }

  export type report_audit_logCreateManyAdmin_usersInput = {
    id?: string
    report_type: string
    report_config: JsonNullValueInput | InputJsonValue
    is_scheduled?: boolean | null
    scheduled_report_id?: string | null
    generated_at?: Date | string | null
    file_size_bytes?: number | null
    generation_time_ms?: number | null
  }

  export type SecurityAlertCreateManyAcknowledgedByAdminInput = {
    id?: string
    alertType: string
    severity: string
    badgeSerial?: string | null
    memberId?: string | null
    kioskId: string
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgeNote?: string | null
    createdAt?: Date | string
  }

  export type VisitorCreateManyAdmin_usersInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
  }

  export type DdsAssignmentCreateManyAssignedByAdminInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserCreateManyDisabledByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    updatedBy?: string | null
  }

  export type AdminUserCreateManyUpdatedByAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    displayName: string
    fullName?: string | null
    role: string
    lastLogin?: Date | string | null
    createdAt?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    updated_at?: Date | string | null
    disabled?: boolean
    disabledAt?: Date | string | null
    disabledBy?: string | null
  }

  export type AuditLogUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckinUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_audit_logUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type report_audit_logUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    report_config?: JsonNullValueInput | InputJsonValue
    is_scheduled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scheduled_report_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SecurityAlertUpdateWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    badgeSerial?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgeNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DdsAssignmentUpdateWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUpdateWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    updatedByAdmin?: AdminUserUpdateOneWithoutUpdatedUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateManyWithoutDisabledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUserUpdateWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutAssignedByAdminNestedInput
    disabledByAdmin?: AdminUserUpdateOneWithoutDisabledUsersNestedInput
    disabledUsers?: AdminUserUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutAdmin_usersNestedInput
    report_audit_log?: report_audit_logUncheckedUpdateManyWithoutAdmin_usersNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutAcknowledgedByAdminNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutAdmin_usersNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutAssignedByAdminNestedInput
    disabledUsers?: AdminUserUncheckedUpdateManyWithoutDisabledByAdminNestedInput
    updatedUsers?: AdminUserUncheckedUpdateManyWithoutUpdatedByAdminNestedInput
  }

  export type AdminUserUncheckedUpdateManyWithoutUpdatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinCreateManyBadgeInput = {
    id?: string
    memberId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type EventAttendeeCreateManyBadgeInput = {
    id?: string
    eventId: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EventCheckinCreateManyBadgeInput = {
    id?: string
    eventAttendeeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type MemberCreateManyBadgeInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
  }

  export type VisitorCreateManyBadgeInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type CheckinUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
    member?: MemberUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventAttendeeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventAttendee?: EventAttendeeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventAttendeeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateManyDivisionInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
  }

  export type MemberUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinCreateManyEventAttendeeInput = {
    id?: string
    badgeId: string
    direction: string
    timestamp?: Date | string
    kioskId: string
    createdAt?: Date | string | null
  }

  export type EventCheckinUpdateWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneRequiredWithoutEventCheckinsNestedInput
  }

  export type EventCheckinUncheckedUpdateWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCheckinUncheckedUpdateManyWithoutEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventAttendeeCreateManyEventInput = {
    id?: string
    name: string
    rank?: string | null
    organization: string
    role: string
    badgeId?: string | null
    badgeAssignedAt?: Date | string | null
    accessStart?: Date | string | null
    accessEnd?: Date | string | null
    status?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VisitorCreateManyEventInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type EventAttendeeUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutEventAttendeesNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutEventAttendeeNestedInput
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeAssignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmqEnrollmentCreateManyMemberInput = {
    id?: string
    bmqCourseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type CheckinCreateManyMemberInput = {
    id?: string
    badgeId?: string | null
    direction: string
    timestamp?: Date | string
    kioskId: string
    synced?: boolean | null
    createdAt?: Date | string | null
    flagged_for_review?: boolean | null
    flag_reason?: string | null
    method?: string | null
    created_by_admin?: string | null
  }

  export type VisitorCreateManyHostMemberInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitTypeId?: string | null
    visitReason?: string | null
    eventId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type MemberTagCreateManyMemberInput = {
    id?: string
    tagId: string
    createdAt?: Date | string | null
  }

  export type DdsAssignmentCreateManyMemberInput = {
    id?: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    transferredTo?: string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DdsAssignmentCreateManyTransferredToMemberInput = {
    id?: string
    memberId: string
    assignedDate: Date | string
    acceptedAt?: Date | string | null
    releasedAt?: Date | string | null
    assignedBy?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BmqEnrollmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    bmqCourse?: BmqCourseUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    bmqCourseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CheckinUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    badge?: BadgeUpdateOneWithoutCheckinsNestedInput
    admin_users?: AdminUserUpdateOneWithoutCheckinsNestedInput
  }

  export type CheckinUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckinUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: StringFieldUpdateOperationsInput | string
    synced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_for_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flag_reason?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_admin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUpdateWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
    visitTypeRef?: VisitTypeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutHostMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberTagUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: TagUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DdsAssignmentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferredToMember?: MemberUpdateOneWithoutDdsTransfersNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferredTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUpdateWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutDdsAssignmentsNestedInput
    assignedByAdmin?: AdminUserUpdateOneWithoutDdsAssignmentsNestedInput
  }

  export type DdsAssignmentUncheckedUpdateWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberTagCreateManyTagInput = {
    id?: string
    memberId: string
    createdAt?: Date | string | null
  }

  export type MemberTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberTagsNestedInput
  }

  export type MemberTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BmqEnrollmentCreateManyBmqCourseInput = {
    id?: string
    memberId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
  }

  export type BmqEnrollmentUpdateWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    member?: MemberUpdateOneRequiredWithoutBmqEnrollmentsNestedInput
  }

  export type BmqEnrollmentUncheckedUpdateWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BmqEnrollmentUncheckedUpdateManyWithoutBmqCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyMemberStatusRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
  }

  export type MemberUpdateWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberTypeRef?: MemberTypeUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMemberStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateManyMemberTypeRefInput = {
    id?: string
    serviceNumber: string
    rank: string
    firstName: string
    lastName: string
    email?: string | null
    mobilePhone?: string | null
    divisionId?: string | null
    badgeId?: string | null
    memberType: string
    status?: string
    memberStatusId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employeeNumber?: string | null
    initials?: string | null
    mess?: string | null
    moc?: string | null
    classDetails?: string | null
    homePhone?: string | null
    notes?: string | null
    contract_start?: Date | string | null
    contract_end?: Date | string | null
  }

  export type MemberUpdateWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: BadgeUpdateOneWithoutMembersNestedInput
    bmqEnrollments?: BmqEnrollmentUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUpdateManyWithoutMemberNestedInput
    division?: DivisionUpdateOneWithoutMembersNestedInput
    visitors?: VisitorUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUpdateManyWithoutTransferredToMemberNestedInput
    memberStatusRef?: MemberStatusUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bmqEnrollments?: BmqEnrollmentUncheckedUpdateManyWithoutMemberNestedInput
    checkins?: CheckinUncheckedUpdateManyWithoutMemberNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutHostMemberNestedInput
    memberTags?: MemberTagUncheckedUpdateManyWithoutMemberNestedInput
    ddsAssignments?: DdsAssignmentUncheckedUpdateManyWithoutMemberNestedInput
    ddsTransfers?: DdsAssignmentUncheckedUpdateManyWithoutTransferredToMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMemberTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceNumber?: StringFieldUpdateOperationsInput | string
    rank?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    badgeId?: NullableStringFieldUpdateOperationsInput | string | null
    memberType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    memberStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    mess?: NullableStringFieldUpdateOperationsInput | string | null
    moc?: NullableStringFieldUpdateOperationsInput | string | null
    classDetails?: NullableStringFieldUpdateOperationsInput | string | null
    homePhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    contract_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitorCreateManyVisitTypeRefInput = {
    id?: string
    name: string
    organization?: string | null
    visitType: string
    visitReason?: string | null
    eventId?: string | null
    hostMemberId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    temporaryBadgeId?: string | null
    kioskId: string
    createdAt?: Date | string | null
    adminNotes?: string | null
    checkInMethod?: string | null
    createdByAdmin?: string | null
  }

  export type VisitorUpdateWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users?: AdminUserUpdateOneWithoutVisitorsNestedInput
    event?: EventUpdateOneWithoutVisitorsNestedInput
    hostMember?: MemberUpdateOneWithoutVisitorsNestedInput
    badge?: BadgeUpdateOneWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorUncheckedUpdateManyWithoutVisitTypeRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    visitType?: StringFieldUpdateOperationsInput | string
    visitReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    hostMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temporaryBadgeId?: NullableStringFieldUpdateOperationsInput | string | null
    kioskId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgeCreateManyBadgeStatusRefInput = {
    id?: string
    serialNumber: string
    assignmentType: string
    assignedToId?: string | null
    status?: string
    lastUsed?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BadgeUpdateWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUpdateManyWithoutBadgeNestedInput
    members?: MemberUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkins?: CheckinUncheckedUpdateManyWithoutBadgeNestedInput
    eventAttendees?: EventAttendeeUncheckedUpdateManyWithoutBadgeNestedInput
    eventCheckins?: EventCheckinUncheckedUpdateManyWithoutBadgeNestedInput
    members?: MemberUncheckedUpdateManyWithoutBadgeNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateManyWithoutBadgeStatusRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}